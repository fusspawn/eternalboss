{"ts":1349185995911,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved. \r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \r\n \r\nTHIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \r\nMERCHANTABLITY OR NON-INFRINGEMENT. \r\n \r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    function hasFlag(val, flag) {\r\n        return (val & flag) != 0;\r\n    }\r\n    TypeScript.hasFlag = hasFlag;\r\n    (function (ErrorRecoverySet) {\r\n        ErrorRecoverySet._map = [];\r\n        ErrorRecoverySet.None = 0;\r\n        ErrorRecoverySet.Comma = 1;\r\n        ErrorRecoverySet.SColon = 1 << 1;\r\n        ErrorRecoverySet.Asg = 1 << 2;\r\n        ErrorRecoverySet.BinOp = 1 << 3;\r\n        ErrorRecoverySet.RBrack = 1 << 4;\r\n        ErrorRecoverySet.RCurly = 1 << 5;\r\n        ErrorRecoverySet.RParen = 1 << 6;\r\n        ErrorRecoverySet.Dot = 1 << 7;\r\n        ErrorRecoverySet.Colon = 1 << 8;\r\n        ErrorRecoverySet.PrimType = 1 << 9;\r\n        ErrorRecoverySet.AddOp = 1 << 10;\r\n        ErrorRecoverySet.LCurly = 1 << 11;\r\n        ErrorRecoverySet.PreOp = 1 << 12;\r\n        ErrorRecoverySet.RegExp = 1 << 13;\r\n        ErrorRecoverySet.LParen = 1 << 14;\r\n        ErrorRecoverySet.LBrack = 1 << 15;\r\n        ErrorRecoverySet.Scope = 1 << 16;\r\n        ErrorRecoverySet.In = 1 << 17;\r\n        ErrorRecoverySet.SCase = 1 << 18;\r\n        ErrorRecoverySet.Else = 1 << 19;\r\n        ErrorRecoverySet.Catch = 1 << 20;\r\n        ErrorRecoverySet.Var = 1 << 21;\r\n        ErrorRecoverySet.Stmt = 1 << 22;\r\n        ErrorRecoverySet.While = 1 << 23;\r\n        ErrorRecoverySet.ID = 1 << 24;\r\n        ErrorRecoverySet.Prefix = 1 << 25;\r\n        ErrorRecoverySet.Literal = 1 << 26;\r\n        ErrorRecoverySet.RLit = 1 << 27;\r\n        ErrorRecoverySet.Func = 1 << 28;\r\n        ErrorRecoverySet.EOF = 1 << 29;\r\n        ErrorRecoverySet.TypeScriptS = 1 << 30;\r\n        ErrorRecoverySet.ExprStart = ErrorRecoverySet.SColon | ErrorRecoverySet.AddOp | ErrorRecoverySet.LCurly | ErrorRecoverySet.PreOp | ErrorRecoverySet.RegExp | ErrorRecoverySet.LParen | ErrorRecoverySet.LBrack | ErrorRecoverySet.ID | ErrorRecoverySet.Prefix | ErrorRecoverySet.RLit | ErrorRecoverySet.Func | ErrorRecoverySet.Literal;\r\n        ErrorRecoverySet.StmtStart = ErrorRecoverySet.ExprStart | ErrorRecoverySet.SColon | ErrorRecoverySet.Var | ErrorRecoverySet.Stmt | ErrorRecoverySet.While | ErrorRecoverySet.TypeScriptS;\r\n        ErrorRecoverySet.Postfix = ErrorRecoverySet.Dot | ErrorRecoverySet.LParen | ErrorRecoverySet.LBrack;\r\n    })(TypeScript.ErrorRecoverySet || (TypeScript.ErrorRecoverySet = {}));\r\n    var ErrorRecoverySet = TypeScript.ErrorRecoverySet;\r\n\r\n    (function (AllowedElements) {\r\n        AllowedElements._map = [];\r\n        AllowedElements.None = 0;\r\n        AllowedElements.Statements = 1;\r\n        AllowedElements.FunctionDecls = 1 << 1;\r\n        AllowedElements.ModuleDecls = 1 << 2;\r\n        AllowedElements.ClassDecls = 1 << 3;\r\n        AllowedElements.InterfaceDecls = 1 << 4;\r\n        AllowedElements.TypedFuncDecls = 1 << 5;\r\n        AllowedElements.TypedDecls = 1 << 6;\r\n        AllowedElements.TypedFuncSignatures = 1 << 8;\r\n        AllowedElements.TypedSignatures = 1 << 9;\r\n        AllowedElements.AmbientDecls = 1 << 10;\r\n        AllowedElements.Properties = 1 << 11;\r\n        AllowedElements.Block = AllowedElements.Statements | AllowedElements.FunctionDecls | AllowedElements.TypedFuncDecls | AllowedElements.TypedDecls;\r\n        AllowedElements.Global = AllowedElements.Statements | AllowedElements.FunctionDecls | AllowedElements.ModuleDecls | AllowedElements.ClassDecls | AllowedElements.InterfaceDecls | AllowedElements.AmbientDecls;\r\n        AllowedElements.FunctionBody = AllowedElements.Statements | AllowedElements.FunctionDecls;\r\n        AllowedElements.ModuleMembers = AllowedElements.TypedFuncDecls | AllowedElements.FunctionDecls | AllowedElements.ModuleDecls | AllowedElements.ClassDecls | AllowedElements.InterfaceDecls | AllowedElements.TypedDecls | AllowedElements.Statements | AllowedElements.AmbientDecls;\r\n        AllowedElements.ClassMembers = AllowedElements.TypedFuncDecls | AllowedElements.FunctionDecls | AllowedElements.Statements | AllowedElements.TypedDecls | AllowedElements.Properties;\r\n        AllowedElements.InterfaceMembers = AllowedElements.TypedFuncSignatures | AllowedElements.TypedSignatures;\r\n        AllowedElements.QuickParse = AllowedElements.Global | AllowedElements.Properties;\r\n    })(TypeScript.AllowedElements || (TypeScript.AllowedElements = {}));\r\n    var AllowedElements = TypeScript.AllowedElements;\r\n\r\n    (function (Modifiers) {\r\n        Modifiers._map = [];\r\n        Modifiers.None = 0;\r\n        Modifiers.Private = 1;\r\n        Modifiers.Public = 1 << 1;\r\n        Modifiers.Readonly = 1 << 2;\r\n        Modifiers.Ambient = 1 << 3;\r\n        Modifiers.Exported = 1 << 4;\r\n        Modifiers.Getter = 1 << 5;\r\n        Modifiers.Setter = 1 << 6;\r\n        Modifiers.Static = 1 << 7;\r\n    })(TypeScript.Modifiers || (TypeScript.Modifiers = {}));\r\n    var Modifiers = TypeScript.Modifiers;\r\n\r\n    (function (ASTFlags) {\r\n        ASTFlags._map = [];\r\n        ASTFlags.None = 0;\r\n        ASTFlags.ExplicitSemicolon = 1;\r\n        ASTFlags.AutomaticSemicolon = 1 << 1;\r\n        ASTFlags.Writeable = 1 << 2;\r\n        ASTFlags.Error = 1 << 3;\r\n        ASTFlags.DotLHSPartial = 1 << 4;\r\n        ASTFlags.DotLHS = 1 << 5;\r\n        ASTFlags.IsStatement = 1 << 6;\r\n        ASTFlags.StrictMode = 1 << 7;\r\n        ASTFlags.PossibleOptionalParameter = 1 << 8;\r\n        ASTFlags.ClassBaseConstructorCall = 1 << 9;\r\n        ASTFlags.OptionalName = 1 << 10;\r\n    })(TypeScript.ASTFlags || (TypeScript.ASTFlags = {}));\r\n    var ASTFlags = TypeScript.ASTFlags;\r\n\r\n    (function (DeclFlags) {\r\n        DeclFlags._map = [];\r\n        DeclFlags.None = 0;\r\n        DeclFlags.Exported = 1;\r\n        DeclFlags.Private = 1 << 1;\r\n        DeclFlags.Public = 1 << 2;\r\n        DeclFlags.Ambient = 1 << 3;\r\n        DeclFlags.Static = 1 << 4;\r\n        DeclFlags.LocalStatic = 1 << 5;\r\n        DeclFlags.GetAccessor = 1 << 6;\r\n        DeclFlags.SetAccessor = 1 << 7;\r\n    })(TypeScript.DeclFlags || (TypeScript.DeclFlags = {}));\r\n    var DeclFlags = TypeScript.DeclFlags;\r\n\r\n    (function (ModuleFlags) {\r\n        ModuleFlags._map = [];\r\n        ModuleFlags.None = 0;\r\n        ModuleFlags.Exported = 1;\r\n        ModuleFlags.Private = 1 << 1;\r\n        ModuleFlags.Public = 1 << 2;\r\n        ModuleFlags.Ambient = 1 << 3;\r\n        ModuleFlags.Static = 1 << 4;\r\n        ModuleFlags.LocalStatic = 1 << 5;\r\n        ModuleFlags.GetAccessor = 1 << 6;\r\n        ModuleFlags.SetAccessor = 1 << 7;\r\n        ModuleFlags.IsEnum = 1 << 8;\r\n        ModuleFlags.ShouldEmitModuleDecl = 1 << 9;\r\n        ModuleFlags.IsWholeFile = 1 << 10;\r\n        ModuleFlags.IsDynamic = 1 << 11;\r\n    })(TypeScript.ModuleFlags || (TypeScript.ModuleFlags = {}));\r\n    var ModuleFlags = TypeScript.ModuleFlags;\r\n\r\n    (function (SymbolFlags) {\r\n        SymbolFlags._map = [];\r\n        SymbolFlags.None = 0;\r\n        SymbolFlags.Exported = 1;\r\n        SymbolFlags.Private = 1 << 1;\r\n        SymbolFlags.Public = 1 << 2;\r\n        SymbolFlags.Ambient = 1 << 3;\r\n        SymbolFlags.Static = 1 << 4;\r\n        SymbolFlags.LocalStatic = 1 << 5;\r\n        SymbolFlags.GetAccessor = 1 << 6;\r\n        SymbolFlags.SetAccessor = 1 << 7;\r\n        SymbolFlags.Property = 1 << 8;\r\n        SymbolFlags.Readonly = 1 << 9;\r\n        SymbolFlags.ModuleMember = 1 << 10;\r\n        SymbolFlags.InterfaceMember = 1 << 11;\r\n        SymbolFlags.ClassMember = 1 << 12;\r\n        SymbolFlags.BuiltIn = 1 << 13;\r\n        SymbolFlags.TypeSetDuringScopeAssignment = 1 << 14;\r\n        SymbolFlags.Constant = 1 << 15;\r\n        SymbolFlags.Optional = 1 << 16;\r\n        SymbolFlags.RecursivelyReferenced = 1 << 17;\r\n        SymbolFlags.Bound = 1 << 18;\r\n    })(TypeScript.SymbolFlags || (TypeScript.SymbolFlags = {}));\r\n    var SymbolFlags = TypeScript.SymbolFlags;\r\n\r\n    (function (VarFlags) {\r\n        VarFlags._map = [];\r\n        VarFlags.None = 0;\r\n        VarFlags.Exported = 1;\r\n        VarFlags.Private = 1 << 1;\r\n        VarFlags.Public = 1 << 2;\r\n        VarFlags.Ambient = 1 << 3;\r\n        VarFlags.Static = 1 << 4;\r\n        VarFlags.LocalStatic = 1 << 5;\r\n        VarFlags.GetAccessor = 1 << 6;\r\n        VarFlags.SetAccessor = 1 << 7;\r\n        VarFlags.AutoInit = 1 << 8;\r\n        VarFlags.Property = 1 << 9;\r\n        VarFlags.Readonly = 1 << 10;\r\n        VarFlags.Class = 1 << 11;\r\n        VarFlags.ClassProperty = 1 << 12;\r\n        VarFlags.ClassBodyProperty = 1 << 13;\r\n        VarFlags.ClassConstructorProperty = 1 << 14;\r\n        VarFlags.ClassSuperMustBeFirstCallInConstructor = 1 << 15;\r\n        VarFlags.Constant = 1 << 16;\r\n    })(TypeScript.VarFlags || (TypeScript.VarFlags = {}));\r\n    var VarFlags = TypeScript.VarFlags;\r\n\r\n    (function (FncFlags) {\r\n        FncFlags._map = [];\r\n        FncFlags.None = 0;\r\n        FncFlags.Exported = 1;\r\n        FncFlags.Private = 1 << 1;\r\n        FncFlags.Public = 1 << 2;\r\n        FncFlags.Ambient = 1 << 3;\r\n        FncFlags.Static = 1 << 4;\r\n        FncFlags.LocalStatic = 1 << 5;\r\n        FncFlags.GetAccessor = 1 << 6;\r\n        FncFlags.SetAccessor = 1 << 7;\r\n        FncFlags.Definition = 1 << 8;\r\n        FncFlags.Signature = 1 << 9;\r\n        FncFlags.Method = 1 << 10;\r\n        FncFlags.HasReturnExpression = 1 << 11;\r\n        FncFlags.CallMember = 1 << 12;\r\n        FncFlags.ConstructMember = 1 << 13;\r\n        FncFlags.HasSelfReference = 1 << 14;\r\n        FncFlags.IsFatArrowFunction = 1 << 15;\r\n        FncFlags.IndexerMember = 1 << 16;\r\n        FncFlags.IsFunctionExpression = 1 << 17;\r\n        FncFlags.ClassMethod = 1 << 18;\r\n        FncFlags.ClassPropertyMethodExported = 1 << 19;\r\n    })(TypeScript.FncFlags || (TypeScript.FncFlags = {}));\r\n    var FncFlags = TypeScript.FncFlags;\r\n\r\n    (function (SignatureFlags) {\r\n        SignatureFlags._map = [];\r\n        SignatureFlags.None = 0;\r\n        SignatureFlags.IsIndexer = 1;\r\n        SignatureFlags.IsStringIndexer = 1 << 1;\r\n        SignatureFlags.IsNumberIndexer = 1 << 2;\r\n    })(TypeScript.SignatureFlags || (TypeScript.SignatureFlags = {}));\r\n    var SignatureFlags = TypeScript.SignatureFlags;\r\n\r\n                    function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags) {\r\n        return fncOrVarOrSymbolOrModuleFlags;\r\n    }\r\n    TypeScript.ToDeclFlags = ToDeclFlags;\r\n    (function (TypeFlags) {\r\n        TypeFlags._map = [];\r\n        TypeFlags.None = 0;\r\n        TypeFlags.HasImplementation = 1;\r\n        TypeFlags.HasSelfReference = 1 << 1;\r\n        TypeFlags.MergeResult = 1 << 2;\r\n        TypeFlags.IsEnum = 1 << 3;\r\n        TypeFlags.BuildingName = 1 << 4;\r\n        TypeFlags.HasBaseType = 1 << 5;\r\n        TypeFlags.HasBaseTypeOfObject = 1 << 6;\r\n        TypeFlags.IsClass = 1 << 7;\r\n    })(TypeScript.TypeFlags || (TypeScript.TypeFlags = {}));\r\n    var TypeFlags = TypeScript.TypeFlags;\r\n\r\n    (function (TypeRelationshipFlags) {\r\n        TypeRelationshipFlags._map = [];\r\n        TypeRelationshipFlags.SuccessfulComparison = 0;\r\n        TypeRelationshipFlags.SourceIsNullTargetIsVoidOrUndefined = 1;\r\n        TypeRelationshipFlags.RequiredPropertyIsMissing = 1 << 1;\r\n        TypeRelationshipFlags.IncompatibleSignatures = 1 << 2;\r\n        TypeRelationshipFlags.SourceSignatureHasTooManyParameters = 3;\r\n        TypeRelationshipFlags.IncompatibleReturnTypes = 1 << 4;\r\n        TypeRelationshipFlags.IncompatiblePropertyTypes = 1 << 5;\r\n        TypeRelationshipFlags.IncompatibleParameterTypes = 1 << 6;\r\n    })(TypeScript.TypeRelationshipFlags || (TypeScript.TypeRelationshipFlags = {}));\r\n    var TypeRelationshipFlags = TypeScript.TypeRelationshipFlags;\r\n\r\n    (function (CodeGenTarget) {\r\n        CodeGenTarget._map = [];\r\n        CodeGenTarget.ES3 = 0;\r\n        CodeGenTarget.ES5 = 1;\r\n    })(TypeScript.CodeGenTarget || (TypeScript.CodeGenTarget = {}));\r\n    var CodeGenTarget = TypeScript.CodeGenTarget;\r\n\r\n    (function (ModuleGenTarget) {\r\n        ModuleGenTarget._map = [];\r\n        ModuleGenTarget.Synchronous = 0;\r\n        ModuleGenTarget.Asynchronous = 1;\r\n        ModuleGenTarget.Local = 1 << 1;\r\n    })(TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));\r\n    var ModuleGenTarget = TypeScript.ModuleGenTarget;\r\n\r\n    TypeScript.codeGenTarget = CodeGenTarget.ES3;\r\n    TypeScript.moduleGenTarget = ModuleGenTarget.Synchronous;\r\n    TypeScript.optimizeModuleCodeGen = true;\r\n    function flagsToString(e, flags) {\r\n        var builder = \"\";\r\n        for(var i = 1; i < (1 << 31); i = i << 1) {\r\n            if((flags & i) != 0) {\r\n                for(var k in e) {\r\n                    if(e[k] == i) {\r\n                        if(builder.length > 0) {\r\n                            builder += \"|\";\r\n                        }\r\n                        builder += k;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return builder;\r\n    }\r\n    TypeScript.flagsToString = flagsToString;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (NodeType) {\r\n        NodeType._map = [];\r\n        NodeType._map[0] = \"None\";\r\n        NodeType.None = 0;\r\n        NodeType._map[1] = \"Empty\";\r\n        NodeType.Empty = 1;\r\n        NodeType._map[2] = \"EmptyExpr\";\r\n        NodeType.EmptyExpr = 2;\r\n        NodeType._map[3] = \"True\";\r\n        NodeType.True = 3;\r\n        NodeType._map[4] = \"False\";\r\n        NodeType.False = 4;\r\n        NodeType._map[5] = \"This\";\r\n        NodeType.This = 5;\r\n        NodeType._map[6] = \"Super\";\r\n        NodeType.Super = 6;\r\n        NodeType._map[7] = \"QString\";\r\n        NodeType.QString = 7;\r\n        NodeType._map[8] = \"Regex\";\r\n        NodeType.Regex = 8;\r\n        NodeType._map[9] = \"Null\";\r\n        NodeType.Null = 9;\r\n        NodeType._map[10] = \"ArrayLit\";\r\n        NodeType.ArrayLit = 10;\r\n        NodeType._map[11] = \"ObjectLit\";\r\n        NodeType.ObjectLit = 11;\r\n        NodeType._map[12] = \"Void\";\r\n        NodeType.Void = 12;\r\n        NodeType._map[13] = \"Comma\";\r\n        NodeType.Comma = 13;\r\n        NodeType._map[14] = \"Pos\";\r\n        NodeType.Pos = 14;\r\n        NodeType._map[15] = \"Neg\";\r\n        NodeType.Neg = 15;\r\n        NodeType._map[16] = \"Delete\";\r\n        NodeType.Delete = 16;\r\n        NodeType._map[17] = \"Await\";\r\n        NodeType.Await = 17;\r\n        NodeType._map[18] = \"In\";\r\n        NodeType.In = 18;\r\n        NodeType._map[19] = \"Dot\";\r\n        NodeType.Dot = 19;\r\n        NodeType._map[20] = \"From\";\r\n        NodeType.From = 20;\r\n        NodeType._map[21] = \"Is\";\r\n        NodeType.Is = 21;\r\n        NodeType._map[22] = \"InstOf\";\r\n        NodeType.InstOf = 22;\r\n        NodeType._map[23] = \"Typeof\";\r\n        NodeType.Typeof = 23;\r\n        NodeType._map[24] = \"NumberLit\";\r\n        NodeType.NumberLit = 24;\r\n        NodeType._map[25] = \"Name\";\r\n        NodeType.Name = 25;\r\n        NodeType._map[26] = \"TypeRef\";\r\n        NodeType.TypeRef = 26;\r\n        NodeType._map[27] = \"Index\";\r\n        NodeType.Index = 27;\r\n        NodeType._map[28] = \"Call\";\r\n        NodeType.Call = 28;\r\n        NodeType._map[29] = \"New\";\r\n        NodeType.New = 29;\r\n        NodeType._map[30] = \"Asg\";\r\n        NodeType.Asg = 30;\r\n        NodeType._map[31] = \"AsgAdd\";\r\n        NodeType.AsgAdd = 31;\r\n        NodeType._map[32] = \"AsgSub\";\r\n        NodeType.AsgSub = 32;\r\n        NodeType._map[33] = \"AsgDiv\";\r\n        NodeType.AsgDiv = 33;\r\n        NodeType._map[34] = \"AsgMul\";\r\n        NodeType.AsgMul = 34;\r\n        NodeType._map[35] = \"AsgMod\";\r\n        NodeType.AsgMod = 35;\r\n        NodeType._map[36] = \"AsgAnd\";\r\n        NodeType.AsgAnd = 36;\r\n        NodeType._map[37] = \"AsgXor\";\r\n        NodeType.AsgXor = 37;\r\n        NodeType._map[38] = \"AsgOr\";\r\n        NodeType.AsgOr = 38;\r\n        NodeType._map[39] = \"AsgLsh\";\r\n        NodeType.AsgLsh = 39;\r\n        NodeType._map[40] = \"AsgRsh\";\r\n        NodeType.AsgRsh = 40;\r\n        NodeType._map[41] = \"AsgRs2\";\r\n        NodeType.AsgRs2 = 41;\r\n        NodeType._map[42] = \"QMark\";\r\n        NodeType.QMark = 42;\r\n        NodeType._map[43] = \"LogOr\";\r\n        NodeType.LogOr = 43;\r\n        NodeType._map[44] = \"LogAnd\";\r\n        NodeType.LogAnd = 44;\r\n        NodeType._map[45] = \"Or\";\r\n        NodeType.Or = 45;\r\n        NodeType._map[46] = \"Xor\";\r\n        NodeType.Xor = 46;\r\n        NodeType._map[47] = \"And\";\r\n        NodeType.And = 47;\r\n        NodeType._map[48] = \"Eq\";\r\n        NodeType.Eq = 48;\r\n        NodeType._map[49] = \"Ne\";\r\n        NodeType.Ne = 49;\r\n        NodeType._map[50] = \"Eqv\";\r\n        NodeType.Eqv = 50;\r\n        NodeType._map[51] = \"NEqv\";\r\n        NodeType.NEqv = 51;\r\n        NodeType._map[52] = \"Lt\";\r\n        NodeType.Lt = 52;\r\n        NodeType._map[53] = \"Le\";\r\n        NodeType.Le = 53;\r\n        NodeType._map[54] = \"Gt\";\r\n        NodeType.Gt = 54;\r\n        NodeType._map[55] = \"Ge\";\r\n        NodeType.Ge = 55;\r\n        NodeType._map[56] = \"Add\";\r\n        NodeType.Add = 56;\r\n        NodeType._map[57] = \"Sub\";\r\n        NodeType.Sub = 57;\r\n        NodeType._map[58] = \"Mul\";\r\n        NodeType.Mul = 58;\r\n        NodeType._map[59] = \"Div\";\r\n        NodeType.Div = 59;\r\n        NodeType._map[60] = \"Mod\";\r\n        NodeType.Mod = 60;\r\n        NodeType._map[61] = \"Lsh\";\r\n        NodeType.Lsh = 61;\r\n        NodeType._map[62] = \"Rsh\";\r\n        NodeType.Rsh = 62;\r\n        NodeType._map[63] = \"Rs2\";\r\n        NodeType.Rs2 = 63;\r\n        NodeType._map[64] = \"Not\";\r\n        NodeType.Not = 64;\r\n        NodeType._map[65] = \"LogNot\";\r\n        NodeType.LogNot = 65;\r\n        NodeType._map[66] = \"IncPre\";\r\n        NodeType.IncPre = 66;\r\n        NodeType._map[67] = \"DecPre\";\r\n        NodeType.DecPre = 67;\r\n        NodeType._map[68] = \"IncPost\";\r\n        NodeType.IncPost = 68;\r\n        NodeType._map[69] = \"DecPost\";\r\n        NodeType.DecPost = 69;\r\n        NodeType._map[70] = \"TypeAssertion\";\r\n        NodeType.TypeAssertion = 70;\r\n        NodeType._map[71] = \"FuncDecl\";\r\n        NodeType.FuncDecl = 71;\r\n        NodeType._map[72] = \"Member\";\r\n        NodeType.Member = 72;\r\n        NodeType._map[73] = \"VarDecl\";\r\n        NodeType.VarDecl = 73;\r\n        NodeType._map[74] = \"ArgDecl\";\r\n        NodeType.ArgDecl = 74;\r\n        NodeType._map[75] = \"Return\";\r\n        NodeType.Return = 75;\r\n        NodeType._map[76] = \"Break\";\r\n        NodeType.Break = 76;\r\n        NodeType._map[77] = \"Continue\";\r\n        NodeType.Continue = 77;\r\n        NodeType._map[78] = \"Throw\";\r\n        NodeType.Throw = 78;\r\n        NodeType._map[79] = \"For\";\r\n        NodeType.For = 79;\r\n        NodeType._map[80] = \"ForIn\";\r\n        NodeType.ForIn = 80;\r\n        NodeType._map[81] = \"If\";\r\n        NodeType.If = 81;\r\n        NodeType._map[82] = \"While\";\r\n        NodeType.While = 82;\r\n        NodeType._map[83] = \"DoWhile\";\r\n        NodeType.DoWhile = 83;\r\n        NodeType._map[84] = \"Block\";\r\n        NodeType.Block = 84;\r\n        NodeType._map[85] = \"Case\";\r\n        NodeType.Case = 85;\r\n        NodeType._map[86] = \"Switch\";\r\n        NodeType.Switch = 86;\r\n        NodeType._map[87] = \"Try\";\r\n        NodeType.Try = 87;\r\n        NodeType._map[88] = \"TryCatch\";\r\n        NodeType.TryCatch = 88;\r\n        NodeType._map[89] = \"TryFinally\";\r\n        NodeType.TryFinally = 89;\r\n        NodeType._map[90] = \"Finally\";\r\n        NodeType.Finally = 90;\r\n        NodeType._map[91] = \"Catch\";\r\n        NodeType.Catch = 91;\r\n        NodeType._map[92] = \"List\";\r\n        NodeType.List = 92;\r\n        NodeType._map[93] = \"Script\";\r\n        NodeType.Script = 93;\r\n        NodeType._map[94] = \"Class\";\r\n        NodeType.Class = 94;\r\n        NodeType._map[95] = \"Interface\";\r\n        NodeType.Interface = 95;\r\n        NodeType._map[96] = \"Module\";\r\n        NodeType.Module = 96;\r\n        NodeType._map[97] = \"Import\";\r\n        NodeType.Import = 97;\r\n        NodeType._map[98] = \"With\";\r\n        NodeType.With = 98;\r\n        NodeType._map[99] = \"Label\";\r\n        NodeType.Label = 99;\r\n        NodeType._map[100] = \"LabeledStatement\";\r\n        NodeType.LabeledStatement = 100;\r\n        NodeType._map[101] = \"EBStart\";\r\n        NodeType.EBStart = 101;\r\n        NodeType._map[102] = \"GotoEB\";\r\n        NodeType.GotoEB = 102;\r\n        NodeType._map[103] = \"EndCode\";\r\n        NodeType.EndCode = 103;\r\n        NodeType._map[104] = \"Error\";\r\n        NodeType.Error = 104;\r\n        NodeType._map[105] = \"Comment\";\r\n        NodeType.Comment = 105;\r\n        NodeType._map[106] = \"Debugger\";\r\n        NodeType.Debugger = 106;\r\n        NodeType.GeneralNode = NodeType.FuncDecl;\r\n        NodeType.LastAsg = NodeType.AsgRs2;\r\n    })(TypeScript.NodeType || (TypeScript.NodeType = {}));\r\n    var NodeType = TypeScript.NodeType;\r\n\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var BlockIntrinsics = (function () {\r\n        function BlockIntrinsics() {\r\n            this.prototype = undefined;\r\n            this.toString = undefined;\r\n            this.toLocaleString = undefined;\r\n            this.valueOf = undefined;\r\n            this.hasOwnProperty = undefined;\r\n            this.propertyIsEnumerable = undefined;\r\n            this.isPrototypeOf = undefined;\r\n            this[\"constructor\"] = undefined;\r\n        }\r\n        return BlockIntrinsics;\r\n    })();\r\n    TypeScript.BlockIntrinsics = BlockIntrinsics;    \r\n    var StringHashTable = (function () {\r\n        function StringHashTable() {\r\n            this.itemCount = 0;\r\n            this.table = (new BlockIntrinsics());\r\n        }\r\n        StringHashTable.prototype.getAllKeys = function () {\r\n            var result = [];\r\n            for(var k in this.table) {\r\n                if(this.table[k] != undefined) {\r\n                    result[result.length] = k;\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        StringHashTable.prototype.add = function (key, data) {\r\n            if(this.table[key] != undefined) {\r\n                return false;\r\n            }\r\n            this.table[key] = data;\r\n            this.itemCount++;\r\n            return true;\r\n        };\r\n        StringHashTable.prototype.addOrUpdate = function (key, data) {\r\n            if(this.table[key] != undefined) {\r\n                this.table[key] = data;\r\n                return false;\r\n            }\r\n            this.table[key] = data;\r\n            this.itemCount++;\r\n            return true;\r\n        };\r\n        StringHashTable.prototype.map = function (fn, context) {\r\n            for(var k in this.table) {\r\n                var data = this.table[k];\r\n                if(data != undefined) {\r\n                    fn(k, this.table[k], context);\r\n                }\r\n            }\r\n        };\r\n        StringHashTable.prototype.every = function (fn, context) {\r\n            for(var k in this.table) {\r\n                var data = this.table[k];\r\n                if(data != undefined) {\r\n                    if(!fn(k, this.table[k], context)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        StringHashTable.prototype.some = function (fn, context) {\r\n            for(var k in this.table) {\r\n                var data = this.table[k];\r\n                if(data != undefined) {\r\n                    if(fn(k, this.table[k], context)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        StringHashTable.prototype.count = function () {\r\n            return this.itemCount;\r\n        };\r\n        StringHashTable.prototype.lookup = function (key) {\r\n            var data = this.table[key];\r\n            if(data != undefined) {\r\n                return data;\r\n            } else {\r\n                return (null);\r\n            }\r\n        };\r\n        return StringHashTable;\r\n    })();\r\n    TypeScript.StringHashTable = StringHashTable;    \r\n    var DualStringHashTable = (function () {\r\n        function DualStringHashTable(primaryTable, secondaryTable) {\r\n            this.primaryTable = primaryTable;\r\n            this.secondaryTable = secondaryTable;\r\n            this.insertPrimary = true;\r\n        }\r\n        DualStringHashTable.prototype.getAllKeys = function () {\r\n            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());\r\n        };\r\n        DualStringHashTable.prototype.add = function (key, data) {\r\n            if(this.insertPrimary) {\r\n                return this.primaryTable.add(key, data);\r\n            } else {\r\n                return this.secondaryTable.add(key, data);\r\n            }\r\n        };\r\n        DualStringHashTable.prototype.addOrUpdate = function (key, data) {\r\n            if(this.insertPrimary) {\r\n                return this.primaryTable.addOrUpdate(key, data);\r\n            } else {\r\n                return this.secondaryTable.addOrUpdate(key, data);\r\n            }\r\n        };\r\n        DualStringHashTable.prototype.map = function (fn, context) {\r\n            this.primaryTable.map(fn, context);\r\n            this.secondaryTable.map(fn, context);\r\n        };\r\n        DualStringHashTable.prototype.every = function (fn, context) {\r\n            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);\r\n        };\r\n        DualStringHashTable.prototype.some = function (fn, context) {\r\n            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);\r\n        };\r\n        DualStringHashTable.prototype.count = function () {\r\n            return this.primaryTable.count() + this.secondaryTable.count();\r\n        };\r\n        DualStringHashTable.prototype.lookup = function (key) {\r\n            var data = this.primaryTable.lookup(key);\r\n            if(data != undefined) {\r\n                return data;\r\n            } else {\r\n                return this.secondaryTable.lookup(key);\r\n            }\r\n        };\r\n        return DualStringHashTable;\r\n    })();\r\n    TypeScript.DualStringHashTable = DualStringHashTable;    \r\n    function numberHashFn(key) {\r\n        var c2 = 668265261;\r\n        key = (key ^ 61) ^ (key >>> 16);\r\n        key = key + (key << 3);\r\n        key = key ^ (key >>> 4);\r\n        key = key * c2;\r\n        key = key ^ (key >>> 15);\r\n        return key;\r\n    }\r\n    TypeScript.numberHashFn = numberHashFn;\r\n    function combineHashes(key1, key2) {\r\n        return key2 ^ ((key1 >> 5) + key1);\r\n    }\r\n    TypeScript.combineHashes = combineHashes;\r\n    var HashEntry = (function () {\r\n        function HashEntry(key, data) {\r\n            this.key = key;\r\n            this.data = data;\r\n        }\r\n        return HashEntry;\r\n    })();\r\n    TypeScript.HashEntry = HashEntry;    \r\n    var HashTable = (function () {\r\n        function HashTable(size, hashFn, equalsFn) {\r\n            this.size = size;\r\n            this.hashFn = hashFn;\r\n            this.equalsFn = equalsFn;\r\n            this.itemCount = 0;\r\n            this.table = new Array();\r\n            for(var i = 0; i < this.size; i++) {\r\n                this.table[i] = null;\r\n            }\r\n        }\r\n        HashTable.prototype.add = function (key, data) {\r\n            var current;\r\n            var entry = new HashEntry(key, data);\r\n            var val = this.hashFn(key);\r\n            val = val % this.size;\r\n            for(current = this.table[val]; current != null; current = current.next) {\r\n                if(this.equalsFn(key, current.key)) {\r\n                    return false;\r\n                }\r\n            }\r\n            entry.next = this.table[val];\r\n            this.table[val] = entry;\r\n            this.itemCount++;\r\n            return true;\r\n        };\r\n        HashTable.prototype.remove = function (key) {\r\n            var current;\r\n            var val = this.hashFn(key);\r\n            val = val % this.size;\r\n            var result = null;\r\n            var prevEntry = null;\r\n            for(current = this.table[val]; current != null; current = current.next) {\r\n                if(this.equalsFn(key, current.key)) {\r\n                    result = current.data;\r\n                    this.itemCount--;\r\n                    if(prevEntry) {\r\n                        prevEntry.next = current.next;\r\n                    } else {\r\n                        this.table[val] = current.next;\r\n                    }\r\n                    break;\r\n                }\r\n                prevEntry = current;\r\n            }\r\n            return result;\r\n        };\r\n        HashTable.prototype.count = function () {\r\n            return this.itemCount;\r\n        };\r\n        HashTable.prototype.lookup = function (key) {\r\n            var current;\r\n            var val = this.hashFn(key);\r\n            val = val % this.size;\r\n            for(current = this.table[val]; current != null; current = current.next) {\r\n                if(this.equalsFn(key, current.key)) {\r\n                    return (current.data);\r\n                }\r\n            }\r\n            return (null);\r\n        };\r\n        return HashTable;\r\n    })();\r\n    TypeScript.HashTable = HashTable;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar __extends = this.__extends || function (d, b) {\r\n    function __() { this.constructor = d; }\r\n    __.prototype = b.prototype;\r\n    d.prototype = new __();\r\n}\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var AST = (function () {\r\n        function AST(nodeType) {\r\n            this.nodeType = nodeType;\r\n            this.type = null;\r\n            this.flags = TypeScript.ASTFlags.Writeable;\r\n            this.minChar = -1;\r\n            this.limChar = -1;\r\n            this.passCreated = TypeScript.CompilerDiagnostics.analysisPass;\r\n            this.preComments = null;\r\n            this.postComments = null;\r\n            this.isParenthesized = false;\r\n        }\r\n        AST.prototype.isStatementOrExpression = function () {\r\n            return false;\r\n        };\r\n        AST.prototype.isCompoundStatement = function () {\r\n            return false;\r\n        };\r\n        AST.prototype.isLeaf = function () {\r\n            return this.isStatementOrExpression() && (!this.isCompoundStatement());\r\n        };\r\n        AST.prototype.typeCheck = function (typeFlow) {\r\n            switch(this.nodeType) {\r\n                case TypeScript.NodeType.Error:\r\n                case TypeScript.NodeType.EmptyExpr: {\r\n                    this.type = typeFlow.anyType;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.This: {\r\n                    return typeFlow.typeCheckThis(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.Null: {\r\n                    this.type = typeFlow.nullType;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.False:\r\n                case TypeScript.NodeType.True: {\r\n                    this.type = typeFlow.booleanType;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Super: {\r\n                    return typeFlow.typeCheckSuper(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.EndCode:\r\n                case TypeScript.NodeType.Empty:\r\n                case TypeScript.NodeType.Void: {\r\n                    this.type = typeFlow.voidType;\r\n                    break;\r\n\r\n                }\r\n                default: {\r\n                    throw new Error(\"please implement in derived class\");\r\n\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        AST.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            switch(this.nodeType) {\r\n                case TypeScript.NodeType.This: {\r\n                    if(emitter.thisFnc && (TypeScript.hasFlag(emitter.thisFnc.fncFlags, TypeScript.FncFlags.IsFatArrowFunction))) {\r\n                        emitter.writeToOutput(\"_this\");\r\n                    } else {\r\n                        emitter.writeToOutput(\"this\");\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Null: {\r\n                    emitter.writeToOutput(\"null\");\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.False: {\r\n                    emitter.writeToOutput(\"false\");\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.True: {\r\n                    emitter.writeToOutput(\"true\");\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Super: {\r\n                    emitter.emitSuperReference();\r\n\r\n                }\r\n                case TypeScript.NodeType.EndCode: {\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Error:\r\n                case TypeScript.NodeType.EmptyExpr: {\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Empty: {\r\n                    emitter.writeToOutput(\"; \");\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Void: {\r\n                    emitter.writeToOutput(\"void \");\r\n                    break;\r\n\r\n                }\r\n                default: {\r\n                    throw new Error(\"please implement in derived class\");\r\n\r\n                }\r\n            }\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        AST.prototype.print = function (context) {\r\n            context.startLine();\r\n            var lineCol = {\r\n                line: -1,\r\n                col: -1\r\n            };\r\n            var limLineCol = {\r\n                line: -1,\r\n                col: -1\r\n            };\r\n            if(context.parser !== null) {\r\n                context.parser.getSourceLineCol(lineCol, this.minChar);\r\n                context.parser.getSourceLineCol(limLineCol, this.limChar);\r\n                context.write(\"(\" + lineCol.line + \",\" + lineCol.col + \")--\" + \"(\" + limLineCol.line + \",\" + limLineCol.col + \"): \");\r\n            }\r\n            var lab = this.printLabel();\r\n            if(TypeScript.hasFlag(this.flags, TypeScript.ASTFlags.Error)) {\r\n                lab += \" (Error)\";\r\n            }\r\n            context.writeLine(lab);\r\n        };\r\n        AST.prototype.printLabel = function () {\r\n            if(TypeScript.nodeTypeTable[this.nodeType] !== undefined) {\r\n                return TypeScript.nodeTypeTable[this.nodeType];\r\n            } else {\r\n                return (TypeScript.NodeType)._map[this.nodeType];\r\n            }\r\n        };\r\n        AST.prototype.addToControlFlow = function (context) {\r\n            context.walker.options.goChildren = false;\r\n            context.addContent(this);\r\n        };\r\n        AST.prototype.netFreeUses = function (container, freeUses) {\r\n        };\r\n        AST.prototype.treeViewLabel = function () {\r\n            return (TypeScript.NodeType)._map[this.nodeType];\r\n        };\r\n        return AST;\r\n    })();\r\n    TypeScript.AST = AST;    \r\n    var IncompleteAST = (function (_super) {\r\n        __extends(IncompleteAST, _super);\r\n        function IncompleteAST(min, lim) {\r\n                _super.call(this, TypeScript.NodeType.Error);\r\n            this.minChar = min;\r\n            this.limChar = lim;\r\n        }\r\n        return IncompleteAST;\r\n    })(AST);\r\n    TypeScript.IncompleteAST = IncompleteAST;    \r\n    var ASTList = (function (_super) {\r\n        __extends(ASTList, _super);\r\n        function ASTList() {\r\n                _super.call(this, TypeScript.NodeType.List);\r\n            this.enclosingScope = null;\r\n            this.members = new Array();\r\n        }\r\n        ASTList.prototype.addToControlFlow = function (context) {\r\n            var len = this.members.length;\r\n            for(var i = 0; i < len; i++) {\r\n                if(context.noContinuation) {\r\n                    context.addUnreachable(this.members[i]);\r\n                    break;\r\n                } else {\r\n                    this.members[i] = context.walk(this.members[i], this);\r\n                }\r\n            }\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        ASTList.prototype.append = function (ast) {\r\n            this.members[this.members.length] = ast;\r\n            return this;\r\n        };\r\n        ASTList.prototype.appendAll = function (ast) {\r\n            if(ast.nodeType == TypeScript.NodeType.List) {\r\n                var list = ast;\r\n                for(var i = 0, len = list.members.length; i < len; i++) {\r\n                    this.append(list.members[i]);\r\n                }\r\n            } else {\r\n                this.append(ast);\r\n            }\r\n            return this;\r\n        };\r\n        ASTList.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitJavascriptList(this, null, TypeScript.TokenID.SColon, startLine, false, false, writeDeclFile);\r\n        };\r\n        ASTList.prototype.typeCheck = function (typeFlow) {\r\n            var len = this.members.length;\r\n            typeFlow.nestingLevel++;\r\n            for(var i = 0; i < len; i++) {\r\n                if(this.members[i]) {\r\n                    this.members[i] = this.members[i].typeCheck(typeFlow);\r\n                }\r\n            }\r\n            typeFlow.nestingLevel--;\r\n            return this;\r\n        };\r\n        return ASTList;\r\n    })(AST);\r\n    TypeScript.ASTList = ASTList;    \r\n    var Identifier = (function (_super) {\r\n        __extends(Identifier, _super);\r\n        function Identifier(text) {\r\n                _super.call(this, TypeScript.NodeType.Name);\r\n            this.text = text;\r\n            this.sym = null;\r\n            this.cloId = -1;\r\n        }\r\n        Identifier.prototype.isMissing = function () {\r\n            return false;\r\n        };\r\n        Identifier.prototype.isLeaf = function () {\r\n            return true;\r\n        };\r\n        Identifier.prototype.treeViewLabel = function () {\r\n            return \"id: \" + this.text;\r\n        };\r\n        Identifier.prototype.printLabel = function () {\r\n            if(this.text) {\r\n                return \"id: \" + this.text;\r\n            } else {\r\n                return \"name node\";\r\n            }\r\n        };\r\n        Identifier.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckName(this);\r\n        };\r\n        Identifier.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitJavascriptName(this, true);\r\n        };\r\n        return Identifier;\r\n    })(AST);\r\n    TypeScript.Identifier = Identifier;    \r\n    var MissingIdentifier = (function (_super) {\r\n        __extends(MissingIdentifier, _super);\r\n        function MissingIdentifier() {\r\n                _super.call(this, \"__missing\");\r\n        }\r\n        MissingIdentifier.prototype.isMissing = function () {\r\n            return true;\r\n        };\r\n        MissingIdentifier.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n        };\r\n        return MissingIdentifier;\r\n    })(Identifier);\r\n    TypeScript.MissingIdentifier = MissingIdentifier;    \r\n    var Label = (function (_super) {\r\n        __extends(Label, _super);\r\n        function Label(id) {\r\n                _super.call(this, TypeScript.NodeType.Label);\r\n            this.id = id;\r\n        }\r\n        Label.prototype.printLabel = function () {\r\n            return this.id.text + \":\";\r\n        };\r\n        Label.prototype.typeCheck = function (typeFlow) {\r\n            this.type = typeFlow.voidType;\r\n            return this;\r\n        };\r\n        Label.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeLineToOutput(this.id.text + \":\");\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return Label;\r\n    })(AST);\r\n    TypeScript.Label = Label;    \r\n    var UnaryExpression = (function (_super) {\r\n        __extends(UnaryExpression, _super);\r\n        function UnaryExpression(nty, operand) {\r\n                _super.call(this, nty);\r\n            this.operand = operand;\r\n            this.targetType = null;\r\n            this.castTerm = null;\r\n            this.nty = nty;\r\n        }\r\n        UnaryExpression.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        UnaryExpression.prototype.addToControlFlow = function (context) {\r\n            _super.prototype.addToControlFlow.call(this, context);\r\n            if(this.nodeType == TypeScript.NodeType.Throw) {\r\n                context.returnStmt();\r\n            }\r\n        };\r\n        UnaryExpression.prototype.typeCheck = function (typeFlow) {\r\n            switch(this.nty) {\r\n                case TypeScript.NodeType.Not: {\r\n                    return typeFlow.typeCheckBitNot(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.LogNot: {\r\n                    return typeFlow.typeCheckLogNot(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.Pos:\r\n                case TypeScript.NodeType.Neg: {\r\n                    return typeFlow.typeCheckUnaryNumberOperator(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.IncPost:\r\n                case TypeScript.NodeType.IncPre:\r\n                case TypeScript.NodeType.DecPost:\r\n                case TypeScript.NodeType.DecPre: {\r\n                    return typeFlow.typeCheckIncOrDec(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.ArrayLit: {\r\n                    typeFlow.typeCheckArrayLit(this);\r\n                    return this;\r\n\r\n                }\r\n                case TypeScript.NodeType.ObjectLit: {\r\n                    typeFlow.typeCheckObjectLit(this);\r\n                    return this;\r\n\r\n                }\r\n                case TypeScript.NodeType.Throw: {\r\n                    this.operand = typeFlow.typeCheck(this.operand);\r\n                    this.type = typeFlow.voidType;\r\n                    return this;\r\n\r\n                }\r\n                case TypeScript.NodeType.Typeof: {\r\n                    this.operand = typeFlow.typeCheck(this.operand);\r\n                    this.type = typeFlow.stringType;\r\n                    return this;\r\n\r\n                }\r\n                case TypeScript.NodeType.Delete: {\r\n                    this.operand = typeFlow.typeCheck(this.operand);\r\n                    this.type = typeFlow.booleanType;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.TypeAssertion: {\r\n                    this.castTerm = typeFlow.typeCheck(this.castTerm);\r\n                    var applyTargetType = !this.operand.isParenthesized;\r\n                    var targetType = applyTargetType ? this.castTerm.type : null;\r\n                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);\r\n                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);\r\n                    this.type = this.castTerm.type;\r\n                    return this;\r\n\r\n                }\r\n                case TypeScript.NodeType.Void: {\r\n                    this.operand = typeFlow.typeCheck(this.operand);\r\n                    this.type = typeFlow.checker.undefinedType;\r\n                    break;\r\n\r\n                }\r\n                default: {\r\n                    throw new Error(\"please implement in derived class\");\r\n\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        UnaryExpression.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            switch(this.nty) {\r\n                case TypeScript.NodeType.IncPost: {\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Inc, false);\r\n                    emitter.writeToOutput(\"++\");\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.LogNot: {\r\n                    emitter.writeToOutput(\"!\");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Bang, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.DecPost: {\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Dec, false);\r\n                    emitter.writeToOutput(\"--\");\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.ObjectLit: {\r\n                    emitter.emitObjectLiteral(this.operand);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.ArrayLit: {\r\n                    emitter.emitArrayLiteral(this.operand);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Not: {\r\n                    emitter.writeToOutput(\"~\");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Tilde, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Neg: {\r\n                    emitter.writeToOutput(\"-\");\r\n                    if(this.operand.nodeType == TypeScript.NodeType.Neg) {\r\n                        this.operand.isParenthesized = true;\r\n                    }\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Sub, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Pos: {\r\n                    emitter.writeToOutput(\"+\");\r\n                    if(this.operand.nodeType == TypeScript.NodeType.Pos) {\r\n                        this.operand.isParenthesized = true;\r\n                    }\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Add, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.IncPre: {\r\n                    emitter.writeToOutput(\"++\");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Inc, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.DecPre: {\r\n                    emitter.writeToOutput(\"--\");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Dec, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Throw: {\r\n                    emitter.writeToOutput(\"throw \");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Tilde, false);\r\n                    emitter.writeToOutput(\";\");\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Typeof: {\r\n                    emitter.writeToOutput(\"typeof \");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Tilde, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Delete: {\r\n                    emitter.writeToOutput(\"delete \");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Tilde, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Void: {\r\n                    emitter.writeToOutput(\"void \");\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Tilde, false);\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.TypeAssertion: {\r\n                    emitter.emitJavascript(this.operand, TypeScript.TokenID.Tilde, false);\r\n                    break;\r\n\r\n                }\r\n                default: {\r\n                    throw new Error(\"please implement in derived class\");\r\n\r\n                }\r\n            }\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return UnaryExpression;\r\n    })(AST);\r\n    TypeScript.UnaryExpression = UnaryExpression;    \r\n    var CallExpression = (function (_super) {\r\n        __extends(CallExpression, _super);\r\n        function CallExpression(nty, target, args) {\r\n                _super.call(this, nty);\r\n            this.target = target;\r\n            this.args = args;\r\n            this.signature = null;\r\n            this.nty = nty;\r\n            this.minChar = this.target.minChar;\r\n        }\r\n        CallExpression.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        CallExpression.prototype.typeCheck = function (typeFlow) {\r\n            if(this.nty == TypeScript.NodeType.New) {\r\n                return typeFlow.typeCheckNew(this);\r\n            } else {\r\n                return typeFlow.typeCheckCall(this);\r\n            }\r\n        };\r\n        CallExpression.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            if(this.nty == TypeScript.NodeType.New) {\r\n                emitter.emitNew(this.target, this.args);\r\n            } else {\r\n                emitter.emitCall(this, this.target, this.args);\r\n            }\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return CallExpression;\r\n    })(AST);\r\n    TypeScript.CallExpression = CallExpression;    \r\n    var BinaryExpression = (function (_super) {\r\n        __extends(BinaryExpression, _super);\r\n        function BinaryExpression(nty, operand1, operand2) {\r\n                _super.call(this, nty);\r\n            this.operand1 = operand1;\r\n            this.operand2 = operand2;\r\n            this.nty = nty;\r\n        }\r\n        BinaryExpression.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        BinaryExpression.prototype.typeCheck = function (typeFlow) {\r\n            switch(this.nty) {\r\n                case TypeScript.NodeType.Dot: {\r\n                    return typeFlow.typeCheckDotOperator(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.Asg: {\r\n                    return typeFlow.typeCheckAsgOperator(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.Add:\r\n                case TypeScript.NodeType.Sub:\r\n                case TypeScript.NodeType.Mul:\r\n                case TypeScript.NodeType.Div:\r\n                case TypeScript.NodeType.Mod:\r\n                case TypeScript.NodeType.Or:\r\n                case TypeScript.NodeType.And: {\r\n                    return typeFlow.typeCheckArithmeticOperator(this, false);\r\n\r\n                }\r\n                case TypeScript.NodeType.Xor: {\r\n                    return typeFlow.typeCheckBitwiseOperator(this, false);\r\n\r\n                }\r\n                case TypeScript.NodeType.Ne:\r\n                case TypeScript.NodeType.Eq: {\r\n                    var text;\r\n                    if(typeFlow.checker.styleSettings.eqeqeq) {\r\n                        text = TypeScript.nodeTypeTable[this.nty];\r\n                        typeFlow.checker.errorReporter.styleError(this, \"use of \" + text);\r\n                    } else {\r\n                        if(typeFlow.checker.styleSettings.eqnull) {\r\n                            text = TypeScript.nodeTypeTable[this.nty];\r\n                            if((this.operand2 !== null) && (this.operand2.nodeType == TypeScript.NodeType.Null)) {\r\n                                typeFlow.checker.errorReporter.styleError(this, \"use of \" + text + \" to compare with null\");\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n                case TypeScript.NodeType.Eqv:\r\n                case TypeScript.NodeType.NEqv:\r\n                case TypeScript.NodeType.Lt:\r\n                case TypeScript.NodeType.Le:\r\n                case TypeScript.NodeType.Ge:\r\n                case TypeScript.NodeType.Gt: {\r\n                    return typeFlow.typeCheckBooleanOperator(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.Index: {\r\n                    return typeFlow.typeCheckIndex(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.Member: {\r\n                    this.type = typeFlow.voidType;\r\n                    return this;\r\n\r\n                }\r\n                case TypeScript.NodeType.LogOr: {\r\n                    return typeFlow.typeCheckLogOr(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.LogAnd: {\r\n                    return typeFlow.typeCheckLogAnd(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.AsgAdd:\r\n                case TypeScript.NodeType.AsgSub:\r\n                case TypeScript.NodeType.AsgMul:\r\n                case TypeScript.NodeType.AsgDiv:\r\n                case TypeScript.NodeType.AsgMod:\r\n                case TypeScript.NodeType.AsgOr:\r\n                case TypeScript.NodeType.AsgAnd: {\r\n                    return typeFlow.typeCheckArithmeticOperator(this, true);\r\n\r\n                }\r\n                case TypeScript.NodeType.AsgXor: {\r\n                    return typeFlow.typeCheckBitwiseOperator(this, true);\r\n\r\n                }\r\n                case TypeScript.NodeType.Lsh:\r\n                case TypeScript.NodeType.Rsh:\r\n                case TypeScript.NodeType.Rs2: {\r\n                    return typeFlow.typeCheckShift(this, false);\r\n\r\n                }\r\n                case TypeScript.NodeType.AsgLsh:\r\n                case TypeScript.NodeType.AsgRsh:\r\n                case TypeScript.NodeType.AsgRs2: {\r\n                    return typeFlow.typeCheckShift(this, true);\r\n\r\n                }\r\n                case TypeScript.NodeType.Comma: {\r\n                    return typeFlow.typeCheckCommaOperator(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.InstOf: {\r\n                    return typeFlow.typeCheckInstOf(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.In: {\r\n                    return typeFlow.typeCheckInOperator(this);\r\n\r\n                }\r\n                case TypeScript.NodeType.From: {\r\n                    typeFlow.checker.errorReporter.simpleError(this, \"Illegal use of 'from' keyword in binary expression\");\r\n                    break;\r\n\r\n                }\r\n                default: {\r\n                    throw new Error(\"please implement in derived class\");\r\n\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        BinaryExpression.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            var binTokenId = TypeScript.nodeTypeToTokTable[this.nodeType];\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            if(binTokenId != undefined) {\r\n                emitter.emitJavascript(this.operand1, binTokenId, false);\r\n                if(TypeScript.tokenTable[binTokenId].text == \"instanceof\") {\r\n                    emitter.writeToOutput(\" instanceof \");\r\n                } else {\r\n                    if(TypeScript.tokenTable[binTokenId].text == \"in\") {\r\n                        emitter.writeToOutput(\" in \");\r\n                    } else {\r\n                        emitter.writeToOutputTrimmable(\" \" + TypeScript.tokenTable[binTokenId].text + \" \");\r\n                    }\r\n                }\r\n                emitter.emitJavascript(this.operand2, binTokenId, false);\r\n            } else {\r\n                switch(this.nty) {\r\n                    case TypeScript.NodeType.Dot: {\r\n                        if(!emitter.tryEmitConstant(this)) {\r\n                            emitter.emitJavascript(this.operand1, TypeScript.TokenID.Dot, false);\r\n                            emitter.writeToOutput(\".\");\r\n                            emitter.emitJavascriptName(this.operand2, false);\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Index: {\r\n                        emitter.emitIndex(this.operand1, this.operand2);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Member: {\r\n                        if(this.operand2.nodeType == TypeScript.NodeType.FuncDecl && (this.operand2).isAccessor()) {\r\n                            var funcDecl = this.operand2;\r\n                            if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.GetAccessor)) {\r\n                                emitter.writeToOutput(\"get \");\r\n                            } else {\r\n                                emitter.writeToOutput(\"set \");\r\n                            }\r\n                            emitter.emitJavascript(this.operand1, TypeScript.TokenID.Colon, false);\r\n                        } else {\r\n                            emitter.emitJavascript(this.operand1, TypeScript.TokenID.Colon, false);\r\n                            emitter.writeToOutputTrimmable(\": \");\r\n                        }\r\n                        emitter.emitJavascript(this.operand2, TypeScript.TokenID.Comma, false);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Comma: {\r\n                        emitter.emitJavascript(this.operand1, TypeScript.TokenID.Comma, false);\r\n                        if(emitter.emitState.inObjectLiteral) {\r\n                            emitter.writeLineToOutput(\", \");\r\n                        } else {\r\n                            emitter.writeToOutput(\",\");\r\n                        }\r\n                        emitter.emitJavascript(this.operand2, TypeScript.TokenID.Comma, false);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Is: {\r\n                        throw new Error(\"should be de-sugared during type check\");\r\n\r\n                    }\r\n                    default: {\r\n                        throw new Error(\"please implement in derived class\");\r\n\r\n                    }\r\n                }\r\n            }\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return BinaryExpression;\r\n    })(AST);\r\n    TypeScript.BinaryExpression = BinaryExpression;    \r\n    var TrinaryExpression = (function (_super) {\r\n        __extends(TrinaryExpression, _super);\r\n        function TrinaryExpression(nty, operand1, operand2, operand3) {\r\n                _super.call(this, nty);\r\n            this.operand1 = operand1;\r\n            this.operand2 = operand2;\r\n            this.operand3 = operand3;\r\n            this.nty = nty;\r\n        }\r\n        TrinaryExpression.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        TrinaryExpression.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckQMark(this);\r\n        };\r\n        TrinaryExpression.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.emitJavascript(this.operand1, TypeScript.TokenID.QMark, false);\r\n            emitter.writeToOutput(\" ? \");\r\n            emitter.emitJavascript(this.operand2, TypeScript.TokenID.QMark, false);\r\n            emitter.writeToOutput(\" : \");\r\n            emitter.emitJavascript(this.operand3, TypeScript.TokenID.QMark, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return TrinaryExpression;\r\n    })(AST);\r\n    TypeScript.TrinaryExpression = TrinaryExpression;    \r\n    var NumberLiteral = (function (_super) {\r\n        __extends(NumberLiteral, _super);\r\n        function NumberLiteral(value) {\r\n                _super.call(this, TypeScript.NodeType.NumberLit);\r\n            this.value = value;\r\n            this.isNegativeZero = false;\r\n        }\r\n        NumberLiteral.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        NumberLiteral.prototype.typeCheck = function (typeFlow) {\r\n            this.type = typeFlow.doubleType;\r\n            return this;\r\n        };\r\n        NumberLiteral.prototype.treeViewLabel = function () {\r\n            return \"num: \" + this.value;\r\n        };\r\n        NumberLiteral.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            if(this.isNegativeZero) {\r\n                emitter.writeToOutput(\"-\");\r\n            }\r\n            emitter.writeToOutput(this.value.toString());\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        NumberLiteral.prototype.printLabel = function () {\r\n            if(Math.floor(this.value) != this.value) {\r\n                return this.value.toFixed(2).toString();\r\n            } else {\r\n                return this.value.toString();\r\n            }\r\n        };\r\n        return NumberLiteral;\r\n    })(AST);\r\n    TypeScript.NumberLiteral = NumberLiteral;    \r\n    var RegexLiteral = (function (_super) {\r\n        __extends(RegexLiteral, _super);\r\n        function RegexLiteral(regex) {\r\n                _super.call(this, TypeScript.NodeType.Regex);\r\n            this.regex = regex;\r\n        }\r\n        RegexLiteral.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        RegexLiteral.prototype.typeCheck = function (typeFlow) {\r\n            this.type = typeFlow.regexType;\r\n            return this;\r\n        };\r\n        RegexLiteral.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeToOutput(this.regex.toString());\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return RegexLiteral;\r\n    })(AST);\r\n    TypeScript.RegexLiteral = RegexLiteral;    \r\n    var StringLiteral = (function (_super) {\r\n        __extends(StringLiteral, _super);\r\n        function StringLiteral(text) {\r\n                _super.call(this, TypeScript.NodeType.QString);\r\n            this.text = text;\r\n        }\r\n        StringLiteral.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        StringLiteral.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.emitStringLiteral(this.text);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        StringLiteral.prototype.typeCheck = function (typeFlow) {\r\n            this.type = typeFlow.stringType;\r\n            return this;\r\n        };\r\n        StringLiteral.prototype.treeViewLabel = function () {\r\n            return \"st: \" + this.text;\r\n        };\r\n        StringLiteral.prototype.printLabel = function () {\r\n            return this.text;\r\n        };\r\n        return StringLiteral;\r\n    })(AST);\r\n    TypeScript.StringLiteral = StringLiteral;    \r\n    var ImportDecl = (function (_super) {\r\n        __extends(ImportDecl, _super);\r\n        function ImportDecl(id, alias) {\r\n                _super.call(this, TypeScript.NodeType.Import);\r\n            this.id = id;\r\n            this.alias = alias;\r\n            this.varFlags = TypeScript.VarFlags.None;\r\n            this.isDynamicImport = false;\r\n        }\r\n        ImportDecl.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        ImportDecl.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            var mod = this.alias.type;\r\n            if(writeDeclFile) {\r\n                emitter.emitImportDecl(this);\r\n            }\r\n            if(!this.isDynamicImport || (this.id.sym && !(this.id.sym).onlyReferencedAsTypeRef)) {\r\n                var prevModAliasId = emitter.modAliasId;\r\n                var prevFirstModAlias = emitter.firstModAlias;\r\n                emitter.recordSourceMappingStart(this);\r\n                emitter.emitParensAndCommentsInPlace(this, true);\r\n                emitter.writeToOutput(\"var \" + this.id.text + \" = \");\r\n                emitter.modAliasId = this.id.text;\r\n                emitter.firstModAlias = this.firstAliasedModToString();\r\n                emitter.emitJavascript(this.alias, TypeScript.TokenID.Tilde, false, writeDeclFile);\r\n                if(!this.isDynamicImport) {\r\n                    emitter.writeToOutput(\";\");\r\n                }\r\n                emitter.emitParensAndCommentsInPlace(this, false);\r\n                emitter.recordSourceMappingEnd(this);\r\n                emitter.modAliasId = prevModAliasId;\r\n                emitter.firstModAlias = prevFirstModAlias;\r\n            }\r\n        };\r\n        ImportDecl.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckImportDecl(this);\r\n        };\r\n        ImportDecl.prototype.getAliasName = function (aliasAST) {\r\n            if (typeof aliasAST === \"undefined\") { aliasAST = this.alias; }\r\n            if(aliasAST.nodeType == TypeScript.NodeType.Name) {\r\n                return (aliasAST).text;\r\n            } else {\r\n                var dotExpr = aliasAST;\r\n                return this.getAliasName(dotExpr.operand1) + \".\" + this.getAliasName(dotExpr.operand2);\r\n            }\r\n        };\r\n        ImportDecl.prototype.firstAliasedModToString = function () {\r\n            if(this.alias.nodeType == TypeScript.NodeType.Name) {\r\n                return (this.alias).text;\r\n            } else {\r\n                var dotExpr = this.alias;\r\n                var firstMod = dotExpr.operand1;\r\n                return firstMod.text;\r\n            }\r\n        };\r\n        return ImportDecl;\r\n    })(AST);\r\n    TypeScript.ImportDecl = ImportDecl;    \r\n    var BoundDecl = (function (_super) {\r\n        __extends(BoundDecl, _super);\r\n        function BoundDecl(id, nodeType, nestingLevel) {\r\n                _super.call(this, nodeType);\r\n            this.id = id;\r\n            this.nestingLevel = nestingLevel;\r\n            this.init = null;\r\n            this.typeExpr = null;\r\n            this.varFlags = TypeScript.VarFlags.None;\r\n            this.sym = null;\r\n        }\r\n        BoundDecl.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        BoundDecl.prototype.isPrivate = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Private);\r\n        };\r\n        BoundDecl.prototype.isPublic = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Public);\r\n        };\r\n        BoundDecl.prototype.isProperty = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Property);\r\n        };\r\n        BoundDecl.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckBoundDecl(this);\r\n        };\r\n        BoundDecl.prototype.printLabel = function () {\r\n            return this.treeViewLabel();\r\n        };\r\n        return BoundDecl;\r\n    })(AST);\r\n    TypeScript.BoundDecl = BoundDecl;    \r\n    var VarDecl = (function (_super) {\r\n        __extends(VarDecl, _super);\r\n        function VarDecl(id, nest) {\r\n                _super.call(this, id, TypeScript.NodeType.VarDecl, nest);\r\n        }\r\n        VarDecl.prototype.isAmbient = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Ambient);\r\n        };\r\n        VarDecl.prototype.isExported = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Exported);\r\n        };\r\n        VarDecl.prototype.isStatic = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Static);\r\n        };\r\n        VarDecl.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitJavascriptVarDecl(this, tokenId, writeDeclFile);\r\n        };\r\n        VarDecl.prototype.treeViewLabel = function () {\r\n            return \"var \" + this.id.text;\r\n        };\r\n        return VarDecl;\r\n    })(BoundDecl);\r\n    TypeScript.VarDecl = VarDecl;    \r\n    var ArgDecl = (function (_super) {\r\n        __extends(ArgDecl, _super);\r\n        function ArgDecl(id) {\r\n                _super.call(this, id, TypeScript.NodeType.ArgDecl, 0);\r\n            this.isOptional = false;\r\n            this.parameterPropertySym = null;\r\n        }\r\n        ArgDecl.prototype.isOptionalArg = function () {\r\n            return this.isOptional || this.init;\r\n        };\r\n        ArgDecl.prototype.treeViewLabel = function () {\r\n            return \"arg: \" + this.id.text;\r\n        };\r\n        ArgDecl.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeToOutput(this.id.text);\r\n            if(writeDeclFile) {\r\n                emitter.emitArgDecl(this);\r\n            }\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return ArgDecl;\r\n    })(BoundDecl);\r\n    TypeScript.ArgDecl = ArgDecl;    \r\n    var internalId = 0;\r\n    var FuncDecl = (function (_super) {\r\n        __extends(FuncDecl, _super);\r\n        function FuncDecl(name, bod, isConstructor, args, vars, scopes, statics, nodeType) {\r\n                _super.call(this, nodeType);\r\n            this.name = name;\r\n            this.bod = bod;\r\n            this.isConstructor = isConstructor;\r\n            this.args = args;\r\n            this.vars = vars;\r\n            this.scopes = scopes;\r\n            this.statics = statics;\r\n            this.hint = null;\r\n            this.fncFlags = TypeScript.FncFlags.None;\r\n            this.returnTypeAnnotation = null;\r\n            this.variableArgList = false;\r\n            this.jumpRefs = null;\r\n            this.internalNameCache = null;\r\n            this.tmp1Declared = false;\r\n            this.enclosingFnc = null;\r\n            this.freeVariables = [];\r\n            this.unitIndex = -1;\r\n            this.classDecl = null;\r\n            this.boundToProperty = null;\r\n            this.isOverload = false;\r\n            this.innerStaticFuncs = [];\r\n            this.isTargetTypedAsMethod = false;\r\n            this.isInlineCallLiteral = false;\r\n            this.accessorSymbol = null;\r\n            this.leftCurlyCount = 0;\r\n            this.rightCurlyCount = 0;\r\n            this.returnStatementsWithExpressions = [];\r\n            this.scopeType = null;\r\n        }\r\n        FuncDecl.prototype.internalName = function () {\r\n            if(this.internalNameCache == null) {\r\n                var extName = this.getNameText();\r\n                if(extName) {\r\n                    this.internalNameCache = \"_internal_\" + extName;\r\n                } else {\r\n                    this.internalNameCache = \"_internal_\" + internalId++;\r\n                }\r\n            }\r\n            return this.internalNameCache;\r\n        };\r\n        FuncDecl.prototype.hasSelfReference = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.HasSelfReference);\r\n        };\r\n        FuncDecl.prototype.setHasSelfReference = function () {\r\n            this.fncFlags |= TypeScript.FncFlags.HasSelfReference;\r\n        };\r\n        FuncDecl.prototype.addCloRef = function (id, sym) {\r\n            if(this.envids == null) {\r\n                this.envids = new Array();\r\n            }\r\n            this.envids[this.envids.length] = id;\r\n            var outerFnc = this.enclosingFnc;\r\n            if(sym) {\r\n                while(outerFnc && (outerFnc.type.symbol != sym.container)) {\r\n                    outerFnc.addJumpRef(sym);\r\n                    outerFnc = outerFnc.enclosingFnc;\r\n                }\r\n            }\r\n            return this.envids.length - 1;\r\n        };\r\n        FuncDecl.prototype.addJumpRef = function (sym) {\r\n            if(this.jumpRefs == null) {\r\n                this.jumpRefs = new Array();\r\n            }\r\n            var id = new Identifier(sym.name);\r\n            this.jumpRefs[this.jumpRefs.length] = id;\r\n            id.sym = sym;\r\n            id.cloId = this.addCloRef(id, null);\r\n        };\r\n        FuncDecl.prototype.buildControlFlow = function () {\r\n            var entry = new TypeScript.BasicBlock();\r\n            var exit = new TypeScript.BasicBlock();\r\n            var context = new TypeScript.ControlFlowContext(entry, exit);\r\n            var controlFlowPrefix = function (ast, parent, walker) {\r\n                ast.addToControlFlow(walker.state);\r\n                return ast;\r\n            };\r\n            var walker = TypeScript.getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);\r\n            context.walker = walker;\r\n            walker.walk(this.bod, this);\r\n            return context;\r\n        };\r\n        FuncDecl.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckFunction(this);\r\n        };\r\n        FuncDecl.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitJavascriptFunction(this, writeDeclFile);\r\n        };\r\n        FuncDecl.prototype.getNameText = function () {\r\n            if(this.name) {\r\n                return this.name.text;\r\n            } else {\r\n                return this.hint;\r\n            }\r\n        };\r\n        FuncDecl.prototype.isMethod = function () {\r\n            return (this.fncFlags & TypeScript.FncFlags.Method) != TypeScript.FncFlags.None;\r\n        };\r\n        FuncDecl.prototype.isCallMember = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.CallMember);\r\n        };\r\n        FuncDecl.prototype.isConstructMember = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.ConstructMember);\r\n        };\r\n        FuncDecl.prototype.isIndexerMember = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.IndexerMember);\r\n        };\r\n        FuncDecl.prototype.isSpecialFn = function () {\r\n            return this.isCallMember() || this.isIndexerMember() || this.isConstructMember();\r\n        };\r\n        FuncDecl.prototype.isAnonymousFn = function () {\r\n            return this.name === null;\r\n        };\r\n        FuncDecl.prototype.isAccessor = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.GetAccessor) || TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.SetAccessor);\r\n        };\r\n        FuncDecl.prototype.isGetAccessor = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.GetAccessor);\r\n        };\r\n        FuncDecl.prototype.isSetAccessor = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.SetAccessor);\r\n        };\r\n        FuncDecl.prototype.isAmbient = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.Ambient);\r\n        };\r\n        FuncDecl.prototype.isExported = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.Exported);\r\n        };\r\n        FuncDecl.prototype.isPrivate = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.Private);\r\n        };\r\n        FuncDecl.prototype.isPublic = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.Public);\r\n        };\r\n        FuncDecl.prototype.isStatic = function () {\r\n            return TypeScript.hasFlag(this.fncFlags, TypeScript.FncFlags.Static);\r\n        };\r\n        FuncDecl.prototype.treeViewLabel = function () {\r\n            if(this.name == null) {\r\n                return \"funcExpr\";\r\n            } else {\r\n                return \"func: \" + this.name.text;\r\n            }\r\n        };\r\n        FuncDecl.prototype.ClearFlags = function () {\r\n            this.fncFlags = TypeScript.FncFlags.None;\r\n        };\r\n        FuncDecl.prototype.isSignature = function () {\r\n            return (this.fncFlags & TypeScript.FncFlags.Signature) != TypeScript.FncFlags.None;\r\n        };\r\n        FuncDecl.prototype.hasStaticDeclarations = function () {\r\n            return (!this.isConstructor && (this.statics.members.length > 0 || this.innerStaticFuncs.length > 0));\r\n        };\r\n        return FuncDecl;\r\n    })(AST);\r\n    TypeScript.FuncDecl = FuncDecl;    \r\n    var LocationInfo = (function () {\r\n        function LocationInfo(filename, lineMap, unitIndex) {\r\n            this.filename = filename;\r\n            this.lineMap = lineMap;\r\n            this.unitIndex = unitIndex;\r\n        }\r\n        return LocationInfo;\r\n    })();\r\n    TypeScript.LocationInfo = LocationInfo;    \r\n    TypeScript.unknownLocationInfo = new LocationInfo(\"unknown\", null, -1);\r\n    var Script = (function (_super) {\r\n        __extends(Script, _super);\r\n        function Script(vars, scopes) {\r\n                _super.call(this, new Identifier(\"script\"), null, false, null, vars, scopes, null, TypeScript.NodeType.Script);\r\n            this.locationInfo = null;\r\n            this.requiresGlobal = false;\r\n            this.requiresInherits = false;\r\n            this.isResident = false;\r\n            this.isDeclareFile = false;\r\n            this.hasBeenTypeChecked = false;\r\n            this.topLevelMod = null;\r\n            this.leftCurlyCount = 0;\r\n            this.rightCurlyCount = 0;\r\n            this.vars = vars;\r\n            this.scopes = scopes;\r\n        }\r\n        Script.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckScript(this);\r\n        };\r\n        Script.prototype.treeViewLabel = function () {\r\n            return \"Script\";\r\n        };\r\n        Script.prototype.emitRequired = function () {\r\n            if(!this.isDeclareFile && !this.isResident && this.bod) {\r\n                for(var i = 0, len = this.bod.members.length; i < len; i++) {\r\n                    var stmt = this.bod.members[i];\r\n                    if(stmt.nodeType == TypeScript.NodeType.Module) {\r\n                        if(!TypeScript.hasFlag((stmt).modFlags, TypeScript.ModuleFlags.ShouldEmitModuleDecl | TypeScript.ModuleFlags.Ambient)) {\r\n                            return true;\r\n                        }\r\n                    } else {\r\n                        if(stmt.nodeType == TypeScript.NodeType.Class) {\r\n                            if(!TypeScript.hasFlag((stmt).varFlags, TypeScript.VarFlags.Ambient)) {\r\n                                return true;\r\n                            }\r\n                        } else {\r\n                            if(stmt.nodeType == TypeScript.NodeType.VarDecl) {\r\n                                if(!TypeScript.hasFlag((stmt).varFlags, TypeScript.VarFlags.Ambient)) {\r\n                                    return true;\r\n                                }\r\n                            } else {\r\n                                if(stmt.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                    if(!(stmt).isSignature()) {\r\n                                        return true;\r\n                                    }\r\n                                } else {\r\n                                    if(stmt.nodeType != TypeScript.NodeType.Interface && stmt.nodeType != TypeScript.NodeType.Empty) {\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        Script.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            if(this.emitRequired()) {\r\n                emitter.emitParensAndCommentsInPlace(this, true);\r\n                emitter.recordSourceMappingStart(this);\r\n                emitter.emitPrologue(this.requiresInherits);\r\n                var oldDeclContainingAST = writeDeclFile ? emitter.setDeclContainingAST(this) : null;\r\n                emitter.emitJavascriptList(this.bod, null, TypeScript.TokenID.SColon, true, false, false, writeDeclFile);\r\n                if(writeDeclFile) {\r\n                    emitter.setDeclContainingAST(oldDeclContainingAST);\r\n                }\r\n                emitter.recordSourceMappingEnd(this);\r\n                emitter.emitParensAndCommentsInPlace(this, false);\r\n            }\r\n        };\r\n        return Script;\r\n    })(FuncDecl);\r\n    TypeScript.Script = Script;    \r\n    var Record = (function (_super) {\r\n        __extends(Record, _super);\r\n        function Record(nty, name, members) {\r\n                _super.call(this, nty);\r\n            this.name = name;\r\n            this.members = members;\r\n            this.nty = nty;\r\n        }\r\n        return Record;\r\n    })(AST);\r\n    TypeScript.Record = Record;    \r\n    var ModuleDecl = (function (_super) {\r\n        __extends(ModuleDecl, _super);\r\n        function ModuleDecl(name, members, vars, scopes) {\r\n                _super.call(this, TypeScript.NodeType.Module, name, members);\r\n            this.modFlags = TypeScript.ModuleFlags.ShouldEmitModuleDecl;\r\n            this.alias = null;\r\n            this.leftCurlyCount = 0;\r\n            this.rightCurlyCount = 0;\r\n            this.amdDependencies = [];\r\n            this.members = members;\r\n            this.vars = vars;\r\n            this.name = name;\r\n            this.scopes = scopes;\r\n            this.prettyName = this.name.text;\r\n        }\r\n        ModuleDecl.prototype.isExported = function () {\r\n            return TypeScript.hasFlag(this.modFlags, TypeScript.ModuleFlags.Exported);\r\n        };\r\n        ModuleDecl.prototype.isAmbient = function () {\r\n            return TypeScript.hasFlag(this.modFlags, TypeScript.ModuleFlags.Ambient);\r\n        };\r\n        ModuleDecl.prototype.isEnum = function () {\r\n            return TypeScript.hasFlag(this.modFlags, TypeScript.ModuleFlags.IsEnum);\r\n        };\r\n        ModuleDecl.prototype.recordNonInterface = function () {\r\n            this.modFlags &= ~TypeScript.ModuleFlags.ShouldEmitModuleDecl;\r\n        };\r\n        ModuleDecl.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckModule(this);\r\n        };\r\n        ModuleDecl.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            if(!TypeScript.hasFlag(this.modFlags, TypeScript.ModuleFlags.ShouldEmitModuleDecl)) {\r\n                emitter.emitParensAndCommentsInPlace(this, true);\r\n                emitter.emitJavascriptModule(this, writeDeclFile);\r\n                emitter.emitParensAndCommentsInPlace(this, false);\r\n            } else {\r\n                if(writeDeclFile) {\r\n                    emitter.emitModuleSignature(this);\r\n                }\r\n            }\r\n        };\r\n        return ModuleDecl;\r\n    })(Record);\r\n    TypeScript.ModuleDecl = ModuleDecl;    \r\n    var NamedType = (function (_super) {\r\n        __extends(NamedType, _super);\r\n        function NamedType(nty, name, extendsList, implementsList, members) {\r\n                _super.call(this, nty, name, members);\r\n            this.extendsList = extendsList;\r\n            this.implementsList = implementsList;\r\n            this.name = name;\r\n            this.members = members;\r\n        }\r\n        return NamedType;\r\n    })(Record);\r\n    TypeScript.NamedType = NamedType;    \r\n    var ClassDecl = (function (_super) {\r\n        __extends(ClassDecl, _super);\r\n        function ClassDecl(name, definitionMembers, baseClass, implementsList) {\r\n                _super.call(this, TypeScript.NodeType.Class, name, baseClass, implementsList, definitionMembers);\r\n            this.varFlags = TypeScript.VarFlags.None;\r\n            this.leftCurlyCount = 0;\r\n            this.rightCurlyCount = 0;\r\n            this.knownMemberNames = {\r\n            };\r\n            this.constructorDecl = null;\r\n            this.constructorNestingLevel = 0;\r\n            this.allMemberDefinitions = new ASTList();\r\n            this.name = name;\r\n            this.baseClass = baseClass;\r\n            this.implementsList = implementsList;\r\n            this.definitionMembers = definitionMembers;\r\n        }\r\n        ClassDecl.prototype.isExported = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Exported);\r\n        };\r\n        ClassDecl.prototype.isAmbient = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Ambient);\r\n        };\r\n        ClassDecl.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckClass(this);\r\n        };\r\n        ClassDecl.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitJavascriptClass(this, writeDeclFile);\r\n        };\r\n        return ClassDecl;\r\n    })(NamedType);\r\n    TypeScript.ClassDecl = ClassDecl;    \r\n    var TypeDecl = (function (_super) {\r\n        __extends(TypeDecl, _super);\r\n        function TypeDecl(nty, name, members, args, extendsList, implementsList) {\r\n                _super.call(this, nty, name, extendsList, implementsList, members);\r\n            this.args = args;\r\n            this.varFlags = TypeScript.VarFlags.None;\r\n            this.isOverload = false;\r\n            this.leftCurlyCount = 0;\r\n            this.rightCurlyCount = 0;\r\n            this.nty = nty;\r\n            this.name = name;\r\n            this.extendsList = extendsList;\r\n            this.implementsList = implementsList;\r\n            this.members = members;\r\n        }\r\n        TypeDecl.prototype.isExported = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Exported);\r\n        };\r\n        TypeDecl.prototype.isAmbient = function () {\r\n            return TypeScript.hasFlag(this.varFlags, TypeScript.VarFlags.Ambient);\r\n        };\r\n        TypeDecl.prototype.typeCheck = function (typeFlow) {\r\n            if(this.nty == TypeScript.NodeType.Interface) {\r\n                return typeFlow.typeCheckInterface(this);\r\n            } else {\r\n                throw new Error(\"please implement type check for node type\" + this.nty);\r\n            }\r\n        };\r\n        TypeDecl.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            if(this.nty == TypeScript.NodeType.Interface) {\r\n                if(writeDeclFile) {\r\n                    emitter.emitInterfaceDeclaration(this);\r\n                }\r\n            } else {\r\n                throw new Error(\"please implement emit for node type\" + this.nty);\r\n            }\r\n        };\r\n        return TypeDecl;\r\n    })(NamedType);\r\n    TypeScript.TypeDecl = TypeDecl;    \r\n    var Statement = (function (_super) {\r\n        __extends(Statement, _super);\r\n        function Statement(nty) {\r\n                _super.call(this, nty);\r\n            this.flags |= TypeScript.ASTFlags.IsStatement;\r\n        }\r\n        Statement.prototype.isLoop = function () {\r\n            return false;\r\n        };\r\n        Statement.prototype.isCompoundStatement = function () {\r\n            return this.isLoop();\r\n        };\r\n        Statement.prototype.typeCheck = function (typeFlow) {\r\n            this.type = typeFlow.voidType;\r\n            return this;\r\n        };\r\n        return Statement;\r\n    })(AST);\r\n    TypeScript.Statement = Statement;    \r\n    var LabeledStatement = (function (_super) {\r\n        __extends(LabeledStatement, _super);\r\n        function LabeledStatement(labels, stmt) {\r\n                _super.call(this, TypeScript.NodeType.LabeledStatement);\r\n            this.labels = labels;\r\n            this.stmt = stmt;\r\n        }\r\n        LabeledStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            if(this.labels) {\r\n                var labelsLen = this.labels.members.length;\r\n                for(var i = 0; i < labelsLen; i++) {\r\n                    this.labels.members[i].emit(emitter, tokenId, startLine, writeDeclFile);\r\n                }\r\n            }\r\n            this.stmt.emit(emitter, tokenId, true, writeDeclFile);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        LabeledStatement.prototype.typeCheck = function (typeFlow) {\r\n            typeFlow.typeCheck(this.labels);\r\n            this.stmt = this.stmt.typeCheck(typeFlow);\r\n            return this;\r\n        };\r\n        LabeledStatement.prototype.addToControlFlow = function (context) {\r\n            var beforeBB = context.current;\r\n            var bb = new TypeScript.BasicBlock();\r\n            context.current = bb;\r\n            beforeBB.addSuccessor(bb);\r\n        };\r\n        return LabeledStatement;\r\n    })(Statement);\r\n    TypeScript.LabeledStatement = LabeledStatement;    \r\n    var Block = (function (_super) {\r\n        __extends(Block, _super);\r\n        function Block(stmts, visible) {\r\n                _super.call(this, TypeScript.NodeType.Block);\r\n            this.stmts = stmts;\r\n            this.visible = visible;\r\n        }\r\n        Block.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            if(this.visible) {\r\n                emitter.writeLineToOutput(\" {\");\r\n                emitter.increaseIndent();\r\n            }\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            if(this.stmts) {\r\n                emitter.emitJavascriptList(this.stmts, null, TypeScript.TokenID.SColon, true, false, false);\r\n            }\r\n            if(this.visible) {\r\n                emitter.decreaseIndent();\r\n                emitter.emitIndent();\r\n                emitter.writeToOutput(\"}\");\r\n            }\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        Block.prototype.addToControlFlow = function (context) {\r\n            var afterIfNeeded = new TypeScript.BasicBlock();\r\n            context.pushStatement(this, context.current, afterIfNeeded);\r\n            if(this.stmts) {\r\n                context.walk(this.stmts, this);\r\n            }\r\n            context.walker.options.goChildren = false;\r\n            context.popStatement();\r\n            if(afterIfNeeded.predecessors.length > 0) {\r\n                context.current.addSuccessor(afterIfNeeded);\r\n                context.current = afterIfNeeded;\r\n            }\r\n        };\r\n        Block.prototype.typeCheck = function (typeFlow) {\r\n            if(!typeFlow.checker.styleSettings.emptyBlocks) {\r\n                if((this.stmts === null) || (this.stmts.members.length == 0)) {\r\n                    typeFlow.checker.errorReporter.styleError(this, \"empty block\");\r\n                }\r\n            }\r\n            typeFlow.typeCheck(this.stmts);\r\n            return this;\r\n        };\r\n        return Block;\r\n    })(Statement);\r\n    TypeScript.Block = Block;    \r\n    var Jump = (function (_super) {\r\n        __extends(Jump, _super);\r\n        function Jump(nty) {\r\n                _super.call(this, nty);\r\n            this.target = null;\r\n            this.resolvedTarget = null;\r\n            this.nty = nty;\r\n        }\r\n        Jump.prototype.hasExplicitTarget = function () {\r\n            return (this.target);\r\n        };\r\n        Jump.prototype.setResolvedTarget = function (parser, stmt) {\r\n            if(stmt.isLoop()) {\r\n                this.resolvedTarget = stmt;\r\n                return true;\r\n            }\r\n            if(this.nty === TypeScript.NodeType.Continue) {\r\n                parser.reportParseError(\"continue statement applies only to loops\");\r\n                return false;\r\n            } else {\r\n                if((stmt.nodeType == TypeScript.NodeType.Switch) || this.hasExplicitTarget()) {\r\n                    this.resolvedTarget = stmt;\r\n                    return true;\r\n                } else {\r\n                    parser.reportParseError(\"break statement with no label can apply only to a loop or switch statement\");\r\n                    return false;\r\n                }\r\n            }\r\n        };\r\n        Jump.prototype.addToControlFlow = function (context) {\r\n            _super.prototype.addToControlFlow.call(this, context);\r\n            context.unconditionalBranch(this.resolvedTarget, (this.nty == TypeScript.NodeType.Continue));\r\n        };\r\n        Jump.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            if(this.nty == TypeScript.NodeType.Break) {\r\n                emitter.writeToOutput(\"break\");\r\n            } else {\r\n                emitter.writeToOutput(\"continue\");\r\n            }\r\n            if(this.hasExplicitTarget()) {\r\n                emitter.writeToOutput(\" \" + this.target);\r\n            }\r\n            emitter.writeToOutput(\";\");\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return Jump;\r\n    })(Statement);\r\n    TypeScript.Jump = Jump;    \r\n    var WhileStatement = (function (_super) {\r\n        __extends(WhileStatement, _super);\r\n        function WhileStatement(cond) {\r\n                _super.call(this, TypeScript.NodeType.While);\r\n            this.cond = cond;\r\n            this.body = null;\r\n        }\r\n        WhileStatement.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        WhileStatement.prototype.isLoop = function () {\r\n            return true;\r\n        };\r\n        WhileStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            emitter.writeToOutput(\"while(\");\r\n            emitter.emitJavascript(this.cond, TypeScript.TokenID.WHILE, false);\r\n            emitter.writeToOutput(\")\");\r\n            emitter.emitJavascriptStatements(this.body, false, false);\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        WhileStatement.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckWhile(this);\r\n        };\r\n        WhileStatement.prototype.addToControlFlow = function (context) {\r\n            var loopHeader = context.current;\r\n            var loopStart = new TypeScript.BasicBlock();\r\n            var afterLoop = new TypeScript.BasicBlock();\r\n            loopHeader.addSuccessor(loopStart);\r\n            context.current = loopStart;\r\n            context.addContent(this.cond);\r\n            var condBlock = context.current;\r\n            var targetInfo = null;\r\n            if(this.body) {\r\n                context.current = new TypeScript.BasicBlock();\r\n                condBlock.addSuccessor(context.current);\r\n                context.pushStatement(this, loopStart, afterLoop);\r\n                context.walk(this.body, this);\r\n                targetInfo = context.popStatement();\r\n            }\r\n            if(!(context.noContinuation)) {\r\n                var loopEnd = context.current;\r\n                loopEnd.addSuccessor(loopStart);\r\n            }\r\n            context.current = afterLoop;\r\n            condBlock.addSuccessor(afterLoop);\r\n            context.noContinuation = false;\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return WhileStatement;\r\n    })(Statement);\r\n    TypeScript.WhileStatement = WhileStatement;    \r\n    var DoWhileStatement = (function (_super) {\r\n        __extends(DoWhileStatement, _super);\r\n        function DoWhileStatement() {\r\n                _super.call(this, TypeScript.NodeType.DoWhile);\r\n            this.body = null;\r\n            this.whileAST = null;\r\n            this.cond = null;\r\n        }\r\n        DoWhileStatement.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        DoWhileStatement.prototype.isLoop = function () {\r\n            return true;\r\n        };\r\n        DoWhileStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            emitter.writeToOutput(\"do\");\r\n            emitter.emitJavascriptStatements(this.body, true, false);\r\n            emitter.recordSourceMappingStart(this.whileAST);\r\n            emitter.writeToOutput(\"while\");\r\n            emitter.recordSourceMappingEnd(this.whileAST);\r\n            emitter.writeToOutput('(');\r\n            emitter.emitJavascript(this.cond, TypeScript.TokenID.RParen, false);\r\n            emitter.writeToOutput(\")\");\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        DoWhileStatement.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckDoWhile(this);\r\n        };\r\n        DoWhileStatement.prototype.addToControlFlow = function (context) {\r\n            var loopHeader = context.current;\r\n            var loopStart = new TypeScript.BasicBlock();\r\n            var afterLoop = new TypeScript.BasicBlock();\r\n            loopHeader.addSuccessor(loopStart);\r\n            context.current = loopStart;\r\n            var targetInfo = null;\r\n            if(this.body) {\r\n                context.pushStatement(this, loopStart, afterLoop);\r\n                context.walk(this.body, this);\r\n                targetInfo = context.popStatement();\r\n            }\r\n            if(!(context.noContinuation)) {\r\n                var loopEnd = context.current;\r\n                loopEnd.addSuccessor(loopStart);\r\n                context.addContent(this.cond);\r\n                context.current = afterLoop;\r\n                loopEnd.addSuccessor(afterLoop);\r\n            } else {\r\n                context.addUnreachable(this.cond);\r\n            }\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return DoWhileStatement;\r\n    })(Statement);\r\n    TypeScript.DoWhileStatement = DoWhileStatement;    \r\n    var IfStatement = (function (_super) {\r\n        __extends(IfStatement, _super);\r\n        function IfStatement(cond) {\r\n                _super.call(this, TypeScript.NodeType.If);\r\n            this.cond = cond;\r\n            this.elseBod = null;\r\n        }\r\n        IfStatement.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        IfStatement.prototype.isCompoundStatement = function () {\r\n            return true;\r\n        };\r\n        IfStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            emitter.writeToOutput(\"if(\");\r\n            emitter.emitJavascript(this.cond, TypeScript.TokenID.IF, false);\r\n            emitter.writeToOutput(\")\");\r\n            emitter.emitJavascriptStatements(this.thenBod, true, false);\r\n            if(this.elseBod) {\r\n                emitter.writeToOutput(\" else\");\r\n                emitter.emitJavascriptStatements(this.elseBod, true, true);\r\n            }\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        IfStatement.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckIf(this);\r\n        };\r\n        IfStatement.prototype.addToControlFlow = function (context) {\r\n            this.cond.addToControlFlow(context);\r\n            var afterIf = new TypeScript.BasicBlock();\r\n            var beforeIf = context.current;\r\n            context.pushStatement(this, beforeIf, afterIf);\r\n            var hasContinuation = false;\r\n            context.current = new TypeScript.BasicBlock();\r\n            beforeIf.addSuccessor(context.current);\r\n            context.walk(this.thenBod, this);\r\n            if(!context.noContinuation) {\r\n                hasContinuation = true;\r\n                context.current.addSuccessor(afterIf);\r\n            }\r\n            if(this.elseBod) {\r\n                context.current = new TypeScript.BasicBlock();\r\n                context.noContinuation = false;\r\n                beforeIf.addSuccessor(context.current);\r\n                context.walk(this.elseBod, this);\r\n                if(!context.noContinuation) {\r\n                    hasContinuation = true;\r\n                    context.current.addSuccessor(afterIf);\r\n                } else {\r\n                    if(hasContinuation) {\r\n                        context.noContinuation = false;\r\n                    }\r\n                }\r\n            } else {\r\n                beforeIf.addSuccessor(afterIf);\r\n                context.noContinuation = false;\r\n                hasContinuation = true;\r\n            }\r\n            var targetInfo = context.popStatement();\r\n            if(afterIf.predecessors.length > 0) {\r\n                context.noContinuation = false;\r\n                hasContinuation = true;\r\n            }\r\n            if(hasContinuation) {\r\n                context.current = afterIf;\r\n            }\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return IfStatement;\r\n    })(Statement);\r\n    TypeScript.IfStatement = IfStatement;    \r\n    var ReturnStatement = (function (_super) {\r\n        __extends(ReturnStatement, _super);\r\n        function ReturnStatement() {\r\n                _super.call(this, TypeScript.NodeType.Return);\r\n            this.returnExpression = null;\r\n        }\r\n        ReturnStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            if(this.returnExpression) {\r\n                emitter.writeToOutput(\"return \");\r\n                emitter.emitJavascript(this.returnExpression, TypeScript.TokenID.SColon, false);\r\n            } else {\r\n                emitter.writeToOutput(\"return;\");\r\n            }\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        ReturnStatement.prototype.addToControlFlow = function (context) {\r\n            _super.prototype.addToControlFlow.call(this, context);\r\n            context.returnStmt();\r\n        };\r\n        ReturnStatement.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckReturn(this);\r\n        };\r\n        return ReturnStatement;\r\n    })(Statement);\r\n    TypeScript.ReturnStatement = ReturnStatement;    \r\n    var EndCode = (function (_super) {\r\n        __extends(EndCode, _super);\r\n        function EndCode() {\r\n                _super.call(this, TypeScript.NodeType.EndCode);\r\n        }\r\n        return EndCode;\r\n    })(AST);\r\n    TypeScript.EndCode = EndCode;    \r\n    var ForInStatement = (function (_super) {\r\n        __extends(ForInStatement, _super);\r\n        function ForInStatement(lval, obj) {\r\n                _super.call(this, TypeScript.NodeType.ForIn);\r\n            this.lval = lval;\r\n            this.obj = obj;\r\n            if(this.lval && (this.lval.nodeType == TypeScript.NodeType.VarDecl)) {\r\n                (this.lval).varFlags |= TypeScript.VarFlags.AutoInit;\r\n            }\r\n        }\r\n        ForInStatement.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        ForInStatement.prototype.isLoop = function () {\r\n            return true;\r\n        };\r\n        ForInStatement.prototype.isFiltered = function () {\r\n            if(this.body) {\r\n                var singleItem = null;\r\n                if(this.body.nodeType == TypeScript.NodeType.List) {\r\n                    var stmts = this.body;\r\n                    if(stmts.members.length == 1) {\r\n                        singleItem = stmts.members[0];\r\n                    }\r\n                } else {\r\n                    singleItem = this.body;\r\n                }\r\n                if(singleItem !== null) {\r\n                    if(singleItem.nodeType == TypeScript.NodeType.Block) {\r\n                        var block = singleItem;\r\n                        if((block.stmts !== null) && (block.stmts.members.length == 1)) {\r\n                            singleItem = block.stmts.members[0];\r\n                        }\r\n                    }\r\n                    if(singleItem.nodeType == TypeScript.NodeType.If) {\r\n                        var cond = (singleItem).cond;\r\n                        if(cond.nodeType == TypeScript.NodeType.Call) {\r\n                            var target = (cond).target;\r\n                            if(target.nodeType == TypeScript.NodeType.Dot) {\r\n                                var binex = target;\r\n                                if((binex.operand1.nodeType == TypeScript.NodeType.Name) && (this.obj.nodeType == TypeScript.NodeType.Name) && ((binex.operand1).text == (this.obj).text)) {\r\n                                    var prop = binex.operand2;\r\n                                    if(prop.text == \"hasOwnProperty\") {\r\n                                        var args = (cond).args;\r\n                                        if((args !== null) && (args.members.length == 1)) {\r\n                                            var arg = args.members[0];\r\n                                            if((arg.nodeType == TypeScript.NodeType.Name) && (this.lval.nodeType == TypeScript.NodeType.Name)) {\r\n                                                if(((this.lval).text) == (arg).text) {\r\n                                                    return true;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        ForInStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            emitter.writeToOutput(\"for(\");\r\n            emitter.emitJavascript(this.lval, TypeScript.TokenID.FOR, false);\r\n            emitter.writeToOutput(\" in \");\r\n            emitter.emitJavascript(this.obj, TypeScript.TokenID.FOR, false);\r\n            emitter.writeToOutput(\")\");\r\n            emitter.emitJavascriptStatements(this.body, true, false);\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        ForInStatement.prototype.typeCheck = function (typeFlow) {\r\n            if(typeFlow.checker.styleSettings.forin) {\r\n                if(!this.isFiltered()) {\r\n                    typeFlow.checker.errorReporter.styleError(this, \"no hasOwnProperty filter\");\r\n                }\r\n            }\r\n            return typeFlow.typeCheckForIn(this);\r\n        };\r\n        ForInStatement.prototype.addToControlFlow = function (context) {\r\n            if(this.lval) {\r\n                context.addContent(this.lval);\r\n            }\r\n            if(this.obj) {\r\n                context.addContent(this.obj);\r\n            }\r\n            var loopHeader = context.current;\r\n            var loopStart = new TypeScript.BasicBlock();\r\n            var afterLoop = new TypeScript.BasicBlock();\r\n            loopHeader.addSuccessor(loopStart);\r\n            context.current = loopStart;\r\n            if(this.body) {\r\n                context.pushStatement(this, loopStart, afterLoop);\r\n                context.walk(this.body, this);\r\n                context.popStatement();\r\n            }\r\n            if(!(context.noContinuation)) {\r\n                var loopEnd = context.current;\r\n                loopEnd.addSuccessor(loopStart);\r\n            }\r\n            context.current = afterLoop;\r\n            context.noContinuation = false;\r\n            loopHeader.addSuccessor(afterLoop);\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return ForInStatement;\r\n    })(Statement);\r\n    TypeScript.ForInStatement = ForInStatement;    \r\n    var ForStatement = (function (_super) {\r\n        __extends(ForStatement, _super);\r\n        function ForStatement(init) {\r\n                _super.call(this, TypeScript.NodeType.For);\r\n            this.init = init;\r\n        }\r\n        ForStatement.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        ForStatement.prototype.isLoop = function () {\r\n            return true;\r\n        };\r\n        ForStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            emitter.writeToOutput(\"for(\");\r\n            if(this.init) {\r\n                if(this.init.nodeType != TypeScript.NodeType.List) {\r\n                    emitter.emitJavascript(this.init, TypeScript.TokenID.FOR, false);\r\n                } else {\r\n                    emitter.emitForVarList(this.init);\r\n                }\r\n            }\r\n            emitter.writeToOutput(\"; \");\r\n            emitter.emitJavascript(this.cond, TypeScript.TokenID.FOR, false);\r\n            emitter.writeToOutput(\"; \");\r\n            emitter.emitJavascript(this.incr, TypeScript.TokenID.FOR, false);\r\n            emitter.writeToOutput(\")\");\r\n            emitter.emitJavascriptStatements(this.body, true, false);\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        ForStatement.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckFor(this);\r\n        };\r\n        ForStatement.prototype.addToControlFlow = function (context) {\r\n            if(this.init) {\r\n                context.addContent(this.init);\r\n            }\r\n            var loopHeader = context.current;\r\n            var loopStart = new TypeScript.BasicBlock();\r\n            var afterLoop = new TypeScript.BasicBlock();\r\n            loopHeader.addSuccessor(loopStart);\r\n            context.current = loopStart;\r\n            var condBlock = null;\r\n            var continueTarget = loopStart;\r\n            var incrBB = null;\r\n            if(this.incr) {\r\n                incrBB = new TypeScript.BasicBlock();\r\n                continueTarget = incrBB;\r\n            }\r\n            if(this.cond) {\r\n                condBlock = context.current;\r\n                context.addContent(this.cond);\r\n                context.current = new TypeScript.BasicBlock();\r\n                condBlock.addSuccessor(context.current);\r\n            }\r\n            var targetInfo = null;\r\n            if(this.body) {\r\n                context.pushStatement(this, continueTarget, afterLoop);\r\n                context.walk(this.body, this);\r\n                targetInfo = context.popStatement();\r\n            }\r\n            if(this.incr) {\r\n                if(context.noContinuation) {\r\n                    if(incrBB.predecessors.length == 0) {\r\n                        context.addUnreachable(this.incr);\r\n                    }\r\n                } else {\r\n                    context.current.addSuccessor(incrBB);\r\n                    context.current = incrBB;\r\n                    context.addContent(this.incr);\r\n                }\r\n            }\r\n            var loopEnd = context.current;\r\n            if(!(context.noContinuation)) {\r\n                loopEnd.addSuccessor(loopStart);\r\n            }\r\n            if(condBlock) {\r\n                condBlock.addSuccessor(afterLoop);\r\n                context.noContinuation = false;\r\n            }\r\n            if(afterLoop.predecessors.length > 0) {\r\n                context.noContinuation = false;\r\n                context.current = afterLoop;\r\n            }\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return ForStatement;\r\n    })(Statement);\r\n    TypeScript.ForStatement = ForStatement;    \r\n    var WithStatement = (function (_super) {\r\n        __extends(WithStatement, _super);\r\n        function WithStatement(expr) {\r\n                _super.call(this, TypeScript.NodeType.With);\r\n            this.expr = expr;\r\n            this.withSym = null;\r\n        }\r\n        WithStatement.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        WithStatement.prototype.isCompoundStatement = function () {\r\n            return true;\r\n        };\r\n        WithStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeToOutput(\"with (\");\r\n            if(this.expr) {\r\n                emitter.emitJavascript(this.expr, TypeScript.TokenID.WITH, false);\r\n            }\r\n            emitter.writeToOutput(\")\");\r\n            emitter.emitJavascriptStatements(this.body, true, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        WithStatement.prototype.typeCheck = function (typeFlow) {\r\n            return typeFlow.typeCheckWith(this);\r\n        };\r\n        return WithStatement;\r\n    })(Statement);\r\n    TypeScript.WithStatement = WithStatement;    \r\n    var SwitchStatement = (function (_super) {\r\n        __extends(SwitchStatement, _super);\r\n        function SwitchStatement(val) {\r\n                _super.call(this, TypeScript.NodeType.Switch);\r\n            this.val = val;\r\n            this.defaultCase = null;\r\n        }\r\n        SwitchStatement.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        SwitchStatement.prototype.isCompoundStatement = function () {\r\n            return true;\r\n        };\r\n        SwitchStatement.prototype.emit = function (emitter, tokenId, startLine) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            var temp = emitter.setInObjectLiteral(false);\r\n            emitter.writeToOutput(\"switch(\");\r\n            emitter.emitJavascript(this.val, TypeScript.TokenID.ID, false);\r\n            emitter.writeLineToOutput(\") {\");\r\n            emitter.increaseIndent();\r\n            var casesLen = this.caseList.members.length;\r\n            for(var i = 0; i < casesLen; i++) {\r\n                var caseExpr = this.caseList.members[i];\r\n                emitter.emitJavascript(caseExpr, TypeScript.TokenID.CASE, true);\r\n                emitter.writeLineToOutput(\"\");\r\n            }\r\n            emitter.decreaseIndent();\r\n            emitter.emitIndent();\r\n            emitter.writeToOutput(\"}\");\r\n            emitter.setInObjectLiteral(temp);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        SwitchStatement.prototype.typeCheck = function (typeFlow) {\r\n            var len = this.caseList.members.length;\r\n            this.val = typeFlow.typeCheck(this.val);\r\n            for(var i = 0; i < len; i++) {\r\n                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);\r\n            }\r\n            this.defaultCase = typeFlow.typeCheck(this.defaultCase);\r\n            this.type = typeFlow.voidType;\r\n            return this;\r\n        };\r\n        SwitchStatement.prototype.addToControlFlow = function (context) {\r\n            var condBlock = context.current;\r\n            context.addContent(this.val);\r\n            var execBlock = new TypeScript.BasicBlock();\r\n            var afterSwitch = new TypeScript.BasicBlock();\r\n            condBlock.addSuccessor(execBlock);\r\n            context.pushSwitch(execBlock);\r\n            context.current = execBlock;\r\n            context.pushStatement(this, execBlock, afterSwitch);\r\n            context.walk(this.caseList, this);\r\n            context.popSwitch();\r\n            var targetInfo = context.popStatement();\r\n            var hasCondContinuation = (this.defaultCase == null);\r\n            if(this.defaultCase == null) {\r\n                condBlock.addSuccessor(afterSwitch);\r\n            }\r\n            if(afterSwitch.predecessors.length > 0) {\r\n                context.noContinuation = false;\r\n                context.current = afterSwitch;\r\n            } else {\r\n                context.noContinuation = true;\r\n            }\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return SwitchStatement;\r\n    })(Statement);\r\n    TypeScript.SwitchStatement = SwitchStatement;    \r\n    var CaseStatement = (function (_super) {\r\n        __extends(CaseStatement, _super);\r\n        function CaseStatement() {\r\n                _super.call(this, TypeScript.NodeType.Case);\r\n            this.expr = null;\r\n        }\r\n        CaseStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            if(this.expr) {\r\n                emitter.writeToOutput(\"case \");\r\n                emitter.emitJavascript(this.expr, TypeScript.TokenID.ID, false);\r\n            } else {\r\n                emitter.writeToOutput(\"default\");\r\n            }\r\n            emitter.writeToOutput(\":\");\r\n            emitter.emitJavascriptStatements(this.body, false, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        CaseStatement.prototype.typeCheck = function (typeFlow) {\r\n            this.expr = typeFlow.typeCheck(this.expr);\r\n            typeFlow.typeCheck(this.body);\r\n            this.type = typeFlow.voidType;\r\n            return this;\r\n        };\r\n        CaseStatement.prototype.addToControlFlow = function (context) {\r\n            var execBlock = new TypeScript.BasicBlock();\r\n            var sw = context.currentSwitch[context.currentSwitch.length - 1];\r\n            if(this.expr) {\r\n                var exprBlock = new TypeScript.BasicBlock();\r\n                context.current = exprBlock;\r\n                sw.addSuccessor(exprBlock);\r\n                context.addContent(this.expr);\r\n                exprBlock.addSuccessor(execBlock);\r\n            } else {\r\n                sw.addSuccessor(execBlock);\r\n            }\r\n            context.current = execBlock;\r\n            if(this.body) {\r\n                context.walk(this.body, this);\r\n            }\r\n            context.noContinuation = false;\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return CaseStatement;\r\n    })(Statement);\r\n    TypeScript.CaseStatement = CaseStatement;    \r\n    var TypeReference = (function (_super) {\r\n        __extends(TypeReference, _super);\r\n        function TypeReference(term, arrayCount) {\r\n                _super.call(this, TypeScript.NodeType.TypeRef);\r\n            this.term = term;\r\n            this.arrayCount = arrayCount;\r\n        }\r\n        TypeReference.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            throw new Error(\"should not emit a type ref\");\r\n        };\r\n        TypeReference.prototype.typeCheck = function (typeFlow) {\r\n            var prevInTCTR = typeFlow.inTypeRefTypeCheck;\r\n            typeFlow.inTypeRefTypeCheck = true;\r\n            var typeLink = TypeScript.getTypeLink(this, typeFlow.checker, true);\r\n            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);\r\n            typeFlow.checkForVoidConstructor(typeLink.type, this);\r\n            this.type = typeLink.type;\r\n            if(this.term) {\r\n                this.term.type = this.type;\r\n            }\r\n            typeFlow.inTypeRefTypeCheck = prevInTCTR;\r\n            return this;\r\n        };\r\n        return TypeReference;\r\n    })(AST);\r\n    TypeScript.TypeReference = TypeReference;    \r\n    var TryFinally = (function (_super) {\r\n        __extends(TryFinally, _super);\r\n        function TryFinally(tryNode, finallyNode) {\r\n                _super.call(this, TypeScript.NodeType.TryFinally);\r\n            this.tryNode = tryNode;\r\n            this.finallyNode = finallyNode;\r\n        }\r\n        TryFinally.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        TryFinally.prototype.isCompoundStatement = function () {\r\n            return true;\r\n        };\r\n        TryFinally.prototype.emit = function (emitter, tokenId, startLine) {\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.emitJavascript(this.tryNode, TypeScript.TokenID.TRY, false);\r\n            emitter.emitJavascript(this.finallyNode, TypeScript.TokenID.FINALLY, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n        };\r\n        TryFinally.prototype.typeCheck = function (typeFlow) {\r\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\r\n            this.finallyNode = typeFlow.typeCheck(this.finallyNode);\r\n            this.type = typeFlow.voidType;\r\n            return this;\r\n        };\r\n        TryFinally.prototype.addToControlFlow = function (context) {\r\n            var afterFinally = new TypeScript.BasicBlock();\r\n            context.walk(this.tryNode, this);\r\n            var finBlock = new TypeScript.BasicBlock();\r\n            if(context.current) {\r\n                context.current.addSuccessor(finBlock);\r\n            }\r\n            context.current = finBlock;\r\n            context.pushStatement(this, null, afterFinally);\r\n            context.walk(this.finallyNode, this);\r\n            if(!context.noContinuation && context.current) {\r\n                context.current.addSuccessor(afterFinally);\r\n            }\r\n            if(afterFinally.predecessors.length > 0) {\r\n                context.current = afterFinally;\r\n            } else {\r\n                context.noContinuation = true;\r\n            }\r\n            context.popStatement();\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        return TryFinally;\r\n    })(Statement);\r\n    TypeScript.TryFinally = TryFinally;    \r\n    var TryCatch = (function (_super) {\r\n        __extends(TryCatch, _super);\r\n        function TryCatch(tryNode, catchNode) {\r\n                _super.call(this, TypeScript.NodeType.TryCatch);\r\n            this.tryNode = tryNode;\r\n            this.catchNode = catchNode;\r\n        }\r\n        TryCatch.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        TryCatch.prototype.isCompoundStatement = function () {\r\n            return true;\r\n        };\r\n        TryCatch.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.emitJavascript(this.tryNode, TypeScript.TokenID.TRY, false);\r\n            emitter.emitJavascript(this.catchNode, TypeScript.TokenID.CATCH, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        TryCatch.prototype.addToControlFlow = function (context) {\r\n            var beforeTry = context.current;\r\n            var tryBlock = new TypeScript.BasicBlock();\r\n            beforeTry.addSuccessor(tryBlock);\r\n            context.current = tryBlock;\r\n            var afterTryCatch = new TypeScript.BasicBlock();\r\n            context.pushStatement(this, null, afterTryCatch);\r\n            context.walk(this.tryNode, this);\r\n            if(!context.noContinuation) {\r\n                if(context.current) {\r\n                    context.current.addSuccessor(afterTryCatch);\r\n                }\r\n            }\r\n            context.current = new TypeScript.BasicBlock();\r\n            beforeTry.addSuccessor(context.current);\r\n            context.walk(this.catchNode, this);\r\n            context.popStatement();\r\n            if(!context.noContinuation) {\r\n                if(context.current) {\r\n                    context.current.addSuccessor(afterTryCatch);\r\n                }\r\n            }\r\n            context.current = afterTryCatch;\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        TryCatch.prototype.typeCheck = function (typeFlow) {\r\n            this.tryNode = typeFlow.typeCheck(this.tryNode);\r\n            this.catchNode = typeFlow.typeCheck(this.catchNode);\r\n            this.type = typeFlow.voidType;\r\n            return this;\r\n        };\r\n        return TryCatch;\r\n    })(Statement);\r\n    TypeScript.TryCatch = TryCatch;    \r\n    var Try = (function (_super) {\r\n        __extends(Try, _super);\r\n        function Try(body) {\r\n                _super.call(this, TypeScript.NodeType.Try);\r\n            this.body = body;\r\n        }\r\n        Try.prototype.isStatementOrExpression = function () {\r\n            return true;\r\n        };\r\n        Try.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeToOutput(\"try \");\r\n            emitter.emitJavascript(this.body, TypeScript.TokenID.TRY, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        Try.prototype.typeCheck = function (typeFlow) {\r\n            this.body = typeFlow.typeCheck(this.body);\r\n            return this;\r\n        };\r\n        Try.prototype.addToControlFlow = function (context) {\r\n            if(this.body) {\r\n                context.walk(this.body, this);\r\n            }\r\n            context.walker.options.goChildren = false;\r\n            context.noContinuation = false;\r\n        };\r\n        return Try;\r\n    })(Statement);\r\n    TypeScript.Try = Try;    \r\n    var Catch = (function (_super) {\r\n        __extends(Catch, _super);\r\n        function Catch(param, body) {\r\n                _super.call(this, TypeScript.NodeType.Catch);\r\n            this.param = param;\r\n            this.body = body;\r\n            this.containedScope = null;\r\n            if(this.param) {\r\n                this.param.varFlags |= TypeScript.VarFlags.AutoInit;\r\n            }\r\n        }\r\n        Catch.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeToOutput(\" catch (\");\r\n            emitter.emitJavascript(this.param, TypeScript.TokenID.LParen, false);\r\n            emitter.writeToOutput(\")\");\r\n            emitter.emitJavascript(this.body, TypeScript.TokenID.CATCH, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        Catch.prototype.addToControlFlow = function (context) {\r\n            if(this.param) {\r\n                context.addContent(this.param);\r\n                var bodBlock = new TypeScript.BasicBlock();\r\n                context.current.addSuccessor(bodBlock);\r\n                context.current = bodBlock;\r\n            }\r\n            if(this.body) {\r\n                context.walk(this.body, this);\r\n            }\r\n            context.noContinuation = false;\r\n            context.walker.options.goChildren = false;\r\n        };\r\n        Catch.prototype.typeCheck = function (typeFlow) {\r\n            var prevScope = typeFlow.scope;\r\n            typeFlow.scope = this.containedScope;\r\n            this.param = typeFlow.typeCheck(this.param);\r\n            var exceptVar = new TypeScript.ValueLocation();\r\n            var varSym = new TypeScript.VariableSymbol((this.param).id.text, this.param.minChar, typeFlow.checker.locationInfo.unitIndex, exceptVar);\r\n            exceptVar.symbol = varSym;\r\n            exceptVar.typeLink = new TypeScript.TypeLink();\r\n            exceptVar.typeLink.type = typeFlow.anyType;\r\n            var thisFnc = typeFlow.thisFnc;\r\n            if(thisFnc && thisFnc.type) {\r\n                exceptVar.symbol.container = thisFnc.type.symbol;\r\n            } else {\r\n                exceptVar.symbol.container = null;\r\n            }\r\n            this.param.sym = exceptVar.symbol;\r\n            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol, typeFlow.checker.errorReporter, false, false, false);\r\n            this.body = typeFlow.typeCheck(this.body);\r\n            if(typeFlow.checker.inProvisionalTypecheckMode()) {\r\n                var table = typeFlow.scope.getTable();\r\n                (table).secondaryTable.table[exceptVar.symbol.name] = undefined;\r\n            }\r\n            this.type = typeFlow.voidType;\r\n            typeFlow.scope = prevScope;\r\n            return this;\r\n        };\r\n        return Catch;\r\n    })(Statement);\r\n    TypeScript.Catch = Catch;    \r\n    var Finally = (function (_super) {\r\n        __extends(Finally, _super);\r\n        function Finally(body) {\r\n                _super.call(this, TypeScript.NodeType.Finally);\r\n            this.body = body;\r\n        }\r\n        Finally.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeToOutput(\"finally\");\r\n            emitter.emitJavascript(this.body, TypeScript.TokenID.FINALLY, false);\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        Finally.prototype.addToControlFlow = function (context) {\r\n            if(this.body) {\r\n                context.walk(this.body, this);\r\n            }\r\n            context.walker.options.goChildren = false;\r\n            context.noContinuation = false;\r\n        };\r\n        Finally.prototype.typeCheck = function (typeFlow) {\r\n            this.body = typeFlow.typeCheck(this.body);\r\n            return this;\r\n        };\r\n        return Finally;\r\n    })(Statement);\r\n    TypeScript.Finally = Finally;    \r\n    var Comment = (function (_super) {\r\n        __extends(Comment, _super);\r\n        function Comment(content, isBlockComment, endsLine) {\r\n                _super.call(this, TypeScript.NodeType.Comment);\r\n            this.content = content;\r\n            this.isBlockComment = isBlockComment;\r\n            this.endsLine = endsLine;\r\n            this.text = null;\r\n        }\r\n        Comment.prototype.getText = function () {\r\n            if(this.text == null) {\r\n                if(this.isBlockComment) {\r\n                    this.text = this.content.split(\"\\n\");\r\n                    for(var i = 0; i < this.text.length; i++) {\r\n                        this.text[i] = this.text[i].replace(/^\\s+|\\s+$/g, '');\r\n                    }\r\n                } else {\r\n                    this.text = [\r\n                        (this.content.replace(/^\\s+|\\s+$/g, ''))\r\n                    ];\r\n                }\r\n            }\r\n            return this.text;\r\n        };\r\n        return Comment;\r\n    })(AST);\r\n    TypeScript.Comment = Comment;    \r\n    var DebuggerStatement = (function (_super) {\r\n        __extends(DebuggerStatement, _super);\r\n        function DebuggerStatement() {\r\n                _super.call(this, TypeScript.NodeType.Debugger);\r\n        }\r\n        DebuggerStatement.prototype.emit = function (emitter, tokenId, startLine, writeDeclFile) {\r\n            emitter.emitParensAndCommentsInPlace(this, true);\r\n            emitter.recordSourceMappingStart(this);\r\n            emitter.writeLineToOutput(\"debugger;\");\r\n            emitter.recordSourceMappingEnd(this);\r\n            emitter.emitParensAndCommentsInPlace(this, false);\r\n        };\r\n        return DebuggerStatement;\r\n    })(Statement);\r\n    TypeScript.DebuggerStatement = DebuggerStatement;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var AstWalkOptions = (function () {\r\n        function AstWalkOptions() {\r\n            this.goChildren = true;\r\n            this.goNextSibling = true;\r\n            this.reverseSiblings = false;\r\n        }\r\n        AstWalkOptions.prototype.stopWalk = function (stop) {\r\n            if (typeof stop === \"undefined\") { stop = true; }\r\n            this.goChildren = !stop;\r\n            this.goNextSibling = !stop;\r\n        };\r\n        return AstWalkOptions;\r\n    })();\r\n    TypeScript.AstWalkOptions = AstWalkOptions;    \r\n    var AstWalker = (function () {\r\n        function AstWalker(childrenWalkers, pre, post, options, state) {\r\n            this.childrenWalkers = childrenWalkers;\r\n            this.pre = pre;\r\n            this.post = post;\r\n            this.options = options;\r\n            this.state = state;\r\n        }\r\n        AstWalker.prototype.walk = function (ast, parent) {\r\n            var preAst = this.pre(ast, parent, this);\r\n            if(preAst === undefined) {\r\n                preAst = ast;\r\n            }\r\n            if(this.options.goChildren) {\r\n                var svGoSib = this.options.goNextSibling;\r\n                this.options.goNextSibling = true;\r\n                this.childrenWalkers[ast.nodeType](ast, parent, this);\r\n                this.options.goNextSibling = svGoSib;\r\n            } else {\r\n                this.options.goChildren = true;\r\n            }\r\n            if(this.post) {\r\n                var postAst = this.post(preAst, parent, this);\r\n                if(postAst === undefined) {\r\n                    postAst = preAst;\r\n                }\r\n                return postAst;\r\n            } else {\r\n                return preAst;\r\n            }\r\n        };\r\n        return AstWalker;\r\n    })();    \r\n    var AstWalkerFactory = (function () {\r\n        function AstWalkerFactory() {\r\n            this.childrenWalkers = [];\r\n            this.initChildrenWalkers();\r\n        }\r\n        AstWalkerFactory.prototype.walk = function (ast, pre, post, options, state) {\r\n            return this.getWalker(pre, post, options, state).walk(ast, null);\r\n        };\r\n        AstWalkerFactory.prototype.getWalker = function (pre, post, options, state) {\r\n            return this.getSlowWalker(pre, post, options, state);\r\n        };\r\n        AstWalkerFactory.prototype.getSlowWalker = function (pre, post, options, state) {\r\n            if(!options) {\r\n                options = new AstWalkOptions();\r\n            }\r\n            return new AstWalker(this.childrenWalkers, pre, post, options, state);\r\n        };\r\n        AstWalkerFactory.prototype.initChildrenWalkers = function () {\r\n            this.childrenWalkers[TypeScript.NodeType.None] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Empty] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.EmptyExpr] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.True] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.False] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.This] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Super] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.QString] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Regex] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Null] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Void] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.NumberLit] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Name] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.QMark] = ChildrenWalkers.walkTrinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Break] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Continue] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.For] = ChildrenWalkers.walkForStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.If] = ChildrenWalkers.walkIfStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Block] = ChildrenWalkers.walkBlockChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Try] = ChildrenWalkers.walkTryChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Catch] = ChildrenWalkers.walkCatchChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.List] = ChildrenWalkers.walkListChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Script] = ChildrenWalkers.walkScriptChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Class] = ChildrenWalkers.walkClassDeclChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Interface] = ChildrenWalkers.walkTypeDeclChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Module] = ChildrenWalkers.walkModuleDeclChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Import] = ChildrenWalkers.walkImportDeclChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.With] = ChildrenWalkers.walkWithStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.Label] = ChildrenWalkers.walkLabelChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;\r\n            this.childrenWalkers[TypeScript.NodeType.EBStart] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.GotoEB] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.EndCode] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Error] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Comment] = ChildrenWalkers.walkNone;\r\n            this.childrenWalkers[TypeScript.NodeType.Debugger] = ChildrenWalkers.walkNone;\r\n            for(var e in (TypeScript.NodeType)._map) {\r\n                if((this.childrenWalkers)[e] === undefined) {\r\n                    throw new Error(\"initWalkers function is not up to date with enum content!\");\r\n                }\r\n            }\r\n        };\r\n        return AstWalkerFactory;\r\n    })();\r\n    TypeScript.AstWalkerFactory = AstWalkerFactory;    \r\n    var globalAstWalkerFactory;\r\n    function getAstWalkerFactory() {\r\n        if(!globalAstWalkerFactory) {\r\n            globalAstWalkerFactory = new AstWalkerFactory();\r\n        }\r\n        return globalAstWalkerFactory;\r\n    }\r\n    TypeScript.getAstWalkerFactory = getAstWalkerFactory;\r\n    var ChildrenWalkers;\r\n    (function (ChildrenWalkers) {\r\n        function walkNone(preAst, parent, walker) {\r\n        }\r\n        ChildrenWalkers.walkNone = walkNone;\r\n        function walkListChildren(preAst, parent, walker) {\r\n            var len = preAst.members.length;\r\n            if(walker.options.reverseSiblings) {\r\n                for(var i = len - 1; i >= 0; i--) {\r\n                    if(walker.options.goNextSibling) {\r\n                        preAst.members[i] = walker.walk(preAst.members[i], preAst);\r\n                    }\r\n                }\r\n            } else {\r\n                for(var i = 0; i < len; i++) {\r\n                    if(walker.options.goNextSibling) {\r\n                        preAst.members[i] = walker.walk(preAst.members[i], preAst);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        ChildrenWalkers.walkListChildren = walkListChildren;\r\n        function walkUnaryExpressionChildren(preAst, parent, walker) {\r\n            if(preAst.castTerm) {\r\n                preAst.castTerm = walker.walk(preAst.castTerm, preAst);\r\n            }\r\n            if(preAst.operand) {\r\n                preAst.operand = walker.walk(preAst.operand, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkUnaryExpressionChildren = walkUnaryExpressionChildren;\r\n        function walkBinaryExpressionChildren(preAst, parent, walker) {\r\n            if(walker.options.reverseSiblings) {\r\n                if(preAst.operand2) {\r\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\r\n                }\r\n                if((preAst.operand1) && (walker.options.goNextSibling)) {\r\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\r\n                }\r\n            } else {\r\n                if(preAst.operand1) {\r\n                    preAst.operand1 = walker.walk(preAst.operand1, preAst);\r\n                }\r\n                if((preAst.operand2) && (walker.options.goNextSibling)) {\r\n                    preAst.operand2 = walker.walk(preAst.operand2, preAst);\r\n                }\r\n            }\r\n        }\r\n        ChildrenWalkers.walkBinaryExpressionChildren = walkBinaryExpressionChildren;\r\n        function walkTypeReferenceChildren(preAst, parent, walker) {\r\n            if(preAst.term) {\r\n                preAst.term = walker.walk(preAst.term, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkTypeReferenceChildren = walkTypeReferenceChildren;\r\n        function walkCallExpressionChildren(preAst, parent, walker) {\r\n            if(!walker.options.reverseSiblings) {\r\n                preAst.target = walker.walk(preAst.target, preAst);\r\n            }\r\n            if(preAst.args && (walker.options.goNextSibling)) {\r\n                preAst.args = walker.walk(preAst.args, preAst);\r\n            }\r\n            if((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {\r\n                preAst.target = walker.walk(preAst.target, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkCallExpressionChildren = walkCallExpressionChildren;\r\n        function walkTrinaryExpressionChildren(preAst, parent, walker) {\r\n            if(preAst.operand1) {\r\n                preAst.operand1 = walker.walk(preAst.operand1, preAst);\r\n            }\r\n            if(preAst.operand2 && (walker.options.goNextSibling)) {\r\n                preAst.operand2 = walker.walk(preAst.operand2, preAst);\r\n            }\r\n            if(preAst.operand3 && (walker.options.goNextSibling)) {\r\n                preAst.operand3 = walker.walk(preAst.operand3, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;\r\n        function walkFuncDeclChildren(preAst, parent, walker) {\r\n            if(preAst.name) {\r\n                preAst.name = walker.walk(preAst.name, preAst);\r\n            }\r\n            if(preAst.args && (preAst.args.members.length > 0) && (walker.options.goNextSibling)) {\r\n                preAst.args = walker.walk(preAst.args, preAst);\r\n            }\r\n            if(preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {\r\n                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);\r\n            }\r\n            if(preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling)) {\r\n                preAst.bod = walker.walk(preAst.bod, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkFuncDeclChildren = walkFuncDeclChildren;\r\n        function walkBoundDeclChildren(preAst, parent, walker) {\r\n            if(preAst.id) {\r\n                preAst.id = walker.walk(preAst.id, preAst);\r\n            }\r\n            if(preAst.init) {\r\n                preAst.init = walker.walk(preAst.init, preAst);\r\n            }\r\n            if((preAst.typeExpr) && (walker.options.goNextSibling)) {\r\n                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkBoundDeclChildren = walkBoundDeclChildren;\r\n        function walkReturnStatementChildren(preAst, parent, walker) {\r\n            if(preAst.returnExpression) {\r\n                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkReturnStatementChildren = walkReturnStatementChildren;\r\n        function walkForStatementChildren(preAst, parent, walker) {\r\n            if(preAst.init) {\r\n                preAst.init = walker.walk(preAst.init, preAst);\r\n            }\r\n            if(preAst.cond && walker.options.goNextSibling) {\r\n                preAst.cond = walker.walk(preAst.cond, preAst);\r\n            }\r\n            if(preAst.incr && walker.options.goNextSibling) {\r\n                preAst.incr = walker.walk(preAst.incr, preAst);\r\n            }\r\n            if(preAst.body && walker.options.goNextSibling) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkForStatementChildren = walkForStatementChildren;\r\n        function walkForInStatementChildren(preAst, parent, walker) {\r\n            preAst.lval = walker.walk(preAst.lval, preAst);\r\n            if(walker.options.goNextSibling) {\r\n                preAst.obj = walker.walk(preAst.obj, preAst);\r\n            }\r\n            if(preAst.body && (walker.options.goNextSibling)) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkForInStatementChildren = walkForInStatementChildren;\r\n        function walkIfStatementChildren(preAst, parent, walker) {\r\n            preAst.cond = walker.walk(preAst.cond, preAst);\r\n            if(preAst.thenBod && (walker.options.goNextSibling)) {\r\n                preAst.thenBod = walker.walk(preAst.thenBod, preAst);\r\n            }\r\n            if(preAst.elseBod && (walker.options.goNextSibling)) {\r\n                preAst.elseBod = walker.walk(preAst.elseBod, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkIfStatementChildren = walkIfStatementChildren;\r\n        function walkWhileStatementChildren(preAst, parent, walker) {\r\n            preAst.cond = walker.walk(preAst.cond, preAst);\r\n            if(preAst.body && (walker.options.goNextSibling)) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkWhileStatementChildren = walkWhileStatementChildren;\r\n        function walkDoWhileStatementChildren(preAst, parent, walker) {\r\n            preAst.cond = walker.walk(preAst.cond, preAst);\r\n            if(preAst.body && (walker.options.goNextSibling)) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkDoWhileStatementChildren = walkDoWhileStatementChildren;\r\n        function walkBlockChildren(preAst, parent, walker) {\r\n            if(preAst.stmts) {\r\n                preAst.stmts = walker.walk(preAst.stmts, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkBlockChildren = walkBlockChildren;\r\n        function walkCaseStatementChildren(preAst, parent, walker) {\r\n            if(preAst.expr) {\r\n                preAst.expr = walker.walk(preAst.expr, preAst);\r\n            }\r\n            if(preAst.body && walker.options.goNextSibling) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkCaseStatementChildren = walkCaseStatementChildren;\r\n        function walkSwitchStatementChildren(preAst, parent, walker) {\r\n            if(preAst.val) {\r\n                preAst.val = walker.walk(preAst.val, preAst);\r\n            }\r\n            if((preAst.caseList) && walker.options.goNextSibling) {\r\n                preAst.caseList = walker.walk(preAst.caseList, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkSwitchStatementChildren = walkSwitchStatementChildren;\r\n        function walkTryChildren(preAst, parent, walker) {\r\n            if(preAst.body) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkTryChildren = walkTryChildren;\r\n        function walkTryCatchChildren(preAst, parent, walker) {\r\n            if(preAst.tryNode) {\r\n                preAst.tryNode = walker.walk(preAst.tryNode, preAst);\r\n            }\r\n            if((preAst.catchNode) && walker.options.goNextSibling) {\r\n                preAst.catchNode = walker.walk(preAst.catchNode, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkTryCatchChildren = walkTryCatchChildren;\r\n        function walkTryFinallyChildren(preAst, parent, walker) {\r\n            if(preAst.tryNode) {\r\n                preAst.tryNode = walker.walk(preAst.tryNode, preAst);\r\n            }\r\n            if(preAst.finallyNode && walker.options.goNextSibling) {\r\n                preAst.finallyNode = walker.walk(preAst.finallyNode, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkTryFinallyChildren = walkTryFinallyChildren;\r\n        function walkFinallyChildren(preAst, parent, walker) {\r\n            if(preAst.body) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkFinallyChildren = walkFinallyChildren;\r\n        function walkCatchChildren(preAst, parent, walker) {\r\n            if(preAst.param) {\r\n                preAst.param = walker.walk(preAst.param, preAst);\r\n            }\r\n            if((preAst.body) && walker.options.goNextSibling) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkCatchChildren = walkCatchChildren;\r\n        function walkRecordChildren(preAst, parent, walker) {\r\n            preAst.name = walker.walk(preAst.name, preAst);\r\n            if(walker.options.goNextSibling && preAst.members) {\r\n                preAst.members = walker.walk(preAst.members, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkRecordChildren = walkRecordChildren;\r\n        function walkNamedTypeChildren(preAst, parent, walker) {\r\n            walkRecordChildren(preAst, parent, walker);\r\n        }\r\n        ChildrenWalkers.walkNamedTypeChildren = walkNamedTypeChildren;\r\n        function walkClassDeclChildren(preAst, parent, walker) {\r\n            walkNamedTypeChildren(preAst, parent, walker);\r\n            if(walker.options.goNextSibling && preAst.baseClass) {\r\n                preAst.baseClass = walker.walk(preAst.baseClass, preAst);\r\n            }\r\n            if(walker.options.goNextSibling && preAst.implementsList) {\r\n                preAst.implementsList = walker.walk(preAst.implementsList, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkClassDeclChildren = walkClassDeclChildren;\r\n        function walkScriptChildren(preAst, parent, walker) {\r\n            if(preAst.bod) {\r\n                preAst.bod = walker.walk(preAst.bod, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkScriptChildren = walkScriptChildren;\r\n        function walkTypeDeclChildren(preAst, parent, walker) {\r\n            walkNamedTypeChildren(preAst, parent, walker);\r\n            if(walker.options.goNextSibling && preAst.extendsList) {\r\n                preAst.extendsList = walker.walk(preAst.extendsList, preAst);\r\n            }\r\n            if(walker.options.goNextSibling && preAst.implementsList) {\r\n                preAst.implementsList = walker.walk(preAst.implementsList, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkTypeDeclChildren = walkTypeDeclChildren;\r\n        function walkModuleDeclChildren(preAst, parent, walker) {\r\n            walkRecordChildren(preAst, parent, walker);\r\n            if(walker.options.goNextSibling && preAst.alias) {\r\n                preAst.alias = walker.walk(preAst.alias, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkModuleDeclChildren = walkModuleDeclChildren;\r\n        function walkImportDeclChildren(preAst, parent, walker) {\r\n            if(preAst.id) {\r\n                preAst.id = walker.walk(preAst.id, preAst);\r\n            }\r\n            if(preAst.alias) {\r\n                preAst.alias = walker.walk(preAst.alias, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkImportDeclChildren = walkImportDeclChildren;\r\n        function walkWithStatementChildren(preAst, parent, walker) {\r\n            if(preAst.expr) {\r\n                preAst.expr = walker.walk(preAst.expr, preAst);\r\n            }\r\n            if(preAst.body && walker.options.goNextSibling) {\r\n                preAst.body = walker.walk(preAst.body, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkWithStatementChildren = walkWithStatementChildren;\r\n        function walkLabelChildren(preAst, parent, walker) {\r\n        }\r\n        ChildrenWalkers.walkLabelChildren = walkLabelChildren;\r\n        function walkLabeledStatementChildren(preAst, parent, walker) {\r\n            preAst.labels = walker.walk(preAst.labels, preAst);\r\n            if(walker.options.goNextSibling) {\r\n                preAst.stmt = walker.walk(preAst.stmt, preAst);\r\n            }\r\n        }\r\n        ChildrenWalkers.walkLabeledStatementChildren = walkLabeledStatementChildren;\r\n    })(ChildrenWalkers || (ChildrenWalkers = {}));\r\n\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    function lastOf(items) {\r\n        return (items === null || items.length === 0) ? null : items[items.length - 1];\r\n    }\r\n    TypeScript.lastOf = lastOf;\r\n    function max(a, b) {\r\n        return a >= b ? a : b;\r\n    }\r\n    TypeScript.max = max;\r\n    function min(a, b) {\r\n        return a <= b ? a : b;\r\n    }\r\n    TypeScript.min = min;\r\n    var AstPath = (function () {\r\n        function AstPath() {\r\n            this.asts = [];\r\n            this.top = -1;\r\n        }\r\n        AstPath.reverseIndexOf = function reverseIndexOf(items, index) {\r\n            return (items === null || items.length <= index) ? null : items[items.length - index - 1];\r\n        }\r\n        AstPath.prototype.clone = function () {\r\n            var clone = new AstPath();\r\n            clone.asts = this.asts.map(function (value) {\r\n                return value;\r\n            });\r\n            clone.top = this.top;\r\n            return clone;\r\n        };\r\n        AstPath.prototype.pop = function () {\r\n            var head = this.ast();\r\n            this.up();\r\n            while(this.asts.length > this.count()) {\r\n                this.asts.pop();\r\n            }\r\n            return head;\r\n        };\r\n        AstPath.prototype.push = function (ast) {\r\n            while(this.asts.length > this.count()) {\r\n                this.asts.pop();\r\n            }\r\n            this.top = this.asts.length;\r\n            this.asts.push(ast);\r\n        };\r\n        AstPath.prototype.up = function () {\r\n            if(this.top <= -1) {\r\n                throw new Error(\"Invalid call to 'up'\");\r\n            }\r\n            this.top--;\r\n        };\r\n        AstPath.prototype.down = function () {\r\n            if(this.top == this.ast.length - 1) {\r\n                throw new Error(\"Invalid call to 'down'\");\r\n            }\r\n            this.top++;\r\n        };\r\n        AstPath.prototype.nodeType = function () {\r\n            if(this.ast() == null) {\r\n                return TypeScript.NodeType.None;\r\n            }\r\n            return this.ast().nodeType;\r\n        };\r\n        AstPath.prototype.ast = function () {\r\n            return AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));\r\n        };\r\n        AstPath.prototype.parent = function () {\r\n            return AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);\r\n        };\r\n        AstPath.prototype.count = function () {\r\n            return this.top + 1;\r\n        };\r\n        AstPath.prototype.get = function (index) {\r\n            return this.asts[index];\r\n        };\r\n        AstPath.prototype.isNameOfClass = function () {\r\n            if(this.ast() === null || this.parent() === null) {\r\n                return false;\r\n            }\r\n            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.Class) && ((this.parent()).name === this.ast());\r\n        };\r\n        AstPath.prototype.isNameOfInterface = function () {\r\n            if(this.ast() === null || this.parent() === null) {\r\n                return false;\r\n            }\r\n            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.Interface) && ((this.parent()).name === this.ast());\r\n        };\r\n        AstPath.prototype.isNameOfArgument = function () {\r\n            if(this.ast() === null || this.parent() === null) {\r\n                return false;\r\n            }\r\n            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.ArgDecl) && ((this.parent()).id === this.ast());\r\n        };\r\n        AstPath.prototype.isNameOfVariable = function () {\r\n            if(this.ast() === null || this.parent() === null) {\r\n                return false;\r\n            }\r\n            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.VarDecl) && ((this.parent()).id === this.ast());\r\n        };\r\n        AstPath.prototype.isNameOfModule = function () {\r\n            if(this.ast() === null || this.parent() === null) {\r\n                return false;\r\n            }\r\n            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.Module) && ((this.parent()).name === this.ast());\r\n        };\r\n        AstPath.prototype.isNameOfFunction = function () {\r\n            if(this.ast() === null || this.parent() === null) {\r\n                return false;\r\n            }\r\n            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.FuncDecl) && ((this.parent()).name === this.ast());\r\n        };\r\n        AstPath.prototype.isChildOfScript = function () {\r\n            var ast = lastOf(this.asts);\r\n            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && this.asts[this.top - 2].nodeType === TypeScript.NodeType.Script;\r\n        };\r\n        AstPath.prototype.isChildOfModule = function () {\r\n            var ast = lastOf(this.asts);\r\n            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && this.asts[this.top - 2].nodeType === TypeScript.NodeType.Module;\r\n        };\r\n        AstPath.prototype.isChildOfClass = function () {\r\n            var ast = lastOf(this.asts);\r\n            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && this.asts[this.top - 2].nodeType === TypeScript.NodeType.Class;\r\n        };\r\n        AstPath.prototype.isArgumentOfClassConstructor = function () {\r\n            var ast = lastOf(this.asts);\r\n            return this.count() >= 5 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl && this.asts[this.top - 3].nodeType === TypeScript.NodeType.List && this.asts[this.top - 4].nodeType === TypeScript.NodeType.Class && ((this.asts[this.top - 2]).isConstructor) && ((this.asts[this.top - 2]).args === this.asts[this.top - 1]) && ((this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);\r\n        };\r\n        AstPath.prototype.isChildOfInterface = function () {\r\n            var ast = lastOf(this.asts);\r\n            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && this.asts[this.top - 2].nodeType === TypeScript.NodeType.Interface;\r\n        };\r\n        AstPath.prototype.isTopLevelImplicitModule = function () {\r\n            return this.count() >= 1 && this.asts[this.top].nodeType === TypeScript.NodeType.Module && TypeScript.hasFlag((this.asts[this.top]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\r\n        };\r\n        AstPath.prototype.isBodyOfTopLevelImplicitModule = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Module && (this.asts[this.top - 1]).members == this.asts[this.top - 0] && TypeScript.hasFlag((this.asts[this.top - 1]).modFlags, TypeScript.ModuleFlags.IsWholeFile);\r\n        };\r\n        AstPath.prototype.isBodyOfScript = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Script && (this.asts[this.top - 1]).bod == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfSwitch = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Switch && (this.asts[this.top - 1]).caseList == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfModule = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Module && (this.asts[this.top - 1]).members == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfClass = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Class && (this.asts[this.top - 1]).members == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfFunction = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl && (this.asts[this.top - 1]).bod == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfInterface = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Interface && (this.asts[this.top - 1]).members == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfBlock = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Block && (this.asts[this.top - 1]).stmts == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfFor = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.For && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfCase = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Case && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfTry = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Try && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfCatch = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Catch && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfDoWhile = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.DoWhile && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfWhile = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.While && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfForIn = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.ForIn && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfWith = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.With && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfFinally = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Finally && (this.asts[this.top - 1]).body == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isCaseOfSwitch = function () {\r\n            return this.count() >= 3 && this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && (this.asts[this.top - 2]).caseList == this.asts[this.top - 1];\r\n        };\r\n        AstPath.prototype.isDefaultCaseOfSwitch = function () {\r\n            return this.count() >= 3 && this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && (this.asts[this.top - 2]).caseList == this.asts[this.top - 1] && (this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isListOfObjectLit = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && (this.asts[this.top - 1]).operand == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfObjectLit = function () {\r\n            return this.isListOfObjectLit();\r\n        };\r\n        AstPath.prototype.isEmptyListOfObjectLit = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && (this.asts[this.top - 1]).operand == this.asts[this.top - 0] && (this.asts[this.top - 0]).members.length == 0;\r\n        };\r\n        AstPath.prototype.isMemberOfObjectLit = function () {\r\n            return this.count() >= 3 && this.asts[this.top - 2].nodeType === TypeScript.NodeType.ObjectLit && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && this.asts[this.top - 0].nodeType === TypeScript.NodeType.Member && (this.asts[this.top - 2]).operand == this.asts[this.top - 1];\r\n        };\r\n        AstPath.prototype.isNameOfMemberOfObjectLit = function () {\r\n            return this.count() >= 4 && this.asts[this.top - 3].nodeType === TypeScript.NodeType.ObjectLit && this.asts[this.top - 2].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member && this.asts[this.top - 0].nodeType === TypeScript.NodeType.Name && (this.asts[this.top - 3]).operand == this.asts[this.top - 2];\r\n        };\r\n        AstPath.prototype.isListOfArrayLit = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.ArrayLit && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && (this.asts[this.top - 1]).operand == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isTargetOfMember = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member && (this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isMemberOfMember = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member && (this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isItemOfList = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List;\r\n        };\r\n        AstPath.prototype.isThenOfIf = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.If && (this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isElseOfIf = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.If && (this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isBodyOfDefaultCase = function () {\r\n            return this.isBodyOfCase();\r\n        };\r\n        AstPath.prototype.isSingleStatementList = function () {\r\n            return this.count() >= 1 && this.asts[this.top].nodeType === TypeScript.NodeType.List && (this.asts[this.top]).members.length === 1;\r\n        };\r\n        AstPath.prototype.isArgumentListOfFunction = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl && (this.asts[this.top - 1]).args === this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isArgumentOfFunction = function () {\r\n            return this.count() >= 3 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.List && this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl && (this.asts[this.top - 2]).args === this.asts[this.top - 1];\r\n        };\r\n        AstPath.prototype.isArgumentListOfCall = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.Call && (this.asts[this.top - 1]).args === this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isArgumentListOfNew = function () {\r\n            return this.count() >= 2 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.New && (this.asts[this.top - 1]).args === this.asts[this.top - 0];\r\n        };\r\n        AstPath.prototype.isSynthesizedBlock = function () {\r\n            return this.count() >= 1 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.Block && (this.asts[this.top - 0]).visible === false;\r\n        };\r\n        return AstPath;\r\n    })();\r\n    TypeScript.AstPath = AstPath;    \r\n    function isValidAstNode(ast) {\r\n        if(ast === null) {\r\n            return false;\r\n        }\r\n        if(ast.minChar === -1 || ast.limChar === -1) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    TypeScript.isValidAstNode = isValidAstNode;\r\n    var AstPathContext = (function () {\r\n        function AstPathContext() {\r\n            this.path = new TypeScript.AstPath();\r\n        }\r\n        return AstPathContext;\r\n    })();\r\n    TypeScript.AstPathContext = AstPathContext;    \r\n    (function (GetAstPathOptions) {\r\n        GetAstPathOptions._map = [];\r\n        GetAstPathOptions.Default = 0;\r\n        GetAstPathOptions.EdgeInclusive = 1;\r\n        GetAstPathOptions.DontPruneSearchBasedOnPosition = 1 << 1;\r\n    })(TypeScript.GetAstPathOptions || (TypeScript.GetAstPathOptions = {}));\r\n    var GetAstPathOptions = TypeScript.GetAstPathOptions;\r\n\r\n    function getAstPathToPosition(script, pos, options) {\r\n        if (typeof options === \"undefined\") { options = GetAstPathOptions.Default; }\r\n        var lookInComments = function (comments) {\r\n            if(comments && comments.length > 0) {\r\n                for(var i = 0; i < comments.length; i++) {\r\n                    var minChar = comments[i].minChar;\r\n                    var limChar = comments[i].limChar;\r\n                    if(!comments[i].isBlockComment) {\r\n                        limChar++;\r\n                    }\r\n                    if(pos >= minChar && pos < limChar) {\r\n                        ctx.path.push(comments[i]);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        var pre = function (cur, parent, walker) {\r\n            if(isValidAstNode(cur)) {\r\n                var inclusive = TypeScript.hasFlag(options, GetAstPathOptions.EdgeInclusive) || cur.nodeType === TypeScript.NodeType.Name || pos === script.limChar;\r\n                var minChar = cur.minChar;\r\n                var limChar = cur.limChar + (inclusive ? 1 : 0);\r\n                if(pos >= minChar && pos < limChar) {\r\n                    var previous = ctx.path.ast();\r\n                    if(previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {\r\n                        ctx.path.push(cur);\r\n                    } else {\r\n                    }\r\n                }\r\n                if(pos < limChar) {\r\n                    lookInComments(cur.preComments);\r\n                }\r\n                if(pos >= minChar) {\r\n                    lookInComments(cur.postComments);\r\n                }\r\n                if(!TypeScript.hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {\r\n                    walker.options.goChildren = (minChar <= pos && pos <= limChar);\r\n                }\r\n            }\r\n            return cur;\r\n        };\r\n        var ctx = new AstPathContext();\r\n        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);\r\n        return ctx.path;\r\n    }\r\n    TypeScript.getAstPathToPosition = getAstPathToPosition;\r\n    function getTokenizationOffset(script, position) {\r\n        var bestOffset = 0;\r\n        var pre = function (cur, parent, walker) {\r\n            if(TypeScript.isValidAstNode(cur)) {\r\n                if(cur.minChar <= position) {\r\n                    bestOffset = max(bestOffset, cur.minChar);\r\n                }\r\n                if(cur.minChar > position || cur.limChar < bestOffset) {\r\n                    walker.options.goChildren = false;\r\n                }\r\n            }\r\n            return cur;\r\n        };\r\n        TypeScript.getAstWalkerFactory().walk(script, pre);\r\n        return bestOffset;\r\n    }\r\n    TypeScript.getTokenizationOffset = getTokenizationOffset;\r\n    function walkAST(ast, callback) {\r\n        var pre = function (cur, parent, walker) {\r\n            var path = walker.state;\r\n            path.push(cur);\r\n            callback(path, walker);\r\n            return cur;\r\n        };\r\n        var post = function (cur, parent, walker) {\r\n            var path = walker.state;\r\n            path.pop();\r\n            return cur;\r\n        };\r\n        var path = new AstPath();\r\n        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);\r\n    }\r\n    TypeScript.walkAST = walkAST;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var AstLogger = (function () {\r\n        function AstLogger(logger) {\r\n            this.logger = logger;\r\n        }\r\n        AstLogger.prototype.logScript = function (script) {\r\n            var _this = this;\r\n            this.logLinemap(script.locationInfo.lineMap);\r\n            var stack = [];\r\n            var pre = function (cur, parent) {\r\n                stack.push(cur);\r\n                var indent = (stack.length - 1) * 2;\r\n                _this.logComments(script, cur.preComments, indent);\r\n                _this.logNode(script, cur, indent);\r\n                _this.logComments(script, cur.postComments, indent);\r\n                return cur;\r\n            };\r\n            var post = function (cur, parent) {\r\n                stack.pop();\r\n                return cur;\r\n            };\r\n            TypeScript.getAstWalkerFactory().walk(script, pre, post);\r\n        };\r\n        AstLogger.prototype.logNode = function (script, cur, indent) {\r\n            var msg = this.addPadding(\"\", indent, \"| \", true);\r\n            msg = msg.concat(\"+ \" + cur.treeViewLabel());\r\n            msg = this.addPadding(msg, 70, \" \", false);\r\n            msg = msg + this.addLineColumn(script, cur.minChar);\r\n            msg = this.addPadding(msg, 80, \" \", false);\r\n            msg = msg + \"=> \";\r\n            msg = msg + this.addLineColumn(script, cur.limChar);\r\n            msg = this.addPadding(msg, 102, \" \", false);\r\n            msg = msg.concat(\"[\" + this.addPadding(cur.minChar.toString(), 1, \" \", true) + \", \" + this.addPadding(cur.limChar.toString(), 1, \" \", true) + \"]\");\r\n            msg = this.addPadding(msg, 115, \" \", false);\r\n            msg = msg.concat(\"sym=\" + (cur).sym);\r\n            msg = this.addPadding(msg, 135, \" \", false);\r\n            msg = msg.concat(\"type=\" + (cur.type === null ? \"null\" : cur.type.getTypeName()));\r\n            this.logger.log(msg);\r\n        };\r\n        AstLogger.prototype.logComments = function (script, comments, indent) {\r\n            if(comments == null) {\r\n                return;\r\n            }\r\n            for(var i = 0; i < comments.length; i++) {\r\n                this.logNode(script, comments[i], indent);\r\n            }\r\n        };\r\n        AstLogger.prototype.logLinemap = function (linemap) {\r\n            var result = \"[\";\r\n            for(var i = 0; i < linemap.length; i++) {\r\n                if(i > 0) {\r\n                    result += \",\";\r\n                }\r\n                result += linemap[i];\r\n            }\r\n            result += \"]\";\r\n            this.logger.log(\"linemap: \" + result);\r\n        };\r\n        AstLogger.prototype.addPadding = function (s, targetLength, paddingString, leftPadding) {\r\n            var result = (leftPadding ? \"\" : s);\r\n            for(var i = s.length; i < targetLength; i++) {\r\n                result = result + paddingString;\r\n            }\r\n            result = result + (leftPadding ? s : \"\");\r\n            return result;\r\n        };\r\n        AstLogger.prototype.addLineColumn = function (script, position) {\r\n            var lineInfo = {\r\n                line: -1,\r\n                col: -1\r\n            };\r\n            TypeScript.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);\r\n            if(lineInfo.col !== -1) {\r\n                lineInfo.col++;\r\n            }\r\n            return \"(\" + lineInfo.line + \", \" + lineInfo.col + \")\";\r\n        };\r\n        return AstLogger;\r\n    })();\r\n    TypeScript.AstLogger = AstLogger;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var Binder = (function () {\r\n        function Binder(checker) {\r\n            this.checker = checker;\r\n        }\r\n        Binder.prototype.resolveBaseTypeLinks = function (typeLinks, scope) {\r\n            var extendsList = null;\r\n            if(typeLinks) {\r\n                extendsList = new Array();\r\n                for(var i = 0, len = typeLinks.length; i < len; i++) {\r\n                    var typeLink = typeLinks[i];\r\n                    this.checker.resolvingBases = true;\r\n                    this.checker.resolveTypeLink(scope, typeLink, true);\r\n                    this.checker.resolvingBases = false;\r\n                    if(typeLink.type.isClass()) {\r\n                        extendsList[i] = typeLink.type.instanceType;\r\n                    } else {\r\n                        extendsList[i] = typeLink.type;\r\n                    }\r\n                }\r\n            }\r\n            return extendsList;\r\n        };\r\n        Binder.prototype.resolveBases = function (scope, type) {\r\n            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);\r\n            var i = 0;\r\n            var len = type.extendsList.length;\r\n\r\n            var derivedIsClass = type.isClassInstance();\r\n            for(; i < len; i++) {\r\n                var baseIsClass = type.extendsList[i].isClassInstance();\r\n                if(type.extendsList[i] != this.checker.anyType) {\r\n                    if(derivedIsClass) {\r\n                        if(!baseIsClass) {\r\n                            this.checker.errorReporter.simpleErrorFromSym(type.symbol, \"A export class may only extend other classes, \" + type.extendsList[i].symbol.fullName() + \" is an interface.\");\r\n                        }\r\n                    } else {\r\n                        if(baseIsClass) {\r\n                            this.checker.errorReporter.simpleErrorFromSym(type.symbol, \"An interface may only extend other interfaces, \" + type.extendsList[i].symbol.fullName() + \" is a class.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);\r\n            if(type.implementsList) {\r\n                for(i = 0 , len = type.implementsList.length; i < len; i++) {\r\n                    var iface = type.implementsList[i];\r\n                    if(iface.isClassInstance()) {\r\n                        if(derivedIsClass) {\r\n                            this.checker.errorReporter.simpleErrorFromSym(type.symbol, \"A class may only implement an interface; \" + iface.symbol.fullName() + \" is a class.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Binder.prototype.resolveSignatureGroup = function (signatureGroup, scope, instanceType) {\r\n            var supplyVar = !(signatureGroup.hasImplementation);\r\n            for(var i = 0, len = signatureGroup.signatures.length; i < len; i++) {\r\n                var signature = signatureGroup.signatures[i];\r\n                if(instanceType) {\r\n                    signature.returnType.type = instanceType;\r\n                } else {\r\n                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);\r\n                }\r\n                var paramLen = signature.parameters.length;\r\n                for(var j = 0; j < paramLen; j++) {\r\n                    this.bindSymbol(scope, signature.parameters[j]);\r\n                }\r\n                if(signature.hasVariableArgList) {\r\n                    var lastParam = signature.parameters[paramLen - 1];\r\n                    lastParam.argsOffset = paramLen - 1;\r\n                    if(!lastParam.getType().isArray()) {\r\n                        this.checker.errorReporter.simpleErrorFromSym(lastParam, \"... parameter must have array type\");\r\n                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Binder.prototype.bindType = function (scope, type, instanceType) {\r\n            if(instanceType) {\r\n                this.bindType(scope, instanceType, null);\r\n            }\r\n            if(type.hasMembers()) {\r\n                var members = type.members;\r\n                var ambientMembers = type.ambientMembers;\r\n                var typeMembers = type.getAllEnclosedTypes();\r\n                var ambientTypeMembers = type.getAllAmbientEnclosedTypes();\r\n                var memberScope = new TypeScript.SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);\r\n                var agg = new TypeScript.SymbolAggregateScope(type.symbol);\r\n                var prevCurrentModDecl = this.checker.currentModDecl;\r\n                var prevBindStatus = this.checker.inBind;\r\n                agg.addParentScope(memberScope);\r\n                agg.addParentScope(scope);\r\n                if(type.isModuleType()) {\r\n                    this.checker.currentModDecl = type.symbol.declAST;\r\n                    this.checker.inBind = true;\r\n                }\r\n                if(members) {\r\n                    this.bind(agg, type.members.allMembers);\r\n                }\r\n                if(typeMembers) {\r\n                    this.bind(agg, typeMembers.allMembers);\r\n                }\r\n                if(ambientMembers) {\r\n                    this.bind(agg, ambientMembers.allMembers);\r\n                }\r\n                if(ambientTypeMembers) {\r\n                    this.bind(agg, ambientTypeMembers.allMembers);\r\n                }\r\n                this.checker.currentModDecl = prevCurrentModDecl;\r\n                this.checker.inBind = prevBindStatus;\r\n            }\r\n            if(type.extendsTypeLinks) {\r\n                this.resolveBases(scope, type);\r\n            }\r\n            if(type.construct) {\r\n                this.resolveSignatureGroup(type.construct, scope, instanceType);\r\n            }\r\n            if(type.call) {\r\n                this.resolveSignatureGroup(type.call, scope, null);\r\n            }\r\n            if(type.index) {\r\n                this.resolveSignatureGroup(type.index, scope, null);\r\n            }\r\n            if(type.elementType) {\r\n                this.bindType(scope, type.elementType, null);\r\n            }\r\n        };\r\n        Binder.prototype.bindSymbol = function (scope, symbol) {\r\n            if(!symbol.bound) {\r\n                var prevLocationInfo = this.checker.locationInfo;\r\n                if((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {\r\n                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];\r\n                }\r\n                switch(symbol.kind()) {\r\n                    case TypeScript.SymbolKind.Type: {\r\n                        if(symbol.flags & TypeScript.SymbolFlags.Bound) {\r\n                            break;\r\n                        }\r\n                        var typeSymbol = symbol;\r\n                        typeSymbol.flags |= TypeScript.SymbolFlags.Bound;\r\n                        if(typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == TypeScript.NodeType.Name) {\r\n                            var modPath = (typeSymbol.aliasLink.alias).text;\r\n                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, function (id) {\r\n                                return scope.find(id, false, true);\r\n                            });\r\n                            if(modSym) {\r\n                                typeSymbol.type = modSym.getType();\r\n                            }\r\n                        }\r\n                        if(typeSymbol.type && typeSymbol.type != this.checker.gloModType) {\r\n                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);\r\n                            if(typeSymbol.type.isModuleType()) {\r\n                                for(var i = 0; i < typeSymbol.expansions.length; i++) {\r\n                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.SymbolKind.Field: {\r\n                        this.checker.resolveTypeLink(scope, (symbol).field.typeLink, false);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.SymbolKind.Parameter: {\r\n                        this.checker.resolveTypeLink(scope, (symbol).parameter.typeLink, true);\r\n                        break;\r\n\r\n                    }\r\n                }\r\n                this.checker.locationInfo = prevLocationInfo;\r\n            }\r\n            symbol.bound = true;\r\n        };\r\n        Binder.prototype.bind = function (scope, table) {\r\n            table.map(function (key, sym, binder) {\r\n                binder.bindSymbol(scope, sym);\r\n            }, this);\r\n        };\r\n        return Binder;\r\n    })();\r\n    TypeScript.Binder = Binder;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var Base64Format = (function () {\r\n        function Base64Format() { }\r\n        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n        Base64Format.encode = function encode(inValue) {\r\n            if(inValue < 64) {\r\n                return Base64Format.encodedValues.charAt(inValue);\r\n            }\r\n            throw TypeError(inValue + \": not a 64 based value\");\r\n        }\r\n        Base64Format.decodeChar = function decodeChar(inChar) {\r\n            if(inChar.length === 1) {\r\n                return Base64Format.encodedValues.indexOf(inChar);\r\n            } else {\r\n                throw TypeError('\"' + inChar + '\" must have length 1');\r\n            }\r\n        }\r\n        return Base64Format;\r\n    })();    \r\n    var Base64VLQFormat = (function () {\r\n        function Base64VLQFormat() { }\r\n        Base64VLQFormat.encode = function encode(inValue) {\r\n            if(inValue < 0) {\r\n                inValue = ((-inValue) << 1) + 1;\r\n            } else {\r\n                inValue = inValue << 1;\r\n            }\r\n            var encodedStr = \"\";\r\n            do {\r\n                var currentDigit = inValue & 31;\r\n                inValue = inValue >> 5;\r\n                if(inValue > 0) {\r\n                    currentDigit = currentDigit | 32;\r\n                }\r\n                encodedStr = encodedStr + Base64Format.encode(currentDigit);\r\n            }while(inValue > 0)\r\n            return encodedStr;\r\n        }\r\n        Base64VLQFormat.decode = function decode(inString) {\r\n            var result = 0;\r\n            var negative = false;\r\n            var shift = 0;\r\n            for(var i = 0; i < inString.length; i++) {\r\n                var byte = Base64Format.decodeChar(inString[i]);\r\n                if(i === 0) {\r\n                    if((byte & 1) === 1) {\r\n                        negative = true;\r\n                    }\r\n                    result = (byte >> 1) & 15;\r\n                } else {\r\n                    result = result | ((byte & 31) << shift);\r\n                }\r\n                shift += (i == 0) ? 4 : 5;\r\n                if((byte & 32) === 32) {\r\n                } else {\r\n                    return {\r\n                        value: negative ? -(result) : result,\r\n                        rest: inString.substr(i + 1)\r\n                    };\r\n                }\r\n            }\r\n            throw new Error('Base64 value \"' + inString + '\" finished with a continuation bit');\r\n        }\r\n        return Base64VLQFormat;\r\n    })();\r\n    TypeScript.Base64VLQFormat = Base64VLQFormat;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var SourceMapping = (function () {\r\n        function SourceMapping(ast) {\r\n            this.parent = -1;\r\n            this.firstChild = -1;\r\n        }\r\n        return SourceMapping;\r\n    })();\r\n    TypeScript.SourceMapping = SourceMapping;    \r\n    var SourceMapper = (function () {\r\n        function SourceMapper(tsFileName, jsFileName, jsFile, sourceMapOut) {\r\n            this.jsFile = jsFile;\r\n            this.sourceMapOut = sourceMapOut;\r\n            this.sourceMappings = new Array();\r\n            this.currentMapping = -1;\r\n            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);\r\n            this.tsFileName = TypeScript.getPrettyName(tsFileName, false, true);\r\n        }\r\n        SourceMapper.MapFileExtension = \".map\";\r\n        SourceMapper.CanEmitMapping = function CanEmitMapping(sourceMappings, currentMapping) {\r\n            if(currentMapping.firstChild !== -1) {\r\n                var childMapping = sourceMappings[currentMapping.firstChild];\r\n                if(childMapping.emittedStartLine === currentMapping.emittedStartLine && childMapping.emittedStartColumn === currentMapping.emittedStartColumn) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        SourceMapper.EmitSourceMapping = function EmitSourceMapping(allSourceMappers) {\r\n            var sourceMapper = allSourceMappers[0];\r\n            sourceMapper.jsFile.WriteLine(\"//@ sourceMappingURL=\" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);\r\n            var sourceMapOut = sourceMapper.sourceMapOut;\r\n            var mappingsString = \"\";\r\n            var tsFiles = [];\r\n            var prevEmittedColumn = 0;\r\n            var prevEmittedLine = 0;\r\n            var prevSourceColumn = 0;\r\n            var prevSourceLine = 0;\r\n            var prevSourceIndex = 0;\r\n            var emitComma = false;\r\n            for(var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {\r\n                sourceMapper = allSourceMappers[sourceMapperIndex];\r\n                if(sourceMapper.sourceMappings) {\r\n                    var currentSourceIndex = tsFiles.length;\r\n                    tsFiles.push(sourceMapper.tsFileName);\r\n                    var sourceMappings = sourceMapper.sourceMappings;\r\n                    for(var i = 0, len = sourceMappings.length; i < len; i++) {\r\n                        var sourceMapping = sourceMappings[i];\r\n                        if(!SourceMapper.CanEmitMapping(sourceMappings, sourceMapping)) {\r\n                            continue;\r\n                        }\r\n                        if(prevEmittedLine !== sourceMapping.emittedStartLine) {\r\n                            while(prevEmittedLine < sourceMapping.emittedStartLine) {\r\n                                prevEmittedColumn = 0;\r\n                                mappingsString = mappingsString + \";\";\r\n                                prevEmittedLine++;\r\n                            }\r\n                            emitComma = false;\r\n                        } else {\r\n                            if(emitComma) {\r\n                                mappingsString = mappingsString + \",\";\r\n                            }\r\n                        }\r\n                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(sourceMapping.emittedStartColumn - prevEmittedColumn);\r\n                        prevEmittedColumn = sourceMapping.emittedStartColumn;\r\n                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);\r\n                        prevSourceIndex = currentSourceIndex;\r\n                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(sourceMapping.sourceStartLine - 1 - prevSourceLine);\r\n                        prevSourceLine = sourceMapping.sourceStartLine - 1;\r\n                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(sourceMapping.sourceStartColumn - prevSourceColumn);\r\n                        prevSourceColumn = sourceMapping.sourceStartColumn;\r\n                        emitComma = true;\r\n                    }\r\n                }\r\n            }\r\n            if(mappingsString != \"\") {\r\n                sourceMapOut.Write('{');\r\n                sourceMapOut.Write('\"version\":3,');\r\n                sourceMapOut.Write('\"file\":\"' + sourceMapper.jsFileName + '\",');\r\n                sourceMapOut.Write('\"sources\":[\"' + tsFiles.join('\",\"') + '\"],');\r\n                sourceMapOut.Write('\"names\":[],');\r\n                sourceMapOut.Write('\"mappings\":\"' + mappingsString);\r\n                sourceMapOut.Write('\"');\r\n                sourceMapOut.Write('}');\r\n            }\r\n            sourceMapOut.Close();\r\n        }\r\n        return SourceMapper;\r\n    })();\r\n    TypeScript.SourceMapper = SourceMapper;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (EmitContainer) {\r\n        EmitContainer._map = [];\r\n        EmitContainer._map[0] = \"Prog\";\r\n        EmitContainer.Prog = 0;\r\n        EmitContainer._map[1] = \"Module\";\r\n        EmitContainer.Module = 1;\r\n        EmitContainer._map[2] = \"DynamicModule\";\r\n        EmitContainer.DynamicModule = 2;\r\n        EmitContainer._map[3] = \"Class\";\r\n        EmitContainer.Class = 3;\r\n        EmitContainer._map[4] = \"Constructor\";\r\n        EmitContainer.Constructor = 4;\r\n        EmitContainer._map[5] = \"Function\";\r\n        EmitContainer.Function = 5;\r\n        EmitContainer._map[6] = \"Args\";\r\n        EmitContainer.Args = 6;\r\n        EmitContainer._map[7] = \"Interface\";\r\n        EmitContainer.Interface = 7;\r\n    })(TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));\r\n    var EmitContainer = TypeScript.EmitContainer;\r\n\r\n    var EmitState = (function () {\r\n        function EmitState() {\r\n            this.indentAmt = 0;\r\n            this.column = 0;\r\n            this.line = 0;\r\n            this.pretty = false;\r\n            this.inObjectLiteral = false;\r\n            this.container = EmitContainer.Prog;\r\n        }\r\n        return EmitState;\r\n    })();\r\n    TypeScript.EmitState = EmitState;    \r\n    var Emitter = (function () {\r\n        function Emitter(checker, outfile, emitOptions) {\r\n            this.checker = checker;\r\n            this.outfile = outfile;\r\n            this.emitOptions = emitOptions;\r\n            this.prologueEmitted = false;\r\n            this.indentStep = 4;\r\n            this.thisClassNode = null;\r\n            this.thisFnc = null;\r\n            this.moduleDeclList = [];\r\n            this.moduleName = \"\";\r\n            this.emitState = new EmitState();\r\n            this.indentStrings = [];\r\n            this.ambientModule = false;\r\n            this.modAliasId = null;\r\n            this.firstModAlias = null;\r\n            this.allSourceMappers = [];\r\n            this.sourceMapper = null;\r\n            this.declDottedModuleName = false;\r\n            this.declIndentDelta = 0;\r\n            this.declFile = null;\r\n            this.declContainingAST = null;\r\n        }\r\n        Emitter.prototype.canWriteDeclFile = function () {\r\n            return this.declFile != null;\r\n        };\r\n        Emitter.prototype.setSourceMappings = function (mapper) {\r\n            this.allSourceMappers.push(mapper);\r\n            this.sourceMapper = mapper;\r\n        };\r\n        Emitter.prototype.setDeclarationFile = function (declaresFile) {\r\n            this.declFile = declaresFile;\r\n        };\r\n        Emitter.prototype.increaseIndent = function () {\r\n            this.emitState.indentAmt += this.indentStep;\r\n            if(this.declDottedModuleName) {\r\n                this.addDeclIndentDelta();\r\n            }\r\n        };\r\n        Emitter.prototype.decreaseIndent = function () {\r\n            this.emitState.indentAmt -= this.indentStep;\r\n        };\r\n        Emitter.prototype.addDeclIndentDelta = function () {\r\n            this.declIndentDelta += this.indentStep;\r\n        };\r\n        Emitter.prototype.reduceDeclIndentDelta = function () {\r\n            this.declIndentDelta -= this.indentStep;\r\n        };\r\n        Emitter.prototype.writeToOutput = function (s) {\r\n            this.outfile.Write(s);\r\n            this.emitState.column += s.length;\r\n        };\r\n        Emitter.prototype.writeToOutputTrimmable = function (s) {\r\n            if(this.emitOptions.minWhitespace) {\r\n                s = s.replace(/[\\s]*/g, '');\r\n            }\r\n            this.writeToOutput(s);\r\n        };\r\n        Emitter.prototype.writeLineToOutput = function (s) {\r\n            if(this.emitOptions.minWhitespace) {\r\n                this.writeToOutput(s);\r\n                var c = s.charCodeAt(s.length - 1);\r\n                if(!((c == TypeScript.LexCodeSpace) || (c == TypeScript.LexCodeSMC) || (c == TypeScript.LexCodeLBR))) {\r\n                    this.writeToOutput(' ');\r\n                }\r\n            } else {\r\n                this.outfile.WriteLine(s);\r\n                this.emitState.column = 0;\r\n                this.emitState.line++;\r\n            }\r\n        };\r\n        Emitter.prototype.setInObjectLiteral = function (val) {\r\n            var temp = this.emitState.inObjectLiteral;\r\n            this.emitState.inObjectLiteral = val;\r\n            return temp;\r\n        };\r\n        Emitter.prototype.setContainer = function (c) {\r\n            var temp = this.emitState.container;\r\n            this.emitState.container = c;\r\n            return temp;\r\n        };\r\n        Emitter.prototype.setDeclContainingAST = function (ast) {\r\n            var temp = this.declContainingAST;\r\n            this.declContainingAST = ast;\r\n            return temp;\r\n        };\r\n        Emitter.prototype.getIndentString = function (declIndent) {\r\n            if (typeof declIndent === \"undefined\") { declIndent = false; }\r\n            if(this.emitOptions.minWhitespace) {\r\n                return \"\";\r\n            } else {\r\n                var indentAmt = this.emitState.indentAmt - (declIndent ? this.declIndentDelta : 0);\r\n                var indentString = this.indentStrings[indentAmt];\r\n                if(indentString === undefined) {\r\n                    indentString = \"\";\r\n                    for(var i = 0; i < indentAmt; i++) {\r\n                        indentString += \" \";\r\n                    }\r\n                    this.indentStrings[indentAmt] = indentString;\r\n                }\r\n                return indentString;\r\n            }\r\n        };\r\n        Emitter.prototype.emitIndent = function () {\r\n            this.writeToOutput(this.getIndentString());\r\n        };\r\n        Emitter.prototype.emitIndentToDeclFile = function () {\r\n            this.declFile.Write(this.getIndentString(true));\r\n        };\r\n        Emitter.prototype.emitCommentInPlace = function (comment) {\r\n            this.recordSourceMappingStart(comment);\r\n            var text = comment.getText();\r\n            var hadNewLine = false;\r\n            if(comment.isBlockComment) {\r\n                if(this.emitState.column == 0) {\r\n                    this.emitIndent();\r\n                }\r\n                this.writeToOutput(text[0]);\r\n                if(text.length > 1 || comment.endsLine) {\r\n                    this.writeLineToOutput(\"\");\r\n                    for(var i = 1; i < text.length; i++) {\r\n                        this.emitIndent();\r\n                        this.writeLineToOutput(text[i]);\r\n                    }\r\n                    hadNewLine = true;\r\n                }\r\n            } else {\r\n                if(this.emitState.column == 0) {\r\n                    this.emitIndent();\r\n                }\r\n                this.writeLineToOutput(text[0]);\r\n                hadNewLine = true;\r\n            }\r\n            if(hadNewLine) {\r\n                this.emitIndent();\r\n            } else {\r\n                this.writeToOutput(\" \");\r\n            }\r\n            this.recordSourceMappingEnd(comment);\r\n        };\r\n        Emitter.prototype.emitParensAndCommentsInPlace = function (ast, pre) {\r\n            var comments = pre ? ast.preComments : ast.postComments;\r\n            if(ast.isParenthesized && !pre) {\r\n                this.writeToOutput(\")\");\r\n            }\r\n            if(this.emitOptions.emitComments && comments && comments.length != 0) {\r\n                for(var i = 0; i < comments.length; i++) {\r\n                    this.emitCommentInPlace(comments[i]);\r\n                }\r\n            }\r\n            if(ast.isParenthesized && pre) {\r\n                this.writeToOutput(\"(\");\r\n            }\r\n        };\r\n        Emitter.prototype.emitObjectLiteral = function (content) {\r\n            this.writeLineToOutput(\"{\");\r\n            this.increaseIndent();\r\n            var inObjectLiteral = this.setInObjectLiteral(true);\r\n            this.emitJavascriptList(content, \",\", TypeScript.TokenID.Comma, true, false, false);\r\n            this.setInObjectLiteral(inObjectLiteral);\r\n            this.decreaseIndent();\r\n            this.emitIndent();\r\n            this.writeToOutput(\"}\");\r\n        };\r\n        Emitter.prototype.emitArrayLiteral = function (content) {\r\n            this.writeToOutput(\"[\");\r\n            if(content) {\r\n                this.writeLineToOutput(\"\");\r\n                this.increaseIndent();\r\n                this.emitJavascriptList(content, \", \", TypeScript.TokenID.Comma, true, false, false);\r\n                this.decreaseIndent();\r\n                this.emitIndent();\r\n            }\r\n            this.writeToOutput(\"]\");\r\n        };\r\n        Emitter.prototype.emitNew = function (target, args) {\r\n            this.recordSourceMappingStart(target);\r\n            this.writeToOutput(\"new \");\r\n            if(target.nodeType == TypeScript.NodeType.TypeRef) {\r\n                this.writeToOutput(\"Array()\");\r\n            } else {\r\n                this.emitJavascript(target, TypeScript.TokenID.Tilde, false);\r\n                this.writeToOutput(\"(\");\r\n                this.emitJavascriptList(args, \", \", TypeScript.TokenID.Comma, false, false, false);\r\n                this.writeToOutput(\")\");\r\n            }\r\n            this.recordSourceMappingEnd(target);\r\n        };\r\n        Emitter.prototype.tryEmitConstant = function (dotExpr) {\r\n            if(!this.emitOptions.propagateConstants) {\r\n                return false;\r\n            }\r\n            var propertyName = dotExpr.operand2;\r\n            if(propertyName && propertyName.sym && propertyName.sym.isVariable()) {\r\n                if(TypeScript.hasFlag(propertyName.sym.flags, TypeScript.SymbolFlags.Constant)) {\r\n                    if(propertyName.sym.declAST) {\r\n                        var boundDecl = propertyName.sym.declAST;\r\n                        if(boundDecl.init && (boundDecl.init.nodeType == TypeScript.NodeType.NumberLit)) {\r\n                            var numLit = boundDecl.init;\r\n                            this.writeToOutput(numLit.value.toString());\r\n                            var comment = \" /* \";\r\n                            comment += propertyName.text;\r\n                            comment += \" */ \";\r\n                            this.writeToOutput(comment);\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        Emitter.prototype.emitCall = function (callNode, target, args) {\r\n            if(!this.emitSuperCall(callNode)) {\r\n                if(!TypeScript.hasFlag(callNode.flags, TypeScript.ASTFlags.ClassBaseConstructorCall)) {\r\n                    if(target.nodeType == TypeScript.NodeType.FuncDecl && !target.isParenthesized) {\r\n                        this.writeToOutput(\"(\");\r\n                    }\r\n                    this.emitJavascript(target, TypeScript.TokenID.LParen, false);\r\n                    if(target.nodeType == TypeScript.NodeType.FuncDecl && !target.isParenthesized) {\r\n                        this.writeToOutput(\")\");\r\n                    }\r\n                    this.writeToOutput(\"(\");\r\n                    this.emitJavascriptList(args, \", \", TypeScript.TokenID.Comma, false, false, false);\r\n                    this.writeToOutput(\")\");\r\n                } else {\r\n                    this.decreaseIndent();\r\n                    this.decreaseIndent();\r\n                    var constructorCall = new TypeScript.ASTList();\r\n                    constructorCall.members[0] = callNode;\r\n                    this.emitConstructorCalls(constructorCall, this.thisClassNode);\r\n                    this.increaseIndent();\r\n                    this.increaseIndent();\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.defaultValue = function (type) {\r\n            if(type == this.checker.anyType) {\r\n                return \"undefined\";\r\n            } else {\r\n                if(type == this.checker.numberType) {\r\n                    return \"0\";\r\n                } else {\r\n                    if(type == this.checker.stringType) {\r\n                        return '\"\"';\r\n                    } else {\r\n                        if(type == this.checker.booleanType) {\r\n                            return \"false\";\r\n                        } else {\r\n                            return \"null\";\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitConstructorCalls = function (bases, classDecl) {\r\n            if(bases == null) {\r\n                return;\r\n            }\r\n            var basesLen = bases.members.length;\r\n            this.recordSourceMappingStart(classDecl);\r\n            for(var i = 0; i < basesLen; i++) {\r\n                var baseExpr = bases.members[i];\r\n                var baseSymbol = null;\r\n                if(baseExpr.nodeType == TypeScript.NodeType.Call) {\r\n                    baseSymbol = (baseExpr).target.type.symbol;\r\n                } else {\r\n                    baseSymbol = baseExpr.type.symbol;\r\n                }\r\n                var baseName = baseSymbol.name;\r\n                if(baseSymbol.declModule != classDecl.type.symbol.declModule) {\r\n                    baseName = baseSymbol.fullName();\r\n                }\r\n                if(baseExpr.nodeType == TypeScript.NodeType.Call) {\r\n                    this.emitIndent();\r\n                    this.writeToOutput(\"_super.call(this\");\r\n                    var args = (baseExpr).args;\r\n                    if(args && (args.members.length > 0)) {\r\n                        this.writeToOutput(\", \");\r\n                        this.emitJavascriptList(args, \", \", TypeScript.TokenID.Comma, false, false, false);\r\n                    }\r\n                    this.writeToOutput(\")\");\r\n                } else {\r\n                    if(baseExpr.type && (baseExpr.type.isClassInstance())) {\r\n                        this.emitIndent();\r\n                        this.writeToOutput(classDecl.name.text + \"._super.constructor\");\r\n                        this.writeToOutput(\".call(this)\");\r\n                    }\r\n                }\r\n            }\r\n            this.recordSourceMappingEnd(classDecl);\r\n        };\r\n        Emitter.prototype.emitInnerFunction = function (funcDecl, printName, isProtoMember, bases, hasSelfRef, classDecl, writeDeclFile, enclosingEmitStateContainer) {\r\n            if (typeof writeDeclFile === \"undefined\") { writeDeclFile = false; }\r\n            if (typeof enclosingEmitStateContainer === \"undefined\") { enclosingEmitStateContainer = this.emitState.container; }\r\n            var isClassConstructor = funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod);\r\n            var hasNonObjectBaseType = isClassConstructor && TypeScript.hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeScript.TypeFlags.HasBaseType) && !TypeScript.hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeScript.TypeFlags.HasBaseTypeOfObject);\r\n            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && TypeScript.hasFlag((this.thisClassNode).varFlags, TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor);\r\n            this.emitParensAndCommentsInPlace(funcDecl, true);\r\n            this.recordSourceMappingStart(funcDecl);\r\n            if(!(funcDecl.isAccessor() && (funcDecl.accessorSymbol).isObjectLitField)) {\r\n                this.writeToOutput(\"function \");\r\n            }\r\n            if(printName) {\r\n                var id = funcDecl.getNameText();\r\n                if(id && !funcDecl.isAccessor()) {\r\n                    this.writeToOutput(id);\r\n                }\r\n            }\r\n            this.writeToOutput(\"(\");\r\n            if(writeDeclFile) {\r\n                writeDeclFile = this.emitFuncSignatureIdentifier(funcDecl, false, enclosingEmitStateContainer);\r\n            }\r\n            var argsLen = 0;\r\n            var i = 0;\r\n            var arg;\r\n            var defaultArgs = [];\r\n            if(funcDecl.args) {\r\n                var tempContainer = this.setContainer(EmitContainer.Args);\r\n                argsLen = funcDecl.args.members.length;\r\n                var printLen = argsLen;\r\n                if(funcDecl.variableArgList) {\r\n                    printLen--;\r\n                }\r\n                for(i = 0; i < printLen; i++) {\r\n                    arg = funcDecl.args.members[i];\r\n                    if(arg.init) {\r\n                        defaultArgs.push(arg);\r\n                    }\r\n                    this.emitJavascript(arg, TypeScript.TokenID.LParen, false, writeDeclFile);\r\n                    if(i < (printLen - 1)) {\r\n                        this.writeToOutput(\", \");\r\n                        if(writeDeclFile) {\r\n                            this.declFile.Write(\", \");\r\n                        }\r\n                    }\r\n                }\r\n                this.setContainer(tempContainer);\r\n            }\r\n            this.writeLineToOutput(\") {\");\r\n            var oldDeclContainingAST = null;\r\n            if(writeDeclFile) {\r\n                this.emitFuncSignatureVariableArg(funcDecl);\r\n                if(funcDecl.hasStaticDeclarations()) {\r\n                    oldDeclContainingAST = this.setDeclContainingAST(funcDecl);\r\n                }\r\n            }\r\n            this.increaseIndent();\r\n            for(i = 0; i < defaultArgs.length; i++) {\r\n                var arg = defaultArgs[i];\r\n                this.emitIndent();\r\n                this.recordSourceMappingStart(arg);\r\n                this.writeToOutput(\"if (typeof \" + arg.id.text + \" === \\\"undefined\\\") { \");\r\n                this.recordSourceMappingStart(arg.id);\r\n                this.writeToOutput(arg.id.text);\r\n                this.recordSourceMappingEnd(arg.id);\r\n                this.writeToOutput(\" = \");\r\n                this.emitJavascript(arg.init, TypeScript.TokenID.LParen, false);\r\n                this.writeLineToOutput(\"; }\");\r\n                this.recordSourceMappingEnd(arg);\r\n            }\r\n            if(funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {\r\n                if(funcDecl.args) {\r\n                    argsLen = funcDecl.args.members.length;\r\n                    for(i = 0; i < argsLen; i++) {\r\n                        arg = funcDecl.args.members[i];\r\n                        if((arg.varFlags & TypeScript.VarFlags.Property) != TypeScript.VarFlags.None) {\r\n                            this.emitIndent();\r\n                            this.recordSourceMappingStart(arg);\r\n                            this.recordSourceMappingStart(arg.id);\r\n                            this.writeToOutput(\"this.\" + arg.id.text);\r\n                            this.recordSourceMappingEnd(arg.id);\r\n                            this.writeToOutput(\" = \");\r\n                            this.recordSourceMappingStart(arg.id);\r\n                            this.writeToOutput(arg.id.text);\r\n                            this.recordSourceMappingEnd(arg.id);\r\n                            this.writeLineToOutput(\";\");\r\n                            this.recordSourceMappingEnd(arg);\r\n                        }\r\n                    }\r\n                }\r\n                if(!TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) {\r\n                    this.emitConstructorCalls(bases, classDecl);\r\n                }\r\n            }\r\n            if(hasSelfRef) {\r\n                this.emitIndent();\r\n                this.writeLineToOutput(\"var _this = this;\");\r\n            }\r\n            if(funcDecl.variableArgList) {\r\n                argsLen = funcDecl.args.members.length;\r\n                var lastArg = funcDecl.args.members[argsLen - 1];\r\n                this.emitIndent();\r\n                this.recordSourceMappingStart(lastArg);\r\n                this.writeToOutput(\"var \");\r\n                this.recordSourceMappingStart(lastArg.id);\r\n                this.writeToOutput(lastArg.id.text);\r\n                this.recordSourceMappingEnd(lastArg.id);\r\n                this.writeLineToOutput(\" = [];\");\r\n                this.recordSourceMappingEnd(lastArg);\r\n                this.emitIndent();\r\n                this.writeLineToOutput(\"for (var _i = 0; _i < (arguments.length - \" + (argsLen - 1) + \"); _i++) {\");\r\n                this.increaseIndent();\r\n                this.emitIndent();\r\n                this.writeLineToOutput(lastArg.id.text + \"[_i] = arguments[_i + \" + (argsLen - 1) + \"];\");\r\n                this.decreaseIndent();\r\n                this.emitIndent();\r\n                this.writeLineToOutput(\"}\");\r\n            }\r\n            if(funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {\r\n                var nProps = (this.thisClassNode.members).members.length;\r\n                for(var i = 0; i < nProps; i++) {\r\n                    if((this.thisClassNode.members).members[i].nodeType == TypeScript.NodeType.VarDecl) {\r\n                        var varDecl = (this.thisClassNode.members).members[i];\r\n                        if(!TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Static) && varDecl.init) {\r\n                            this.emitIndent();\r\n                            this.emitJavascriptVarDecl(varDecl, TypeScript.TokenID.Tilde);\r\n                            this.writeLineToOutput(\"\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);\r\n            this.decreaseIndent();\r\n            this.emitIndent();\r\n            this.writeToOutput(\"}\");\r\n            if(!isProtoMember && !TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.IsFunctionExpression) && (TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Definition) || funcDecl.isConstructor)) {\r\n                this.writeLineToOutput(\"\");\r\n            }\r\n            if(funcDecl.hasStaticDeclarations()) {\r\n                this.writeLineToOutput(\"\");\r\n                this.emitIndent();\r\n                var funcName = funcDecl.getNameText();\r\n                this.writeLineToOutput(\"(function (\" + funcName + \") {\");\r\n                this.increaseIndent();\r\n                var len = 0;\r\n                var i = 0;\r\n                len = funcDecl.innerStaticFuncs.length;\r\n                for(i = 0; i < len; i++) {\r\n                    var innerFunc = funcDecl.innerStaticFuncs[i];\r\n                    if(innerFunc.isOverload) {\r\n                        if(writeDeclFile) {\r\n                            this.emitFuncSignature(innerFunc);\r\n                        }\r\n                        continue;\r\n                    }\r\n                    this.emitIndent();\r\n                    if(innerFunc.isAccessor()) {\r\n                        this.emitPropertyAccessor(innerFunc, funcDecl.name.text, false, writeDeclFile);\r\n                    } else {\r\n                        this.writeToOutput(funcName + \".\" + innerFunc.name.text + \" = \");\r\n                        this.emitInnerFunction(innerFunc, (innerFunc.name && !innerFunc.name.isMissing()), false, null, innerFunc.hasSelfReference(), null, writeDeclFile);\r\n                    }\r\n                }\r\n                if(funcDecl.statics) {\r\n                    this.recordSourceMappingStart(funcDecl.statics);\r\n                    len = funcDecl.statics.members.length;\r\n                    for(i = 0; i < len; i++) {\r\n                        this.emitIndent();\r\n                        this.writeToOutput(funcName);\r\n                        this.emitJavascript(funcDecl.statics.members[i], TypeScript.TokenID.Tilde, false, writeDeclFile);\r\n                        this.writeLineToOutput(\"\");\r\n                    }\r\n                    this.recordSourceMappingEnd(funcDecl.statics);\r\n                }\r\n                this.decreaseIndent();\r\n                this.emitIndent();\r\n                var printProto = isProtoMember && this.thisClassNode;\r\n                var prefix = printProto ? this.thisClassNode.name.text + \".prototype.\" : \"\";\r\n                this.writeLineToOutput(\"})(\" + prefix + funcName + \");\");\r\n                if(writeDeclFile) {\r\n                    this.setDeclContainingAST(oldDeclContainingAST);\r\n                    this.emitIndentToDeclFile();\r\n                    this.declFile.WriteLine(\"}\");\r\n                }\r\n            }\r\n            this.recordSourceMappingEnd(funcDecl);\r\n            this.emitParensAndCommentsInPlace(funcDecl, false);\r\n        };\r\n        Emitter.prototype.emitArgDecl = function (argDecl) {\r\n            this.declFile.Write(argDecl.id.text);\r\n            if(argDecl.isOptionalArg()) {\r\n                this.declFile.Write(\"?\");\r\n            }\r\n            if((argDecl.typeExpr || argDecl.type != this.checker.anyType) && this.canEmitTypeAnnotationSignature(argDecl.type)) {\r\n                this.declFile.Write(\": \" + this.getTypeSignature(argDecl.type));\r\n            }\r\n        };\r\n        Emitter.prototype.emitFuncSignatureIdentifier = function (funcDecl, isInterfaceMember, enclosingEmitStateContainer) {\r\n            if (typeof isInterfaceMember === \"undefined\") { isInterfaceMember = false; }\r\n            if (typeof enclosingEmitStateContainer === \"undefined\") { enclosingEmitStateContainer = this.emitState.container; }\r\n            if(!isInterfaceMember && !funcDecl.isOverload) {\r\n                if(funcDecl.isConstructor) {\r\n                    if(funcDecl.type.construct.signatures.length > 1) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if(funcDecl.type.call.signatures.length > 1) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            if(!this.canEmitSignature(TypeScript.ToDeclFlags(funcDecl.fncFlags), enclosingEmitStateContainer)) {\r\n                return false;\r\n            }\r\n            if(funcDecl.isConstructor) {\r\n                this.emitIndentToDeclFile();\r\n                this.declFile.Write(\"constructor \");\r\n            } else {\r\n                var id = funcDecl.getNameText();\r\n                if(!isInterfaceMember) {\r\n                    this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.fncFlags), \"function\");\r\n                    this.declFile.Write(id);\r\n                } else {\r\n                    this.emitIndentToDeclFile();\r\n                    if(funcDecl.isConstructMember()) {\r\n                        this.declFile.Write(\"new\");\r\n                    } else {\r\n                        if(!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {\r\n                            this.declFile.Write(id);\r\n                            if(TypeScript.hasFlag(funcDecl.name.flags, TypeScript.ASTFlags.OptionalName)) {\r\n                                this.declFile.Write(\"? \");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(!funcDecl.isIndexerMember()) {\r\n                this.declFile.Write(\"(\");\r\n            } else {\r\n                this.declFile.Write(\"[\");\r\n            }\r\n            return true;\r\n        };\r\n        Emitter.prototype.emitFuncSignatureVariableArg = function (funcDecl) {\r\n            if(funcDecl.variableArgList) {\r\n                var lastArg = funcDecl.args.members[funcDecl.args.members.length - 1];\r\n                if(funcDecl.args.members.length > 1) {\r\n                    this.declFile.Write(\", ...\");\r\n                } else {\r\n                    this.declFile.Write(\"...\");\r\n                }\r\n                this.emitArgDecl(lastArg);\r\n            }\r\n            if(!funcDecl.isIndexerMember()) {\r\n                this.declFile.Write(\")\");\r\n            } else {\r\n                this.declFile.Write(\"]\");\r\n            }\r\n            if(!funcDecl.isConstructor && (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) && this.canEmitTypeAnnotationSignature(funcDecl.signature.returnType.type)) {\r\n                this.declFile.Write(\": \" + this.getTypeSignature(funcDecl.signature.returnType.type));\r\n            }\r\n            if(funcDecl.hasStaticDeclarations()) {\r\n                this.declFile.WriteLine(\" {\");\r\n            } else {\r\n                this.declFile.WriteLine(\";\");\r\n            }\r\n        };\r\n        Emitter.prototype.emitFuncSignature = function (funcDecl, isInterfaceMember) {\r\n            if (typeof isInterfaceMember === \"undefined\") { isInterfaceMember = false; }\r\n            var emitSignature = this.emitFuncSignatureIdentifier(funcDecl, isInterfaceMember);\r\n            if(emitSignature) {\r\n                if(funcDecl.args) {\r\n                    var argsLen = funcDecl.args.members.length;\r\n                    if(funcDecl.variableArgList) {\r\n                        argsLen--;\r\n                    }\r\n                    for(var i = 0; i < argsLen; i++) {\r\n                        var argDecl = funcDecl.args.members[i];\r\n                        this.emitArgDecl(argDecl);\r\n                        if(i < (argsLen - 1)) {\r\n                            this.declFile.Write(\", \");\r\n                        }\r\n                    }\r\n                }\r\n                this.emitFuncSignatureVariableArg(funcDecl);\r\n            }\r\n        };\r\n        Emitter.prototype.emitPropertyAccessorSignature = function (funcDecl) {\r\n            var accessorSymbol = funcDecl.accessorSymbol;\r\n            this.emitDeclFlags(TypeScript.ToDeclFlags(accessorSymbol.flags), \"var\");\r\n            this.declFile.WriteLine(funcDecl.name.text + \" : \" + this.getTypeSignature(accessorSymbol.getType()) + \";\");\r\n        };\r\n        Emitter.prototype.emitDeclFlags = function (declFlags, typeString) {\r\n            this.emitIndentToDeclFile();\r\n            var accessorString = \"\";\r\n            if(TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.GetAccessor)) {\r\n                accessorString = \"get \";\r\n            } else {\r\n                if(TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.SetAccessor)) {\r\n                    accessorString = \"set \";\r\n                }\r\n            }\r\n            if(TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Exported)) {\r\n                this.declFile.Write(\"export \");\r\n            }\r\n            if(TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.LocalStatic) || TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Static)) {\r\n                this.declFile.Write(\"static \" + accessorString);\r\n            } else {\r\n                if(TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Private)) {\r\n                    this.declFile.Write(\"private \" + accessorString);\r\n                } else {\r\n                    if(TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Public)) {\r\n                        this.declFile.Write(\"public \" + accessorString);\r\n                    } else {\r\n                        if(accessorString == \"\") {\r\n                            this.declFile.Write(typeString + \" \");\r\n                        } else {\r\n                            this.declFile.Write(accessorString);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.canEmitTypeAnnotationSignature = function (type, declFlag) {\r\n            if (typeof declFlag === \"undefined\") { declFlag = TypeScript.DeclFlags.None; }\r\n            if(type == null) {\r\n                return false;\r\n            }\r\n            if(type.primitiveTypeClass == TypeScript.Primitive.None && (type.symbol && type.symbol.container != undefined && type.symbol.container != this.checker.gloMod)) {\r\n                if(TypeScript.hasFlag(declFlag, TypeScript.DeclFlags.Private)) {\r\n                    return false;\r\n                }\r\n                if(TypeScript.hasFlag(type.symbol.container.flags, TypeScript.SymbolFlags.Exported)) {\r\n                    return true;\r\n                }\r\n                if(type.symbol.declAST) {\r\n                    switch(type.symbol.declAST.nodeType) {\r\n                        case TypeScript.NodeType.Module: {\r\n                            if(!TypeScript.hasFlag((type.symbol.declAST).modFlags, TypeScript.ModuleFlags.Exported)) {\r\n                                return false;\r\n                            }\r\n                            break;\r\n\r\n                        }\r\n                        case TypeScript.NodeType.Class: {\r\n                            if(!TypeScript.hasFlag((type.symbol.declAST).varFlags, TypeScript.VarFlags.Exported)) {\r\n                                return false;\r\n                            }\r\n                            break;\r\n\r\n                        }\r\n                        case TypeScript.NodeType.Interface: {\r\n                            if(!TypeScript.hasFlag((type.symbol.declAST).varFlags, TypeScript.VarFlags.Exported)) {\r\n                                return false;\r\n                            }\r\n                            break;\r\n\r\n                        }\r\n                        case TypeScript.NodeType.FuncDecl: {\r\n                            if(!TypeScript.hasFlag((type.symbol.declAST).fncFlags, TypeScript.FncFlags.Exported)) {\r\n                                return false;\r\n                            }\r\n                            break;\r\n\r\n                        }\r\n                        default: {\r\n                            throw Error(\"Catch this unhandled type container\");\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        Emitter.prototype.getTypeSignature = function (type) {\r\n            var containingScope = null;\r\n            if(this.declContainingAST) {\r\n                switch(this.declContainingAST.nodeType) {\r\n                    case TypeScript.NodeType.Module:\r\n                    case TypeScript.NodeType.Interface:\r\n                    case TypeScript.NodeType.FuncDecl: {\r\n                        if(this.declContainingAST.type) {\r\n                            containingScope = this.declContainingAST.type.containedScope;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Script: {\r\n                        var script = this.declContainingAST;\r\n                        if(script.bod) {\r\n                            containingScope = script.bod.enclosingScope;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Class: {\r\n                        if(this.declContainingAST.type) {\r\n                            containingScope = this.declContainingAST.type.instanceType.containedScope;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        throw Error(\"Unknown containing scope\");\r\n\r\n                    }\r\n                }\r\n            }\r\n            return type.getScopedTypeName(containingScope);\r\n        };\r\n        Emitter.prototype.canEmitSignature = function (declFlags, enclosingEmitStateContainer) {\r\n            if (typeof enclosingEmitStateContainer === \"undefined\") { enclosingEmitStateContainer = this.emitState.container; }\r\n            if(enclosingEmitStateContainer == EmitContainer.Module && !TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Exported)) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        Emitter.prototype.emitVarSignature = function (varDecl, interfaceMember) {\r\n            if (typeof interfaceMember === \"undefined\") { interfaceMember = false; }\r\n            if(this.canEmitSignature(TypeScript.ToDeclFlags(varDecl.varFlags))) {\r\n                if(!interfaceMember) {\r\n                    this.emitDeclFlags(TypeScript.ToDeclFlags(varDecl.varFlags), \"var\");\r\n                    this.declFile.Write(varDecl.id.text);\r\n                } else {\r\n                    this.emitIndentToDeclFile();\r\n                    this.declFile.Write(varDecl.id.text);\r\n                    if(TypeScript.hasFlag(varDecl.id.flags, TypeScript.ASTFlags.OptionalName)) {\r\n                        this.declFile.Write(\"?\");\r\n                    }\r\n                }\r\n                var type = null;\r\n                if(varDecl.typeExpr && varDecl.typeExpr.type) {\r\n                    type = varDecl.typeExpr.type;\r\n                } else {\r\n                    if(varDecl.sym) {\r\n                        type = (varDecl.sym).getType();\r\n                        if(type == this.checker.anyType) {\r\n                            type = null;\r\n                        }\r\n                    }\r\n                }\r\n                if(this.canEmitTypeAnnotationSignature(type, TypeScript.ToDeclFlags(varDecl.varFlags))) {\r\n                    var typeName = this.getTypeSignature(type);\r\n                    this.declFile.WriteLine(\": \" + typeName + \";\");\r\n                } else {\r\n                    this.declFile.WriteLine(\";\");\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitBaseList = function (bases, qual) {\r\n            if(bases && (bases.members.length > 0)) {\r\n                this.declFile.Write(\" \" + qual + \" \");\r\n                var basesLen = bases.members.length;\r\n                for(var i = 0; i < basesLen; i++) {\r\n                    var baseExpr = bases.members[i];\r\n                    var baseSymbol = baseExpr.type.symbol;\r\n                    var baseType = baseExpr.type;\r\n                    var baseName = this.getTypeSignature(baseType);\r\n                    if(i > 0) {\r\n                        this.declFile.Write(\", \");\r\n                    }\r\n                    this.declFile.Write(baseName);\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitClassSignatureIdentifierAndHeritage = function (classDecl) {\r\n            if(!this.canEmitSignature(TypeScript.ToDeclFlags(classDecl.varFlags))) {\r\n                return false;\r\n            }\r\n            var className = classDecl.name.text;\r\n            this.emitDeclFlags(TypeScript.ToDeclFlags(classDecl.varFlags), \"class\");\r\n            this.declFile.Write(className);\r\n            this.emitBaseList(classDecl.baseClass, \"extends\");\r\n            this.emitBaseList(classDecl.implementsList, \"implements\");\r\n            this.declFile.WriteLine(\" {\");\r\n            return true;\r\n        };\r\n        Emitter.prototype.emitClassSignatureClassBodyOfAmbientClass = function (classDecl) {\r\n            var membersLen = classDecl.definitionMembers.members.length;\r\n            for(var j = 0; j < membersLen; j++) {\r\n                var memberDecl = classDecl.definitionMembers.members[j];\r\n                if(memberDecl.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                    var fn = memberDecl;\r\n                    if(!fn.isAccessor()) {\r\n                        this.emitFuncSignature(fn);\r\n                    }\r\n                } else {\r\n                    if(memberDecl.nodeType == TypeScript.NodeType.VarDecl) {\r\n                        this.emitVarSignature(memberDecl);\r\n                    } else {\r\n                        throw Error(\"We want to catch this\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitMembersFromConstructorDefinition = function (funcDecl) {\r\n            if(funcDecl.args) {\r\n                var argsLen = funcDecl.args.members.length;\r\n                if(funcDecl.variableArgList) {\r\n                    argsLen--;\r\n                }\r\n                for(var i = 0; i < argsLen; i++) {\r\n                    var argDecl = funcDecl.args.members[i];\r\n                    if(TypeScript.hasFlag(argDecl.varFlags, TypeScript.VarFlags.Property)) {\r\n                        this.emitDeclFlags(TypeScript.ToDeclFlags(argDecl.varFlags), \"var\");\r\n                        this.declFile.Write(argDecl.id.text);\r\n                        if(argDecl.typeExpr) {\r\n                            this.declFile.Write(\": \" + this.getTypeSignature(argDecl.type));\r\n                        }\r\n                        this.declFile.WriteLine(\";\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitClassSignature = function (classDecl) {\r\n            var canEmitSignature = this.emitClassSignatureIdentifierAndHeritage(classDecl);\r\n            if(canEmitSignature) {\r\n                var oldDeclContainingAST = this.setDeclContainingAST(classDecl);\r\n                this.increaseIndent();\r\n                this.emitClassSignatureClassBodyOfAmbientClass(classDecl);\r\n                this.decreaseIndent();\r\n                this.setDeclContainingAST(oldDeclContainingAST);\r\n                this.emitIndentToDeclFile();\r\n                this.declFile.WriteLine(\"}\");\r\n            }\r\n        };\r\n        Emitter.prototype.emitImportDecl = function (importDecl) {\r\n            if(this.canEmitSignature(TypeScript.ToDeclFlags(importDecl.varFlags))) {\r\n                this.emitDeclFlags(TypeScript.ToDeclFlags(importDecl.varFlags), \"import\");\r\n                this.declFile.Write(importDecl.id.text + \" = \");\r\n                if(importDecl.isDynamicImport) {\r\n                    this.declFile.WriteLine(\"module (\" + importDecl.getAliasName() + \");\");\r\n                } else {\r\n                    this.declFile.WriteLine(importDecl.getAliasName() + \";\");\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitModuleIdentification = function (moduleDecl) {\r\n            if(!this.canEmitSignature(TypeScript.ToDeclFlags(moduleDecl.modFlags))) {\r\n                return false;\r\n            }\r\n            if(this.declDottedModuleName) {\r\n                this.declFile.Write(\".\");\r\n            } else {\r\n                this.emitDeclFlags(TypeScript.ToDeclFlags(moduleDecl.modFlags), \"module\");\r\n            }\r\n            this.declFile.Write(moduleDecl.name.text);\r\n            if(moduleDecl.members.members.length == 1 && moduleDecl.members.members[0].nodeType == TypeScript.NodeType.Module && !(moduleDecl.members.members[0]).isEnum() && TypeScript.hasFlag((moduleDecl.members.members[0]).modFlags, TypeScript.ModuleFlags.Exported)) {\r\n                this.declDottedModuleName = true;\r\n            } else {\r\n                this.declDottedModuleName = false;\r\n                this.declFile.WriteLine(\" {\");\r\n            }\r\n            return true;\r\n        };\r\n        Emitter.prototype.emitModuleBodyOfAmbientModule = function (moduleDecl) {\r\n            var membersLen = moduleDecl.members.members.length;\r\n            for(var j = 0; j < membersLen; j++) {\r\n                var memberDecl = moduleDecl.members.members[j];\r\n                switch(memberDecl.nodeType) {\r\n                    case TypeScript.NodeType.VarDecl: {\r\n                        this.emitVarSignature(memberDecl);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.FuncDecl: {\r\n                        this.emitFuncSignature(memberDecl);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Class: {\r\n                        this.emitClassSignature(memberDecl);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Interface: {\r\n                        this.emitInterfaceDeclaration(memberDecl);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Module: {\r\n                        this.emitModuleSignature(memberDecl);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Import: {\r\n                        this.emitImportDecl(memberDecl);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Empty: {\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        throw Error(\"We want to catch this\");\r\n\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitModuleSignature = function (moduleDecl) {\r\n            if(moduleDecl.isEnum()) {\r\n                this.emitEnumSignature(moduleDecl);\r\n            } else {\r\n                var oldDeclIndentDelta = this.declIndentDelta;\r\n                var wasDottedModuleDecl = this.declDottedModuleName;\r\n                var canEmitSignature = this.emitModuleIdentification(moduleDecl);\r\n                if(canEmitSignature) {\r\n                    var oldDeclContainingAST = this.setDeclContainingAST(moduleDecl);\r\n                    this.increaseIndent();\r\n                    var tempContainer = this.setContainer(EmitContainer.Module);\r\n                    this.emitModuleBodyOfAmbientModule(moduleDecl);\r\n                    this.setContainer(tempContainer);\r\n                    this.decreaseIndent();\r\n                    this.setDeclContainingAST(oldDeclContainingAST);\r\n                    if(!wasDottedModuleDecl) {\r\n                        this.declIndentDelta = oldDeclIndentDelta;\r\n                        this.emitIndentToDeclFile();\r\n                        this.declFile.WriteLine(\"}\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitEnumBodyOfAmbientEnum = function (moduleDecl) {\r\n            var membersLen = moduleDecl.members.members.length;\r\n            for(var j = 1; j < membersLen; j++) {\r\n                var memberDecl = moduleDecl.members.members[j];\r\n                if(memberDecl.nodeType == TypeScript.NodeType.VarDecl) {\r\n                    this.emitIndentToDeclFile();\r\n                    this.declFile.WriteLine((memberDecl).id.text + \",\");\r\n                } else {\r\n                    if(memberDecl.nodeType != TypeScript.NodeType.Asg) {\r\n                        throw Error(\"We want to catch this\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitEnumSignature = function (moduleDecl) {\r\n            if(!this.canEmitSignature(TypeScript.ToDeclFlags(moduleDecl.modFlags))) {\r\n                return false;\r\n            }\r\n            this.emitDeclFlags(TypeScript.ToDeclFlags(moduleDecl.modFlags), \"enum\");\r\n            this.declFile.WriteLine(moduleDecl.name.text + \" {\");\r\n            this.increaseIndent();\r\n            this.emitEnumBodyOfAmbientEnum(moduleDecl);\r\n            this.decreaseIndent();\r\n            this.emitIndentToDeclFile();\r\n            this.declFile.WriteLine(\"}\");\r\n            return true;\r\n        };\r\n        Emitter.prototype.emitInterfaceBody = function (typeMemberList) {\r\n            for(var i = 0; i < typeMemberList.members.length; i++) {\r\n                var typeMember = typeMemberList.members[i];\r\n                switch(typeMember.nodeType) {\r\n                    case TypeScript.NodeType.FuncDecl: {\r\n                        this.emitFuncSignature(typeMember, true);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.VarDecl: {\r\n                        this.emitVarSignature(typeMember, true);\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        throw Error(\"Not allowed\");\r\n\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitInterfaceDeclaration = function (interfaceDecl) {\r\n            if(this.canEmitSignature(TypeScript.ToDeclFlags(interfaceDecl.varFlags))) {\r\n                var temp = this.setContainer(EmitContainer.Interface);\r\n                var interfaceName = interfaceDecl.name.text;\r\n                this.emitDeclFlags(TypeScript.ToDeclFlags(interfaceDecl.varFlags), \"interface\");\r\n                this.declFile.Write(interfaceName);\r\n                this.emitBaseList(interfaceDecl.extendsList, \"extends\");\r\n                this.declFile.WriteLine(\" {\");\r\n                this.increaseIndent();\r\n                var oldDeclContainingAST = this.setDeclContainingAST(interfaceDecl);\r\n                this.emitInterfaceBody(interfaceDecl.members);\r\n                this.setDeclContainingAST(oldDeclContainingAST);\r\n                this.decreaseIndent();\r\n                this.emitIndentToDeclFile();\r\n                this.declFile.WriteLine(\"}\");\r\n                this.setContainer(temp);\r\n            }\r\n        };\r\n        Emitter.prototype.emitJavascriptModule = function (moduleDecl, writeDeclFile) {\r\n            var modName = moduleDecl.name.text;\r\n            if(TypeScript.isTSFile(modName)) {\r\n                moduleDecl.name.text = modName.substring(0, modName.length - 3);\r\n            } else {\r\n                if(TypeScript.isSTRFile(modName)) {\r\n                    moduleDecl.name.text = modName.substring(0, modName.length - 4);\r\n                }\r\n            }\r\n            if(!TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.Ambient)) {\r\n                var isDynamicMod = TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.IsDynamic);\r\n                var oldDeclIndentDelta = this.declIndentDelta;\r\n                var wasDottedModuleDecl = this.declDottedModuleName;\r\n                var oldDeclContainingAST = null;\r\n                var prevOutFile = this.outfile;\r\n                if(writeDeclFile) {\r\n                    if(!isDynamicMod) {\r\n                        if(moduleDecl.isEnum()) {\r\n                            writeDeclFile = this.emitEnumSignature(moduleDecl);\r\n                        } else {\r\n                            writeDeclFile = this.emitModuleIdentification(moduleDecl);\r\n                        }\r\n                    }\r\n                    if(writeDeclFile) {\r\n                        oldDeclContainingAST = this.setDeclContainingAST(moduleDecl);\r\n                    }\r\n                }\r\n                var temp = this.setContainer(EmitContainer.Module);\r\n                var svModuleName = this.moduleName;\r\n                var isExported = TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.Exported);\r\n                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;\r\n                this.moduleName = moduleDecl.name.text;\r\n                this.recordSourceMappingStart(moduleDecl);\r\n                if(isDynamicMod) {\r\n                    var modFilePath = TypeScript.stripQuotes(TypeScript.trimModName(moduleDecl.name.text)) + \".js\";\r\n                    if(this.emitOptions.createFile) {\r\n                        if(modFilePath != this.emitOptions.path) {\r\n                            this.outfile = this.emitOptions.createFile(modFilePath);\r\n                        } else {\r\n                            if(!this.emitOptions.outputMany) {\r\n                                this.checker.errorReporter.emitterError(moduleDecl, \"Module emit collides with emitted script: \" + modFilePath);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.setContainer(EmitContainer.DynamicModule);\r\n                    if(TypeScript.moduleGenTarget == TypeScript.ModuleGenTarget.Asynchronous) {\r\n                        var dependencyList = \"[\\\"require\\\", \\\"exports\\\"\";\r\n                        var importList = \"require, exports\";\r\n                        var importStatement = null;\r\n                        for(var i = 0; i < (moduleDecl.mod).importedModules.length; i++) {\r\n                            importStatement = (moduleDecl.mod).importedModules[i];\r\n                            if(importStatement.id.sym && !(importStatement.id.sym).onlyReferencedAsTypeRef) {\r\n                                if(i <= (moduleDecl.mod).importedModules.length - 1) {\r\n                                    dependencyList += \", \";\r\n                                    importList += \", \";\r\n                                }\r\n                                importList += \"__\" + importStatement.id.text + \"__\";\r\n                                dependencyList += importStatement.firstAliasedModToString();\r\n                            }\r\n                        }\r\n                        for(var i = 0; i < moduleDecl.amdDependencies.length; i++) {\r\n                            dependencyList += \", \\\"\" + moduleDecl.amdDependencies[i] + \"\\\"\";\r\n                        }\r\n                        dependencyList += \"]\";\r\n                        this.writeLineToOutput(\"define(\" + dependencyList + \",\" + \" function(\" + importList + \") {\");\r\n                    } else {\r\n                    }\r\n                } else {\r\n                    if(!isExported) {\r\n                        this.writeLineToOutput(\"var \" + this.moduleName + \";\");\r\n                        this.emitIndent();\r\n                    }\r\n                    this.writeLineToOutput(\"(function (\" + this.moduleName + \") {\");\r\n                }\r\n                if(!isDynamicMod || TypeScript.moduleGenTarget == TypeScript.ModuleGenTarget.Asynchronous) {\r\n                    this.increaseIndent();\r\n                    if(isDynamicMod) {\r\n                        this.addDeclIndentDelta();\r\n                    }\r\n                }\r\n                this.emitJavascriptList(moduleDecl.members, null, TypeScript.TokenID.SColon, true, false, false, writeDeclFile && !moduleDecl.isEnum());\r\n                if(!isDynamicMod || TypeScript.moduleGenTarget == TypeScript.ModuleGenTarget.Asynchronous) {\r\n                    this.decreaseIndent();\r\n                    if(isDynamicMod) {\r\n                        this.reduceDeclIndentDelta();\r\n                    }\r\n                }\r\n                this.emitIndent();\r\n                if(isDynamicMod) {\r\n                    if(writeDeclFile) {\r\n                        this.setDeclContainingAST(oldDeclContainingAST);\r\n                    }\r\n                    if(TypeScript.moduleGenTarget == TypeScript.ModuleGenTarget.Asynchronous) {\r\n                        this.writeLineToOutput(\"})\");\r\n                    } else {\r\n                    }\r\n                    if(this.outfile != prevOutFile) {\r\n                        this.outfile.Close();\r\n                        this.outfile = prevOutFile;\r\n                    }\r\n                } else {\r\n                    if(writeDeclFile) {\r\n                        this.setDeclContainingAST(oldDeclContainingAST);\r\n                        if(!moduleDecl.isEnum() && !wasDottedModuleDecl) {\r\n                            this.declIndentDelta = oldDeclIndentDelta;\r\n                            this.emitIndentToDeclFile();\r\n                            this.declFile.WriteLine(\"}\");\r\n                        }\r\n                    }\r\n                    var containingMod = null;\r\n                    if(moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {\r\n                        containingMod = moduleDecl.type.symbol.container.declAST;\r\n                    }\r\n                    var parentIsDynamic = containingMod && TypeScript.hasFlag(containingMod.modFlags, TypeScript.ModuleFlags.IsDynamic);\r\n                    if(temp == EmitContainer.Prog && isExported) {\r\n                        this.writeLineToOutput(\"})(this.\" + this.moduleName + \" || (this.\" + this.moduleName + \" = {}));\");\r\n                    } else {\r\n                        if(isExported || temp == EmitContainer.Prog) {\r\n                            var dotMod = svModuleName != \"\" ? (parentIsDynamic ? \"exports\" : svModuleName) + \".\" : svModuleName;\r\n                            this.writeLineToOutput(\"})(\" + dotMod + this.moduleName + \" || (\" + dotMod + this.moduleName + \" = {}));\");\r\n                        } else {\r\n                            if(!isExported && temp != EmitContainer.Prog) {\r\n                                this.writeLineToOutput(\"})(\" + this.moduleName + \" || (\" + this.moduleName + \" = {}));\");\r\n                            } else {\r\n                                this.writeLineToOutput(\"})();\");\r\n                            }\r\n                        }\r\n                    }\r\n                    if(temp != EmitContainer.Prog && !parentIsDynamic && isExported) {\r\n                        this.emitIndent();\r\n                        this.writeLineToOutput(\"var \" + this.moduleName + \" = \" + svModuleName + \".\" + this.moduleName + \";\");\r\n                    }\r\n                }\r\n                this.recordSourceMappingEnd(moduleDecl);\r\n                this.setContainer(temp);\r\n                this.moduleName = svModuleName;\r\n                this.moduleDeclList.length--;\r\n            } else {\r\n                if(writeDeclFile) {\r\n                    this.emitModuleSignature(moduleDecl);\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitIndex = function (operand1, operand2) {\r\n            var temp = this.setInObjectLiteral(false);\r\n            this.emitJavascript(operand1, TypeScript.TokenID.Tilde, false);\r\n            this.writeToOutput(\"[\");\r\n            this.emitJavascriptList(operand2, \", \", TypeScript.TokenID.Comma, false, false, false);\r\n            this.writeToOutput(\"]\");\r\n            this.setInObjectLiteral(temp);\r\n        };\r\n        Emitter.prototype.emitStringLiteral = function (text) {\r\n            this.writeToOutput(text);\r\n        };\r\n        Emitter.prototype.emitJavascriptFunction = function (funcDecl, writeDeclFile) {\r\n            if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Signature) || funcDecl.isOverload) {\r\n                if(writeDeclFile) {\r\n                    this.emitFuncSignature(funcDecl);\r\n                }\r\n                return;\r\n            }\r\n            var temp;\r\n            var tempFnc = this.thisFnc;\r\n            this.thisFnc = funcDecl;\r\n            if(funcDecl.isConstructor) {\r\n                temp = this.setContainer(EmitContainer.Constructor);\r\n            } else {\r\n                temp = this.setContainer(EmitContainer.Function);\r\n            }\r\n            var bases = null;\r\n            var hasSelfRef = false;\r\n            var funcName = funcDecl.getNameText();\r\n            if((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) && ((temp != EmitContainer.Constructor) || ((funcDecl.fncFlags & TypeScript.FncFlags.Method) == TypeScript.FncFlags.None))) {\r\n                var tempLit = this.setInObjectLiteral(false);\r\n                if(this.thisClassNode) {\r\n                    bases = this.thisClassNode.extendsList;\r\n                }\r\n                hasSelfRef = funcDecl.hasSelfReference();\r\n                this.recordSourceMappingStart(funcDecl);\r\n                if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Exported | TypeScript.FncFlags.ClassPropertyMethodExported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {\r\n                    this.writeToOutput(\"this.\" + funcName + \" = \");\r\n                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode, writeDeclFile, temp);\r\n                } else {\r\n                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode, writeDeclFile, temp);\r\n                }\r\n                this.recordSourceMappingEnd(funcDecl);\r\n                this.setInObjectLiteral(tempLit);\r\n            }\r\n            this.setContainer(temp);\r\n            this.thisFnc = tempFnc;\r\n            if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Definition)) {\r\n                if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Static)) {\r\n                    if(this.thisClassNode) {\r\n                        if(funcDecl.isAccessor()) {\r\n                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.text, false, false);\r\n                        } else {\r\n                            this.emitIndent();\r\n                            this.recordSourceMappingStart(funcDecl);\r\n                            this.writeLineToOutput(this.thisClassNode.name.text + \".\" + funcName + \" = \" + funcName + \";\");\r\n                            this.recordSourceMappingEnd(funcDecl);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Exported | TypeScript.FncFlags.ClassPropertyMethodExported)) {\r\n                        this.emitIndent();\r\n                        var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : \"exports\";\r\n                        this.recordSourceMappingStart(funcDecl);\r\n                        this.writeLineToOutput(modName + \".\" + funcName + \" = \" + funcName + \";\");\r\n                        this.recordSourceMappingEnd(funcDecl);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {\r\n            if(varDecl.init) {\r\n                this.emitParensAndCommentsInPlace(varDecl, true);\r\n                this.recordSourceMappingStart(varDecl);\r\n                this.recordSourceMappingStart(varDecl.id);\r\n                this.writeToOutput(varDecl.id.text);\r\n                this.recordSourceMappingEnd(varDecl.id);\r\n                this.writeToOutput(\" = \");\r\n                this.emitJavascript(varDecl.init, TypeScript.TokenID.Comma, false);\r\n                this.recordSourceMappingEnd(varDecl);\r\n                this.writeToOutput(\";\");\r\n                this.emitParensAndCommentsInPlace(varDecl, false);\r\n            }\r\n        };\r\n        Emitter.prototype.emitForVarList = function (varDeclList) {\r\n            if(varDeclList) {\r\n                this.recordSourceMappingStart(varDeclList);\r\n                var len = varDeclList.members.length;\r\n                for(var i = 0; i < len; i++) {\r\n                    var varDecl = varDeclList.members[i];\r\n                    this.emitJavascriptVarDecl(varDecl, (i == 0) ? TypeScript.TokenID.FOR : TypeScript.TokenID.LParen);\r\n                    if(i < (len - 1)) {\r\n                        this.writeToOutput(\", \");\r\n                    }\r\n                }\r\n                this.recordSourceMappingEnd(varDeclList);\r\n            }\r\n        };\r\n        Emitter.prototype.emitJavascriptVarDecl = function (varDecl, tokenId, writeDeclFile) {\r\n            if (typeof writeDeclFile === \"undefined\") { writeDeclFile = false; }\r\n            if((varDecl.varFlags & TypeScript.VarFlags.Ambient) == TypeScript.VarFlags.Ambient) {\r\n                this.emitAmbientVarDecl(varDecl);\r\n            } else {\r\n                var sym = varDecl.sym;\r\n                var hasInitializer = (varDecl.init != null);\r\n                this.emitParensAndCommentsInPlace(varDecl, true);\r\n                this.recordSourceMappingStart(varDecl);\r\n                if(sym && sym.isMember() && sym.container && (sym.container.kind() == TypeScript.SymbolKind.Type)) {\r\n                    var type = (sym.container).type;\r\n                    if(type.isClass() && (!TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.ModuleMember))) {\r\n                        if(this.emitState.container != EmitContainer.Args) {\r\n                            if(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Static)) {\r\n                                this.writeToOutput(sym.container.name + \".\");\r\n                            } else {\r\n                                this.writeToOutput(\"this.\");\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if(type.hasImplementation()) {\r\n                            if(!TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Property))) {\r\n                                this.writeToOutput(\"var \");\r\n                            } else {\r\n                                if(TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.LocalStatic)) {\r\n                                    this.writeToOutput(\".\");\r\n                                } else {\r\n                                    if(this.emitState.container == EmitContainer.DynamicModule) {\r\n                                        this.writeToOutput(\"exports.\");\r\n                                    } else {\r\n                                        this.writeToOutput(this.moduleName + \".\");\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if(tokenId != TypeScript.TokenID.LParen) {\r\n                                if(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Exported) && sym.container == this.checker.gloMod) {\r\n                                    this.writeToOutput(\"this.\");\r\n                                } else {\r\n                                    this.writeToOutput(\"var \");\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if(tokenId != TypeScript.TokenID.LParen) {\r\n                        this.writeToOutput(\"var \");\r\n                    }\r\n                }\r\n                this.recordSourceMappingStart(varDecl.id);\r\n                this.writeToOutput(varDecl.id.text);\r\n                this.recordSourceMappingEnd(varDecl.id);\r\n                if(hasInitializer) {\r\n                    this.writeToOutputTrimmable(\" = \");\r\n                    this.emitJavascript(varDecl.init, TypeScript.TokenID.Comma, false);\r\n                } else {\r\n                    if(sym && sym.isMember() && (this.emitState.container == EmitContainer.Constructor)) {\r\n                        this.writeToOutputTrimmable(\" = \");\r\n                        this.writeToOutput(this.defaultValue(varDecl.type));\r\n                    }\r\n                }\r\n                if((tokenId != TypeScript.TokenID.FOR) && (tokenId != TypeScript.TokenID.LParen)) {\r\n                    this.writeToOutputTrimmable(\";\");\r\n                }\r\n                this.recordSourceMappingEnd(varDecl);\r\n                this.emitParensAndCommentsInPlace(varDecl, false);\r\n            }\r\n            if(writeDeclFile) {\r\n                this.emitVarSignature(varDecl);\r\n            }\r\n        };\r\n        Emitter.prototype.declEnclosed = function (moduleDecl) {\r\n            if(moduleDecl == null) {\r\n                return true;\r\n            }\r\n            for(var i = 0, len = this.moduleDeclList.length; i < len; i++) {\r\n                if(this.moduleDeclList[i] == moduleDecl) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        Emitter.prototype.emitJavascriptName = function (name, addThis) {\r\n            var sym = name.sym;\r\n            this.emitParensAndCommentsInPlace(name, true);\r\n            this.recordSourceMappingStart(name);\r\n            if(!name.isMissing()) {\r\n                if(addThis && (this.emitState.container != EmitContainer.Args) && sym) {\r\n                    if(sym.container && (sym.container.name != TypeScript.globalId)) {\r\n                        if(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Static) && (TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Property))) {\r\n                            if(sym.declModule && TypeScript.hasFlag(sym.declModule.modFlags, TypeScript.ModuleFlags.IsDynamic)) {\r\n                                this.writeToOutput(\"exports.\");\r\n                            } else {\r\n                                this.writeToOutput(sym.container.name + \".\");\r\n                            }\r\n                        } else {\r\n                            if(sym.kind() == TypeScript.SymbolKind.Field) {\r\n                                var fieldSym = sym;\r\n                                if(TypeScript.hasFlag(fieldSym.flags, TypeScript.SymbolFlags.ModuleMember)) {\r\n                                    if((sym.container != this.checker.gloMod) && ((TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Property)) || TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Exported))) {\r\n                                        if(TypeScript.hasFlag(sym.declModule.modFlags, TypeScript.ModuleFlags.IsDynamic)) {\r\n                                            this.writeToOutput(\"exports.\");\r\n                                        } else {\r\n                                            this.writeToOutput(sym.container.name + \".\");\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    if(sym.isInstanceProperty()) {\r\n                                        if(this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {\r\n                                            this.writeToOutput(\"_this.\");\r\n                                        } else {\r\n                                            this.writeToOutput(\"this.\");\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                if(sym.kind() == TypeScript.SymbolKind.Type) {\r\n                                    if(sym.isInstanceProperty()) {\r\n                                        var typeSym = sym;\r\n                                        var type = typeSym.type;\r\n                                        if(type.call && !TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.ModuleMember)) {\r\n                                            if(this.thisFnc && !this.thisFnc.isMethod() && !this.thisFnc.isConstructor) {\r\n                                                this.writeToOutput(\"_this.\");\r\n                                            } else {\r\n                                                this.writeToOutput(\"this.\");\r\n                                            }\r\n                                        }\r\n                                    } else {\r\n                                        if((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {\r\n                                            this.writeToOutput(sym.container.name + \".\");\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if(sym.container == this.checker.gloMod && TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Exported) && !TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Ambient) && !((sym.isType() || sym.isMember()) && sym.declModule && TypeScript.hasFlag(sym.declModule.modFlags, TypeScript.ModuleFlags.Ambient)) && this.emitState.container == EmitContainer.Prog && sym.declAST.nodeType != TypeScript.NodeType.FuncDecl) {\r\n                            this.writeToOutput(\"this.\");\r\n                        }\r\n                    }\r\n                }\r\n                if(sym && sym.declAST && sym.declAST.nodeType == TypeScript.NodeType.Module && (TypeScript.hasFlag((sym.declAST).modFlags, TypeScript.ModuleFlags.IsDynamic))) {\r\n                    var moduleDecl = sym.declAST;\r\n                    if(TypeScript.moduleGenTarget == TypeScript.ModuleGenTarget.Asynchronous) {\r\n                        this.writeLineToOutput(\"__\" + this.modAliasId + \"__;\");\r\n                    } else {\r\n                        var modPath = name.text;\r\n                        var isAmbient = moduleDecl.mod.symbol.declAST && TypeScript.hasFlag((moduleDecl.mod.symbol.declAST).modFlags, TypeScript.ModuleFlags.Ambient);\r\n                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : TypeScript.quoteBaseName(modPath);\r\n                        modPath = isAmbient ? modPath : (!TypeScript.isRelative(TypeScript.stripQuotes(modPath)) ? TypeScript.quoteStr(\"./\" + TypeScript.stripQuotes(modPath)) : modPath);\r\n                        this.writeToOutput(\"require(\" + modPath + \")\");\r\n                    }\r\n                } else {\r\n                    this.writeToOutput(name.text);\r\n                }\r\n            }\r\n            this.recordSourceMappingEnd(name);\r\n            this.emitParensAndCommentsInPlace(name, false);\r\n        };\r\n        Emitter.prototype.emitJavascriptStatements = function (stmts, emitEmptyBod, newlineAfterBlock) {\r\n            if(stmts) {\r\n                if(stmts.nodeType != TypeScript.NodeType.Block) {\r\n                    var hasContents = (stmts && (stmts.nodeType != TypeScript.NodeType.List || ((stmts).members.length > 0)));\r\n                    if(emitEmptyBod || hasContents) {\r\n                        var hasOnlyBlockStatement = ((stmts.nodeType == TypeScript.NodeType.Block) || ((stmts.nodeType == TypeScript.NodeType.List) && ((stmts).members.length == 1) && ((stmts).members[0].nodeType == TypeScript.NodeType.Block)));\r\n                        this.recordSourceMappingStart(stmts);\r\n                        if(!hasOnlyBlockStatement) {\r\n                            this.writeLineToOutput(\" {\");\r\n                            this.increaseIndent();\r\n                        }\r\n                        this.emitJavascriptList(stmts, null, TypeScript.TokenID.SColon, true, false, false);\r\n                        if(!hasOnlyBlockStatement) {\r\n                            this.writeLineToOutput(\"\");\r\n                            this.decreaseIndent();\r\n                            this.emitIndent();\r\n                            this.writeToOutput(\"}\");\r\n                        }\r\n                        this.recordSourceMappingEnd(stmts);\r\n                    }\r\n                } else {\r\n                    this.emitJavascript(stmts, TypeScript.TokenID.SColon, true);\r\n                }\r\n            } else {\r\n                if(emitEmptyBod) {\r\n                    this.writeToOutput(\"{ }\");\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitBareJavascriptStatements = function (stmts, emitClassPropertiesAfterSuperCall) {\r\n            if(stmts.nodeType != TypeScript.NodeType.Block) {\r\n                if(stmts.nodeType == TypeScript.NodeType.List) {\r\n                    var stmtList = stmts;\r\n                    if((stmtList.members.length == 2) && (stmtList.members[0].nodeType == TypeScript.NodeType.Block) && (stmtList.members[1].nodeType == TypeScript.NodeType.EndCode)) {\r\n                        this.emitJavascript(stmtList.members[0], TypeScript.TokenID.SColon, true);\r\n                        this.writeLineToOutput(\"\");\r\n                    } else {\r\n                        this.emitJavascriptList(stmts, null, TypeScript.TokenID.SColon, true, false, emitClassPropertiesAfterSuperCall);\r\n                    }\r\n                } else {\r\n                    this.emitJavascript(stmts, TypeScript.TokenID.SColon, true);\r\n                }\r\n            } else {\r\n                this.emitJavascript(stmts, TypeScript.TokenID.SColon, true);\r\n            }\r\n        };\r\n        Emitter.prototype.recordSourceMappingStart = function (ast) {\r\n            if(this.sourceMapper && ast) {\r\n                var lineCol = {\r\n                    line: -1,\r\n                    col: -1\r\n                };\r\n                var sourceMapping = new TypeScript.SourceMapping(ast);\r\n                sourceMapping.emittedStartColumn = this.emitState.column;\r\n                sourceMapping.emittedStartLine = this.emitState.line;\r\n                TypeScript.getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);\r\n                sourceMapping.sourceStartColumn = lineCol.col;\r\n                sourceMapping.sourceStartLine = lineCol.line;\r\n                TypeScript.getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);\r\n                sourceMapping.sourceEndColumn = lineCol.col;\r\n                sourceMapping.sourceEndLine = lineCol.line;\r\n                sourceMapping.parent = this.sourceMapper.currentMapping;\r\n                this.sourceMapper.currentMapping = this.sourceMapper.sourceMappings.length;\r\n                this.sourceMapper.sourceMappings.push(sourceMapping);\r\n                if(sourceMapping.parent >= 0) {\r\n                    var parentMapping = this.sourceMapper.sourceMappings[sourceMapping.parent];\r\n                    if(parentMapping.firstChild == -1) {\r\n                        parentMapping.firstChild = this.sourceMapper.currentMapping;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.recordSourceMappingEnd = function (ast) {\r\n            if(this.sourceMapper && ast) {\r\n                var currentMappingIndex = this.sourceMapper.currentMapping;\r\n                var sourceMapping = this.sourceMapper.sourceMappings[currentMappingIndex];\r\n                sourceMapping.emittedEndColumn = this.emitState.column;\r\n                sourceMapping.emittedEndLine = this.emitState.line;\r\n                this.sourceMapper.currentMapping = sourceMapping.parent;\r\n            }\r\n        };\r\n        Emitter.prototype.emitSourceMappings = function () {\r\n            TypeScript.SourceMapper.EmitSourceMapping(this.allSourceMappers);\r\n        };\r\n        Emitter.prototype.emitJavascriptList = function (ast, delimiter, tokenId, startLine, onlyStatics, emitClassPropertiesAfterSuperCall, writeDeclFile) {\r\n            if(ast == null) {\r\n                return;\r\n            } else {\r\n                if(ast.nodeType != TypeScript.NodeType.List) {\r\n                    this.emitJavascript(ast, tokenId, startLine, writeDeclFile);\r\n                } else {\r\n                    var list = ast;\r\n                    if(list.members.length == 0) {\r\n                        return;\r\n                    }\r\n                    this.emitParensAndCommentsInPlace(ast, true);\r\n                    var len = list.members.length;\r\n                    for(var i = 0; i < len; i++) {\r\n                        if(i == 1 && emitClassPropertiesAfterSuperCall) {\r\n                            var constructorDecl = (this.thisClassNode).constructorDecl;\r\n                            if(constructorDecl && constructorDecl.args) {\r\n                                var argsLen = constructorDecl.args.members.length;\r\n                                for(var iArg = 0; iArg < argsLen; iArg++) {\r\n                                    var arg = constructorDecl.args.members[iArg];\r\n                                    if((arg.varFlags & TypeScript.VarFlags.Property) != TypeScript.VarFlags.None) {\r\n                                        this.emitIndent();\r\n                                        this.recordSourceMappingStart(arg);\r\n                                        this.recordSourceMappingStart(arg.id);\r\n                                        this.writeToOutput(\"this.\" + arg.id.text);\r\n                                        this.recordSourceMappingEnd(arg.id);\r\n                                        this.writeToOutput(\" = \");\r\n                                        this.recordSourceMappingStart(arg.id);\r\n                                        this.writeToOutput(arg.id.text);\r\n                                        this.recordSourceMappingEnd(arg.id);\r\n                                        this.writeLineToOutput(\";\");\r\n                                        this.recordSourceMappingEnd(arg);\r\n                                    }\r\n                                }\r\n                            }\r\n                            var nProps = (this.thisClassNode.members).members.length;\r\n                            for(var iMember = 0; iMember < nProps; iMember++) {\r\n                                if((this.thisClassNode.members).members[iMember].nodeType == TypeScript.NodeType.VarDecl) {\r\n                                    var varDecl = (this.thisClassNode.members).members[iMember];\r\n                                    if(!TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Static) && varDecl.init) {\r\n                                        this.emitIndent();\r\n                                        this.emitJavascriptVarDecl(varDecl, TypeScript.TokenID.Tilde);\r\n                                        this.writeLineToOutput(\"\");\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        var emitNode = list.members[i];\r\n                        var isStaticDecl = (emitNode.nodeType == TypeScript.NodeType.FuncDecl && TypeScript.hasFlag((emitNode).fncFlags, TypeScript.FncFlags.Static)) || (emitNode.nodeType == TypeScript.NodeType.VarDecl && TypeScript.hasFlag((emitNode).varFlags, TypeScript.VarFlags.Static));\r\n                        if(onlyStatics ? !isStaticDecl : isStaticDecl) {\r\n                            continue;\r\n                        }\r\n                        this.emitJavascript(emitNode, tokenId, startLine, writeDeclFile);\r\n                        if(delimiter && (i < (len - 1))) {\r\n                            if(startLine) {\r\n                                this.writeLineToOutput(delimiter);\r\n                            } else {\r\n                                this.writeToOutput(delimiter);\r\n                            }\r\n                        } else {\r\n                            if(startLine && (emitNode.nodeType != TypeScript.NodeType.Interface) && (!((emitNode.nodeType == TypeScript.NodeType.VarDecl) && ((((emitNode).varFlags) & TypeScript.VarFlags.Ambient) == TypeScript.VarFlags.Ambient) && (((emitNode).init) == null))) && (emitNode.nodeType != TypeScript.NodeType.EndCode) && (emitNode.nodeType != TypeScript.NodeType.FuncDecl)) {\r\n                                this.writeLineToOutput(\"\");\r\n                            }\r\n                        }\r\n                    }\r\n                    this.emitParensAndCommentsInPlace(ast, false);\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitJavascript = function (ast, tokenId, startLine, writeDeclFile) {\r\n            if (typeof writeDeclFile === \"undefined\") { writeDeclFile = false; }\r\n            if(ast == null) {\r\n                return;\r\n            }\r\n            var parenthesize = false;\r\n            if(startLine && (this.emitState.indentAmt > 0) && (ast.nodeType != TypeScript.NodeType.List) && (ast.nodeType != TypeScript.NodeType.Block)) {\r\n                if((ast.nodeType != TypeScript.NodeType.Interface) && (!((ast.nodeType == TypeScript.NodeType.VarDecl) && ((((ast).varFlags) & TypeScript.VarFlags.Ambient) == TypeScript.VarFlags.Ambient) && (((ast).init) == null))) && (ast.nodeType != TypeScript.NodeType.EndCode) && ((ast.nodeType != TypeScript.NodeType.FuncDecl) || (this.emitState.container != EmitContainer.Constructor))) {\r\n                    this.emitIndent();\r\n                }\r\n            }\r\n            if(parenthesize) {\r\n                this.writeToOutput(\"(\");\r\n            }\r\n            ast.emit(this, tokenId, startLine, writeDeclFile);\r\n            if(parenthesize) {\r\n                this.writeToOutput(\")\");\r\n            }\r\n            if((tokenId == TypeScript.TokenID.SColon) && (ast.nodeType < TypeScript.NodeType.GeneralNode)) {\r\n                this.writeToOutput(\";\");\r\n            }\r\n        };\r\n        Emitter.prototype.emitPropertyAccessor = function (funcDecl, className, isProto, writeDeclFile) {\r\n            if(!(funcDecl.accessorSymbol).hasBeenEmitted) {\r\n                var accessorSymbol = funcDecl.accessorSymbol;\r\n                this.emitIndent();\r\n                this.recordSourceMappingStart(funcDecl);\r\n                this.writeLineToOutput(\"Object.defineProperty(\" + className + (isProto ? \".prototype, \\\"\" : \", \\\"\") + funcDecl.name.text + \"\\\"\" + \", {\");\r\n                this.increaseIndent();\r\n                if(accessorSymbol.getter) {\r\n                    var getter = accessorSymbol.getter.declAST;\r\n                    this.emitIndent();\r\n                    this.writeToOutput(\"get: \");\r\n                    this.emitInnerFunction(getter, false, isProto, null, funcDecl.hasSelfReference(), null);\r\n                    this.writeLineToOutput(\",\");\r\n                }\r\n                if(accessorSymbol.setter) {\r\n                    var setter = accessorSymbol.setter.declAST;\r\n                    this.emitIndent();\r\n                    this.writeToOutput(\"set: \");\r\n                    this.emitInnerFunction(setter, false, isProto, null, funcDecl.hasSelfReference(), null);\r\n                    this.writeLineToOutput(\",\");\r\n                }\r\n                this.emitIndent();\r\n                this.writeLineToOutput(\"enumerable: true,\");\r\n                this.emitIndent();\r\n                this.writeLineToOutput(\"configurable: true\");\r\n                this.decreaseIndent();\r\n                this.emitIndent();\r\n                this.writeLineToOutput(\"});\");\r\n                this.recordSourceMappingEnd(funcDecl);\r\n                if(writeDeclFile) {\r\n                    this.emitPropertyAccessorSignature(funcDecl);\r\n                }\r\n                accessorSymbol.hasBeenEmitted = true;\r\n            }\r\n        };\r\n        Emitter.prototype.emitPrototypeMember = function (member, className, writeDeclFile) {\r\n            if(member.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                var funcDecl = member;\r\n                if(funcDecl.isAccessor()) {\r\n                    this.emitPropertyAccessor(funcDecl, className, true, writeDeclFile);\r\n                } else {\r\n                    this.emitIndent();\r\n                    this.recordSourceMappingStart(funcDecl);\r\n                    this.writeToOutput(className + \".prototype.\" + funcDecl.getNameText() + \" = \");\r\n                    this.emitInnerFunction(funcDecl, false, true, null, funcDecl.hasSelfReference(), null, writeDeclFile);\r\n                    this.recordSourceMappingEnd(funcDecl);\r\n                    this.writeLineToOutput(\";\");\r\n                }\r\n            } else {\r\n                if(member.nodeType == TypeScript.NodeType.VarDecl) {\r\n                    var varDecl = member;\r\n                    if(varDecl.init) {\r\n                        this.emitIndent();\r\n                        this.recordSourceMappingStart(varDecl);\r\n                        this.recordSourceMappingStart(varDecl.id);\r\n                        this.writeToOutput(className + \".prototype.\" + varDecl.id.text);\r\n                        this.recordSourceMappingEnd(varDecl.id);\r\n                        this.writeToOutput(\" = \");\r\n                        this.emitJavascript(varDecl.init, TypeScript.TokenID.Asg, false);\r\n                        this.recordSourceMappingEnd(varDecl);\r\n                        this.writeLineToOutput(\";\");\r\n                    }\r\n                    if(writeDeclFile) {\r\n                        this.emitVarSignature(varDecl);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitAddBaseMethods = function (className, base, classDecl) {\r\n            if(base.members) {\r\n                var baseSymbol = base.symbol;\r\n                var baseName = baseSymbol.name;\r\n                if(baseSymbol.declModule != classDecl.type.symbol.declModule) {\r\n                    baseName = baseSymbol.fullName();\r\n                }\r\n                base.members.allMembers.map(function (key, s, c) {\r\n                    var sym = s;\r\n                    if((sym.kind() == TypeScript.SymbolKind.Type) && (sym).type.call) {\r\n                        this.recordSourceMappingStart(sym.declAST);\r\n                        this.writeLineToOutput(className + \".prototype.\" + sym.name + \" = \" + baseName + \".prototype.\" + sym.name + \";\");\r\n                        this.recordSourceMappingEnd(sym.declAST);\r\n                    }\r\n                }, null);\r\n            }\r\n            if(base.extendsList) {\r\n                for(var i = 0, len = base.extendsList.length; i < len; i++) {\r\n                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitJavascriptClass = function (classDecl, writeDeclFile) {\r\n            if(!TypeScript.hasFlag(classDecl.varFlags, TypeScript.VarFlags.Ambient)) {\r\n                var svClassNode = this.thisClassNode;\r\n                var i = 0;\r\n                this.thisClassNode = classDecl;\r\n                var className = classDecl.name.text;\r\n                this.emitParensAndCommentsInPlace(classDecl, true);\r\n                var oldDeclContainingAST = null;\r\n                if(writeDeclFile) {\r\n                    writeDeclFile = this.emitClassSignatureIdentifierAndHeritage(classDecl);\r\n                    if(writeDeclFile) {\r\n                        oldDeclContainingAST = this.setDeclContainingAST(classDecl);\r\n                    }\r\n                }\r\n                var temp = this.setContainer(EmitContainer.Class);\r\n                this.recordSourceMappingStart(classDecl);\r\n                if(TypeScript.hasFlag(classDecl.varFlags, TypeScript.VarFlags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {\r\n                    this.writeToOutput(\"this.\" + className);\r\n                } else {\r\n                    this.writeToOutput(\"var \" + className);\r\n                }\r\n                var _class = classDecl.type;\r\n                var instanceType = _class.instanceType;\r\n                var baseClass = instanceType ? instanceType.baseClass() : null;\r\n                var baseNameDecl = null;\r\n                var baseName = null;\r\n                if(baseClass) {\r\n                    this.writeLineToOutput(\" = (function (_super) {\");\r\n                } else {\r\n                    this.writeLineToOutput(\" = (function () {\");\r\n                }\r\n                this.increaseIndent();\r\n                if(baseClass) {\r\n                    baseNameDecl = classDecl.extendsList.members[0];\r\n                    baseName = baseNameDecl.nodeType == TypeScript.NodeType.Call ? (baseNameDecl).target : baseNameDecl;\r\n                    this.emitIndent();\r\n                    this.writeLineToOutput(\"__extends(\" + className + \", _super);\");\r\n                    var elen = instanceType.extendsList.length;\r\n                    if(elen > 1) {\r\n                        for(var i = 1; i < elen; i++) {\r\n                            var base = instanceType.extendsList[i];\r\n                            this.emitAddBaseMethods(className, base, classDecl);\r\n                        }\r\n                    }\r\n                }\r\n                this.emitIndent();\r\n                var constrDecl = classDecl.constructorDecl;\r\n                if(constrDecl) {\r\n                    this.emitJavascript(classDecl.constructorDecl, TypeScript.TokenID.LParen, false, false);\r\n                    if(writeDeclFile) {\r\n                        this.emitMembersFromConstructorDefinition(classDecl.constructorDecl);\r\n                    }\r\n                } else {\r\n                    var wroteProps = 0;\r\n                    this.recordSourceMappingStart(classDecl);\r\n                    this.increaseIndent();\r\n                    this.writeToOutput(\"function \" + classDecl.name.text + \"() {\");\r\n                    if(baseClass) {\r\n                        this.writeLineToOutput(\"\");\r\n                        this.emitIndent();\r\n                        this.writeLineToOutput(\"_super.apply(this, arguments);\");\r\n                        wroteProps++;\r\n                    }\r\n                    var members = (this.thisClassNode.members).members;\r\n                    for(var i = 0; i < members.length; i++) {\r\n                        if(members[i].nodeType == TypeScript.NodeType.VarDecl) {\r\n                            var varDecl = members[i];\r\n                            if(!TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Static) && varDecl.init) {\r\n                                this.writeLineToOutput(\"\");\r\n                                this.emitIndent();\r\n                                this.emitJavascriptVarDecl(varDecl, TypeScript.TokenID.Tilde);\r\n                                wroteProps++;\r\n                            }\r\n                        }\r\n                    }\r\n                    if(wroteProps) {\r\n                        this.writeLineToOutput(\"\");\r\n                        this.decreaseIndent();\r\n                        this.emitIndent();\r\n                        this.writeLineToOutput(\"}\");\r\n                    } else {\r\n                        this.writeLineToOutput(\" }\");\r\n                        this.decreaseIndent();\r\n                    }\r\n                    this.recordSourceMappingEnd(classDecl);\r\n                }\r\n                var membersLen = classDecl.definitionMembers.members.length;\r\n                for(var j = 0; j < membersLen; j++) {\r\n                    var memberDecl = classDecl.definitionMembers.members[j];\r\n                    if(memberDecl.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                        var fn = memberDecl;\r\n                        if(TypeScript.hasFlag(fn.fncFlags, TypeScript.FncFlags.Method) && !fn.isSignature()) {\r\n                            if(!TypeScript.hasFlag(fn.fncFlags, TypeScript.FncFlags.Static)) {\r\n                                this.emitPrototypeMember(fn, className, writeDeclFile);\r\n                            } else {\r\n                                if(fn.isAccessor()) {\r\n                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.text, false, writeDeclFile);\r\n                                } else {\r\n                                    this.emitIndent();\r\n                                    this.recordSourceMappingStart(fn);\r\n                                    this.writeToOutput(classDecl.name.text + \".\" + fn.name.text + \" = \");\r\n                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), false, null, fn.hasSelfReference(), null, writeDeclFile);\r\n                                    this.recordSourceMappingEnd(fn);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if(writeDeclFile) {\r\n                                this.emitFuncSignature(fn);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if(memberDecl.nodeType == TypeScript.NodeType.VarDecl) {\r\n                            var varDecl = memberDecl;\r\n                            if(TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Static)) {\r\n                                this.emitIndent();\r\n                                this.recordSourceMappingStart(varDecl);\r\n                                this.writeToOutput(classDecl.name.text + \".\" + varDecl.id.text + \" = \");\r\n                                if(varDecl.init) {\r\n                                    this.emitJavascript(varDecl.init, TypeScript.TokenID.Asg, false);\r\n                                    this.writeLineToOutput(\";\");\r\n                                } else {\r\n                                    this.writeLineToOutput(this.defaultValue(varDecl.type) + \";\");\r\n                                }\r\n                                if(writeDeclFile) {\r\n                                    this.emitVarSignature(varDecl);\r\n                                }\r\n                                this.recordSourceMappingEnd(varDecl);\r\n                            } else {\r\n                                if(writeDeclFile) {\r\n                                    this.emitVarSignature(varDecl);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            throw Error(\"We want to catch this\");\r\n                        }\r\n                    }\r\n                }\r\n                this.emitIndent();\r\n                this.recordSourceMappingStart(classDecl);\r\n                this.writeLineToOutput(\"return \" + className + \";\");\r\n                this.recordSourceMappingEnd(classDecl);\r\n                this.decreaseIndent();\r\n                this.emitIndent();\r\n                this.writeToOutput(\"})(\");\r\n                if(baseClass) {\r\n                    this.emitJavascript(baseName, TypeScript.TokenID.Tilde, false);\r\n                }\r\n                this.writeToOutput(\");\");\r\n                if(writeDeclFile) {\r\n                    this.setDeclContainingAST(oldDeclContainingAST);\r\n                    this.emitIndentToDeclFile();\r\n                    this.declFile.WriteLine(\"}\");\r\n                }\r\n                if((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && TypeScript.hasFlag(classDecl.varFlags, TypeScript.VarFlags.Exported)) {\r\n                    this.writeLineToOutput(\"\");\r\n                    this.emitIndent();\r\n                    var modName = temp == EmitContainer.Module ? this.moduleName : \"exports\";\r\n                    this.recordSourceMappingStart(classDecl);\r\n                    this.writeToOutput(modName + \".\" + className + \" = \" + className + \";\");\r\n                    this.recordSourceMappingEnd(classDecl);\r\n                }\r\n                this.emitIndent();\r\n                this.recordSourceMappingEnd(classDecl);\r\n                this.emitParensAndCommentsInPlace(classDecl, false);\r\n                this.setContainer(temp);\r\n                this.thisClassNode = svClassNode;\r\n            } else {\r\n                if(writeDeclFile) {\r\n                    this.emitClassSignature(classDecl);\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitPrologue = function (reqInherits) {\r\n            if(!this.prologueEmitted) {\r\n                if(reqInherits) {\r\n                    this.prologueEmitted = true;\r\n                    this.writeLineToOutput(\"var __extends = this.__extends || function (d, b) {\");\r\n                    this.writeLineToOutput(\"    function __() { this.constructor = d; }\");\r\n                    this.writeLineToOutput(\"    __.prototype = b.prototype;\");\r\n                    this.writeLineToOutput(\"    d.prototype = new __();\");\r\n                    this.writeLineToOutput(\"}\");\r\n                }\r\n            }\r\n        };\r\n        Emitter.prototype.emitSuperReference = function () {\r\n            this.writeToOutput(\"_super.prototype\");\r\n        };\r\n        Emitter.prototype.emitSuperCall = function (callEx) {\r\n            if(callEx.target.nodeType == TypeScript.NodeType.Dot) {\r\n                var dotNode = callEx.target;\r\n                if(dotNode.operand1.nodeType == TypeScript.NodeType.Super) {\r\n                    this.emitJavascript(dotNode, TypeScript.TokenID.LParen, false);\r\n                    this.writeToOutput(\".call(this\");\r\n                    if(callEx.args && callEx.args.members.length > 0) {\r\n                        this.writeToOutput(\", \");\r\n                        this.emitJavascriptList(callEx.args, \", \", TypeScript.TokenID.Comma, false, false, false);\r\n                    }\r\n                    this.writeToOutput(\")\");\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        return Emitter;\r\n    })();\r\n    TypeScript.Emitter = Emitter;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var ErrorReporter = (function () {\r\n        function ErrorReporter(outfile) {\r\n            this.outfile = outfile;\r\n            this.parser = null;\r\n            this.checker = null;\r\n            this.lineCol = {\r\n                line: 0,\r\n                col: 0\r\n            };\r\n            this.emitAsComments = true;\r\n            this.hasErrors = false;\r\n            this.pushToErrorSink = false;\r\n            this.errorSink = [];\r\n        }\r\n        ErrorReporter.prototype.getCapturedErrors = function () {\r\n            return this.errorSink;\r\n        };\r\n        ErrorReporter.prototype.freeCapturedErrors = function () {\r\n            this.errorSink = [];\r\n        };\r\n        ErrorReporter.prototype.captureError = function (emsg) {\r\n            this.errorSink[this.errorSink.length] = emsg;\r\n        };\r\n        ErrorReporter.prototype.setErrOut = function (outerr) {\r\n            this.outfile = outerr;\r\n            this.emitAsComments = false;\r\n        };\r\n        ErrorReporter.prototype.emitPrefix = function () {\r\n            if(this.emitAsComments) {\r\n                this.outfile.Write(\"// \");\r\n            }\r\n            this.outfile.Write(this.checker.locationInfo.filename + \"(\" + this.lineCol.line + \",\" + this.lineCol.col + \"): \");\r\n        };\r\n        ErrorReporter.prototype.writePrefix = function (ast) {\r\n            if(ast) {\r\n                this.setError(ast);\r\n            } else {\r\n                this.lineCol.line = -1;\r\n                this.lineCol.col = -1;\r\n            }\r\n            this.emitPrefix();\r\n        };\r\n        ErrorReporter.prototype.writePrefixFromSym = function (symbol) {\r\n            if(symbol && this.checker.locationInfo.lineMap) {\r\n                TypeScript.getSourceLineColFromMap(this.lineCol, symbol.location, this.checker.locationInfo.lineMap);\r\n            } else {\r\n                this.lineCol.line = -1;\r\n                this.lineCol.col = -1;\r\n            }\r\n            this.emitPrefix();\r\n        };\r\n        ErrorReporter.prototype.setError = function (ast) {\r\n            if(ast) {\r\n                ast.flags |= TypeScript.ASTFlags.Error;\r\n                if(this.checker.locationInfo.lineMap) {\r\n                    TypeScript.getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);\r\n                }\r\n            }\r\n        };\r\n        ErrorReporter.prototype.reportError = function (ast, message) {\r\n            if(this.pushToErrorSink) {\r\n                this.captureError(message);\r\n                return;\r\n            }\r\n            this.hasErrors = true;\r\n            var len = (ast.limChar - ast.minChar);\r\n            if(this.parser.errorRecovery && this.parser.errorCallback) {\r\n                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);\r\n            } else {\r\n                this.writePrefix(ast);\r\n                this.outfile.WriteLine(message);\r\n            }\r\n        };\r\n        ErrorReporter.prototype.reportErrorFromSym = function (symbol, message) {\r\n            if(this.pushToErrorSink) {\r\n                this.captureError(message);\r\n                return;\r\n            }\r\n            this.hasErrors = true;\r\n            if(this.parser.errorRecovery && this.parser.errorCallback) {\r\n                this.parser.errorCallback(symbol.location, 1, message, this.checker.locationInfo.unitIndex);\r\n            } else {\r\n                this.writePrefixFromSym(symbol);\r\n                this.outfile.WriteLine(message);\r\n            }\r\n        };\r\n        ErrorReporter.prototype.emitterError = function (ast, message) {\r\n            this.reportError(ast, message);\r\n            throw Error(\"EmitError\");\r\n        };\r\n        ErrorReporter.prototype.duplicateIdentifier = function (ast, name) {\r\n            this.reportError(ast, \"Duplicate identifier '\" + name + \"'\");\r\n        };\r\n        ErrorReporter.prototype.showRef = function (ast, text, symbol) {\r\n            var defLineCol = {\r\n                line: -1,\r\n                col: -1\r\n            };\r\n            this.parser.getSourceLineCol(defLineCol, symbol.location);\r\n            this.reportError(ast, \"symbol \" + text + \" defined at (\" + defLineCol.line + \",\" + defLineCol.col + \")\");\r\n        };\r\n        ErrorReporter.prototype.unresolvedSymbol = function (ast, name) {\r\n            this.reportError(ast, \"The name '\" + name + \"' does not exist in the current scope\");\r\n        };\r\n        ErrorReporter.prototype.symbolDoesNotReferToAValue = function (ast, name) {\r\n            this.reportError(ast, \"The name '\" + name + \"' does not refer to a value\");\r\n        };\r\n        ErrorReporter.prototype.styleError = function (ast, msg) {\r\n            var bkThrow = this.pushToErrorSink;\r\n            this.pushToErrorSink = false;\r\n            this.reportError(ast, \"STYLE: \" + msg);\r\n            this.pushToErrorSink = bkThrow;\r\n        };\r\n        ErrorReporter.prototype.simpleError = function (ast, msg) {\r\n            this.reportError(ast, msg);\r\n        };\r\n        ErrorReporter.prototype.simpleErrorFromSym = function (sym, msg) {\r\n            this.reportErrorFromSym(sym, msg);\r\n        };\r\n        ErrorReporter.prototype.invalidSuperReference = function (ast) {\r\n            this.simpleError(ast, \"Keyword 'super' can only be used inside a class instance method\");\r\n        };\r\n        ErrorReporter.prototype.valueCannotBeModified = function (ast) {\r\n            this.simpleError(ast, \"The left-hand side of an assignment expression must be a variable, property or indexer\");\r\n        };\r\n        ErrorReporter.prototype.invalidCall = function (ast, nodeType, scope) {\r\n            var targetType = ast.target.type;\r\n            var typeName = targetType.getScopedTypeName(scope);\r\n            if(targetType.construct && (nodeType == TypeScript.NodeType.Call)) {\r\n                this.reportError(ast, \"Value of type '\" + typeName + \"' is not callable.  Did you mean to include 'new'?\");\r\n            } else {\r\n                var catString = (nodeType == TypeScript.NodeType.Call) ? \"callable\" : \"newable\";\r\n                this.reportError(ast, \"Value of type '\" + typeName + \"' is not \" + catString);\r\n            }\r\n        };\r\n        ErrorReporter.prototype.indexLHS = function (ast, scope) {\r\n            var targetType = ast.operand1.type.getScopedTypeName(scope);\r\n            var indexType = ast.operand2.type.getScopedTypeName(scope);\r\n            this.simpleError(ast, \"Value of type '\" + targetType + \"' is not indexable by type '\" + indexType + \"'\");\r\n        };\r\n        ErrorReporter.prototype.incompatibleTypes = function (ast, t1, t2, op, scope, comparisonInfo) {\r\n            if(!t1) {\r\n                t1 = this.checker.anyType;\r\n            }\r\n            if(!t2) {\r\n                t2 = this.checker.anyType;\r\n            }\r\n            var reason = comparisonInfo ? comparisonInfo.message : \"\";\r\n            if(op) {\r\n                this.reportError(ast, \"Operator '\" + op + \"' cannot be applied to types '\" + t1.getScopedTypeName(scope) + \"' and '\" + t2.getScopedTypeName(scope) + \"'\" + (reason ? \": \" + reason : \"\"));\r\n            } else {\r\n                this.reportError(ast, \"Cannot convert '\" + t1.getScopedTypeName(scope) + \"' to '\" + t2.getScopedTypeName(scope) + \"'\" + (reason ? \": \" + reason : \"\"));\r\n            }\r\n        };\r\n        ErrorReporter.prototype.expectedClassOrInterface = function (ast) {\r\n            this.simpleError(ast, \"Expected var, class, interface, or module\");\r\n        };\r\n        ErrorReporter.prototype.unaryOperatorTypeError = function (ast, op, type) {\r\n            this.reportError(ast, \"Operator '\" + op + \"' cannot be applied to type '\" + type.getTypeName() + \"'\");\r\n        };\r\n        return ErrorReporter;\r\n    })();\r\n    TypeScript.ErrorReporter = ErrorReporter;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (TypeContext) {\r\n        TypeContext._map = [];\r\n        TypeContext.NoTypes = 0;\r\n        TypeContext.ArraySuffix = 1;\r\n        TypeContext.Primitive = 2;\r\n        TypeContext.Named = 4;\r\n        TypeContext.AllSimpleTypes = TypeContext.Primitive | TypeContext.Named;\r\n        TypeContext.AllTypes = TypeContext.Primitive | TypeContext.Named | TypeContext.ArraySuffix;\r\n    })(TypeScript.TypeContext || (TypeScript.TypeContext = {}));\r\n    var TypeContext = TypeScript.TypeContext;\r\n\r\n    (function (ParseState) {\r\n        ParseState._map = [];\r\n        ParseState._map[0] = \"None\";\r\n        ParseState.None = 0;\r\n        ParseState._map[1] = \"StartScript\";\r\n        ParseState.StartScript = 1;\r\n        ParseState._map[2] = \"StartStmtList\";\r\n        ParseState.StartStmtList = 2;\r\n        ParseState._map[3] = \"StartStatement\";\r\n        ParseState.StartStatement = 3;\r\n        ParseState._map[4] = \"StartFncDecl\";\r\n        ParseState.StartFncDecl = 4;\r\n        ParseState._map[5] = \"FncDeclName\";\r\n        ParseState.FncDeclName = 5;\r\n        ParseState._map[6] = \"FncDeclArgs\";\r\n        ParseState.FncDeclArgs = 6;\r\n        ParseState._map[7] = \"FncDeclReturnType\";\r\n        ParseState.FncDeclReturnType = 7;\r\n        ParseState._map[8] = \"ForInit\";\r\n        ParseState.ForInit = 8;\r\n        ParseState._map[9] = \"ForInitAfterVar\";\r\n        ParseState.ForInitAfterVar = 9;\r\n        ParseState._map[10] = \"ForCondStart\";\r\n        ParseState.ForCondStart = 10;\r\n        ParseState._map[11] = \"EndStmtList\";\r\n        ParseState.EndStmtList = 11;\r\n        ParseState._map[12] = \"EndScript\";\r\n        ParseState.EndScript = 12;\r\n    })(TypeScript.ParseState || (TypeScript.ParseState = {}));\r\n    var ParseState = TypeScript.ParseState;\r\n\r\n    var QuickParseResult = (function () {\r\n        function QuickParseResult(Script, endLexState) {\r\n            this.Script = Script;\r\n            this.endLexState = endLexState;\r\n        }\r\n        return QuickParseResult;\r\n    })();\r\n    TypeScript.QuickParseResult = QuickParseResult;    \r\n    var Parser = (function () {\r\n        function Parser() {\r\n            this.varLists = [];\r\n            this.scopeLists = [];\r\n            this.staticsLists = [];\r\n            this.scanner = new TypeScript.Scanner();\r\n            this.tok = null;\r\n            this.needTerminator = false;\r\n            this.inFnc = false;\r\n            this.inStaticFnc = false;\r\n            this.inInterfaceDecl = false;\r\n            this.currentClassDecl = null;\r\n            this.inFncDecl = false;\r\n            this.anonId = new TypeScript.Identifier(\"_anonymous\");\r\n            this.style_requireSemi = false;\r\n            this.style_funcInLoop = true;\r\n            this.incremental = false;\r\n            this.errorRecovery = false;\r\n            this.outfile = undefined;\r\n            this.errorCallback = null;\r\n            this.state = ParseState.StartStmtList;\r\n            this.cursorLine = -1;\r\n            this.cursorColumn = -1;\r\n            this.cursorState = ParseState.None;\r\n            this.errorMessage = \"\";\r\n            this.ambientModule = false;\r\n            this.ambientClass = false;\r\n            this.topLevel = true;\r\n            this.currentUnitIndex = (-1);\r\n            this.prevIDTok = null;\r\n            this.stmtStack = new Array();\r\n            this.hasTopLevelImportOrExport = false;\r\n            this.strictMode = false;\r\n            this.nestingLevel = 0;\r\n            this.prevExpr = null;\r\n            this.currentClassDefinition = null;\r\n            this.parsingClassConstructorDefinition = false;\r\n            this.parsingDeclareFile = false;\r\n            this.amdDependencies = [];\r\n            this.inferPropertiesFromThisAssignment = false;\r\n            this.fname = \"\";\r\n            this.parseError = false;\r\n        }\r\n        Parser.prototype.resetStmtStack = function () {\r\n            this.stmtStack = new Array();\r\n        };\r\n        Parser.prototype.inLoop = function () {\r\n            for(var j = this.stmtStack.length - 1; j >= 0; j--) {\r\n                if(this.stmtStack[j].stmt.isLoop()) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        Parser.prototype.pushStmt = function (stmt, labels) {\r\n            var info = {\r\n                stmt: stmt,\r\n                labels: labels\r\n            };\r\n            this.stmtStack.push(info);\r\n        };\r\n        Parser.prototype.popStmt = function () {\r\n            return this.stmtStack.pop();\r\n        };\r\n        Parser.prototype.resolveJumpTarget = function (jump) {\r\n            var len = this.stmtStack.length;\r\n            for(var i = len - 1; i >= 0; i--) {\r\n                var info = this.stmtStack[i];\r\n                if(jump.target) {\r\n                    if(info.labels && (info.labels.members.length > 0)) {\r\n                        for(var j = 0, labLen = info.labels.members.length; j < labLen; j++) {\r\n                            var label = info.labels.members[j];\r\n                            if(label.id.text == jump.target) {\r\n                                jump.setResolvedTarget(this, info.stmt);\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if(info.stmt.isLoop()) {\r\n                        jump.setResolvedTarget(this, info.stmt);\r\n                        return;\r\n                    } else {\r\n                        if((info.stmt.nodeType == TypeScript.NodeType.Switch) && (jump.nodeType == TypeScript.NodeType.Break)) {\r\n                            jump.setResolvedTarget(this, info.stmt);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(jump.target) {\r\n                this.reportParseError(\"could not find enclosing statement with label \" + jump.target);\r\n            } else {\r\n                if(jump.nodeType == TypeScript.NodeType.Break) {\r\n                    this.reportParseError(\"break statement requires enclosing loop or switch\");\r\n                } else {\r\n                    this.reportParseError(\"continue statement requires enclosing loop\");\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.setNonInteractive = function () {\r\n            this.errorRecovery = false;\r\n        };\r\n        Parser.prototype.setErrorRecovery = function (outf, l, c) {\r\n            this.outfile = outf;\r\n            this.cursorLine = l;\r\n            this.cursorColumn = c;\r\n            this.cursorState = ParseState.None;\r\n            this.errorRecovery = true;\r\n        };\r\n        Parser.prototype.posMatchesCursor = function (pos) {\r\n            var lineCol = {\r\n                line: -1,\r\n                col: -1\r\n            };\r\n            this.getSourceLineCol(lineCol, pos);\r\n            return (lineCol.line == this.cursorLine) && (lineCol.col == this.cursorColumn);\r\n        };\r\n        Parser.prototype.getSourceLineCol = function (lineCol, minChar) {\r\n            TypeScript.getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);\r\n        };\r\n        Parser.prototype.createRef = function (text, minChar) {\r\n            var id = new TypeScript.Identifier(text);\r\n            id.minChar = minChar;\r\n            return id;\r\n        };\r\n        Parser.prototype.reportParseStyleError = function (message) {\r\n            this.reportParseError(\"STYLE: \" + message);\r\n        };\r\n        Parser.prototype.reportParseError = function (message, startPos, pos) {\r\n            if (typeof startPos === \"undefined\") { startPos = this.scanner.startPos; }\r\n            if (typeof pos === \"undefined\") { pos = this.scanner.pos; }\r\n            var len = Math.max(1, pos - startPos);\r\n            if(this.errorCallback) {\r\n                this.errorCallback(startPos, len, message, this.currentUnitIndex);\r\n            } else {\r\n                if(this.errorRecovery) {\r\n                    var lineCol = {\r\n                        line: -1,\r\n                        col: -1\r\n                    };\r\n                    this.getSourceLineCol(lineCol, startPos);\r\n                    if(this.outfile) {\r\n                        this.outfile.WriteLine(\"// \" + this.fname + \" (\" + lineCol.line + \",\" + lineCol.col + \"): \" + message);\r\n                    }\r\n                } else {\r\n                    throw new SyntaxError(this.fname + \" (\" + this.scanner.line + \",\" + this.scanner.col + \"): \" + message);\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.chkNxtTok = function (tokenId, errorText, errorRecoverySet) {\r\n            this.tok = this.scanner.scan();\r\n            this.chkCurTok(tokenId, errorText, errorRecoverySet);\r\n        };\r\n        Parser.prototype.skip = function (errorRecoverySet) {\r\n            errorRecoverySet |= TypeScript.ErrorRecoverySet.EOF;\r\n            var ersTok = TypeScript.ErrorRecoverySet.None;\r\n            var tokenInfo = TypeScript.lookupToken(this.tok.tokenId);\r\n            if(tokenInfo != undefined) {\r\n                ersTok = tokenInfo.ers;\r\n            }\r\n            var pendingRightCurlies = 0;\r\n            while(((ersTok & errorRecoverySet) == TypeScript.ErrorRecoverySet.None) || (this.tok.tokenId == TypeScript.TokenID.RCurly) && (pendingRightCurlies > 0)) {\r\n                if(this.tok.tokenId == TypeScript.TokenID.LCurly) {\r\n                    pendingRightCurlies++;\r\n                } else {\r\n                    if(this.tok.tokenId == TypeScript.TokenID.RCurly) {\r\n                        pendingRightCurlies--;\r\n                    }\r\n                }\r\n                this.tok = this.scanner.scan();\r\n                ersTok = TypeScript.ErrorRecoverySet.None;\r\n                tokenInfo = TypeScript.lookupToken(this.tok.tokenId);\r\n                if(tokenInfo != undefined) {\r\n                    ersTok = tokenInfo.ers;\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.chkCurTok = function (tokenId, errorText, errorRecoverySet) {\r\n            if(this.tok.tokenId != tokenId) {\r\n                this.reportParseError(errorText);\r\n                if(this.errorRecovery) {\r\n                    this.skip(errorRecoverySet);\r\n                }\r\n            } else {\r\n                this.tok = this.scanner.scan();\r\n            }\r\n        };\r\n        Parser.prototype.pushDeclLists = function () {\r\n            this.staticsLists.push(new TypeScript.ASTList());\r\n            this.varLists.push(new TypeScript.ASTList());\r\n            this.scopeLists.push(new TypeScript.ASTList());\r\n        };\r\n        Parser.prototype.popDeclLists = function () {\r\n            this.staticsLists.pop();\r\n            this.varLists.pop();\r\n            this.scopeLists.pop();\r\n        };\r\n        Parser.prototype.topVarList = function () {\r\n            return this.varLists[this.varLists.length - 1];\r\n        };\r\n        Parser.prototype.topScopeList = function () {\r\n            return this.scopeLists[this.scopeLists.length - 1];\r\n        };\r\n        Parser.prototype.topStaticsList = function () {\r\n            return this.staticsLists[this.staticsLists.length - 1];\r\n        };\r\n        Parser.prototype.parseComment = function (comment) {\r\n            if(comment) {\r\n                var c = new TypeScript.Comment(comment.value, comment.isBlock, comment.endsLine);\r\n                c.minChar = comment.startPos;\r\n                c.limChar = comment.startPos + comment.value.length;\r\n                if(!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == \"///\") {\r\n                    var dependencyPath = TypeScript.getAdditionalDependencyPath(comment.value);\r\n                    if(dependencyPath) {\r\n                        this.amdDependencies.push(dependencyPath);\r\n                    }\r\n                }\r\n                return c;\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n        Parser.prototype.parseCommentsInner = function (comments) {\r\n            if(comments) {\r\n                var commentASTs = new Array();\r\n                for(var i = 0; i < comments.length; i++) {\r\n                    commentASTs.push(this.parseComment(comments[i]));\r\n                }\r\n                return commentASTs;\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n        Parser.prototype.parseComments = function () {\r\n            var comments = this.scanner.getComments();\r\n            return this.parseCommentsInner(comments);\r\n        };\r\n        Parser.prototype.parseCommentsForLine = function (line) {\r\n            var comments = this.scanner.getCommentsForLine(line);\r\n            return this.parseCommentsInner(comments);\r\n        };\r\n        Parser.prototype.combineComments = function (comment1, comment2) {\r\n            if(comment1 == null) {\r\n                return comment2;\r\n            } else {\r\n                if(comment2 == null) {\r\n                    return comment1;\r\n                } else {\r\n                    return comment1.concat(comment2);\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.parseEnumDecl = function (errorRecoverySet, modifiers) {\r\n            var leftCurlyCount = this.scanner.leftCurlyCount;\r\n            var rightCurlyCount = this.scanner.rightCurlyCount;\r\n            var name = null;\r\n            if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                name = new TypeScript.Identifier(this.tok.getText());\r\n                name.minChar = this.scanner.startPos;\r\n                name.limChar = this.scanner.pos;\r\n                this.tok = this.scanner.scan();\r\n            } else {\r\n                this.reportParseError(\"Enum declaration requires identifier\");\r\n                if(this.errorRecovery) {\r\n                    name = new TypeScript.MissingIdentifier();\r\n                    name.minChar = this.scanner.startPos;\r\n                    name.limChar = this.scanner.startPos;\r\n                    name.flags |= TypeScript.ASTFlags.Error;\r\n                }\r\n            }\r\n            var membersMinChar = this.scanner.startPos;\r\n            this.chkCurTok(TypeScript.TokenID.LCurly, \"Expected '{'\", errorRecoverySet | TypeScript.ErrorRecoverySet.ID);\r\n            this.pushDeclLists();\r\n            var members = new TypeScript.ASTList();\r\n            members.minChar = membersMinChar;\r\n            var mapDecl = new TypeScript.VarDecl(new TypeScript.Identifier(\"_map\"), 0);\r\n            mapDecl.varFlags |= TypeScript.VarFlags.Exported;\r\n            mapDecl.varFlags |= TypeScript.VarFlags.Private;\r\n            mapDecl.varFlags |= (TypeScript.VarFlags.Property | TypeScript.VarFlags.Public);\r\n            mapDecl.init = new TypeScript.UnaryExpression(TypeScript.NodeType.ArrayLit, null);\r\n            members.append(mapDecl);\r\n            var lastValue = null;\r\n            for(; ; ) {\r\n                var minChar = this.scanner.startPos;\r\n                var limChar;\r\n                var memberName = null;\r\n                var memberValue = null;\r\n                var preComments = null;\r\n                var postComments = null;\r\n                if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToIDName(this.tok)) {\r\n                    memberName = new TypeScript.Identifier(this.tok.getText());\r\n                    memberName.minChar = this.scanner.startPos;\r\n                    memberName.limChar = this.scanner.pos;\r\n                } else {\r\n                    if(this.tok.tokenId == TypeScript.TokenID.RCurly) {\r\n                        break;\r\n                    } else {\r\n                        this.reportParseError(\"Expected identifer of enum member\");\r\n                        if(this.errorRecovery) {\r\n                            memberName = new TypeScript.MissingIdentifier();\r\n                            memberName.minChar = this.scanner.startPos;\r\n                            memberName.limChar = this.scanner.startPos;\r\n                            memberName.flags |= TypeScript.ASTFlags.Error;\r\n                        }\r\n                    }\r\n                }\r\n                limChar = this.scanner.pos;\r\n                preComments = this.parseComments();\r\n                this.tok = this.scanner.scan();\r\n                postComments = this.parseComments();\r\n                if(this.tok.tokenId == TypeScript.TokenID.Asg) {\r\n                    this.tok = this.scanner.scan();\r\n                    memberValue = this.parseExpr(errorRecoverySet, TypeScript.OperatorPrecedence.Cma, true, TypeContext.NoTypes);\r\n                    lastValue = memberValue;\r\n                    limChar = memberValue.limChar;\r\n                } else {\r\n                    if(lastValue == null) {\r\n                        memberValue = new TypeScript.NumberLiteral(0);\r\n                        lastValue = memberValue;\r\n                    } else {\r\n                        memberValue = new TypeScript.NumberLiteral(lastValue.value + 1);\r\n                        lastValue = memberValue;\r\n                    }\r\n                    var map = new TypeScript.BinaryExpression(TypeScript.NodeType.Asg, new TypeScript.BinaryExpression(TypeScript.NodeType.Index, new TypeScript.Identifier(\"_map\"), memberValue), new TypeScript.StringLiteral('\"' + memberName.text + '\"'));\r\n                    members.append(map);\r\n                }\r\n                var member = new TypeScript.VarDecl(memberName, this.nestingLevel);\r\n                member.minChar = minChar;\r\n                member.limChar = limChar;\r\n                member.init = memberValue;\r\n                member.typeExpr = new TypeScript.TypeReference(this.createRef(name.text, -1), 0);\r\n                member.varFlags |= (TypeScript.VarFlags.Readonly | TypeScript.VarFlags.Property);\r\n                if(memberValue.nodeType == TypeScript.NodeType.NumberLit) {\r\n                    member.varFlags |= TypeScript.VarFlags.Constant;\r\n                }\r\n                member.preComments = preComments;\r\n                members.append(member);\r\n                member.postComments = postComments;\r\n                member.varFlags |= TypeScript.VarFlags.Exported;\r\n                if(this.tok.tokenId == TypeScript.TokenID.Comma) {\r\n                    this.tok = this.scanner.scan();\r\n                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));\r\n                    if((this.tok.tokenId == TypeScript.TokenID.ID) || (TypeScript.convertTokToIDName(this.tok))) {\r\n                        continue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n            members.limChar = this.scanner.lastTokenLimChar();\r\n            var modDecl = new TypeScript.ModuleDecl(name, members, this.topVarList(), this.topScopeList());\r\n            modDecl.modFlags |= TypeScript.ModuleFlags.IsEnum;\r\n            this.popDeclLists();\r\n            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\r\n            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\r\n            return modDecl;\r\n        };\r\n        Parser.prototype.parseDottedName = function (enclosedList) {\r\n            this.tok = this.scanner.scan();\r\n            if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                var id = new TypeScript.Identifier(this.tok.getText());\r\n                id.preComments = this.parseComments();\r\n                enclosedList[enclosedList.length] = id;\r\n                id.minChar = this.scanner.startPos;\r\n                id.limChar = this.scanner.pos;\r\n                this.tok = this.scanner.scan();\r\n                if(this.tok.tokenId == TypeScript.TokenID.Dot) {\r\n                    this.parseDottedName(enclosedList);\r\n                }\r\n            } else {\r\n                this.reportParseError(\"need identifier after '.'\");\r\n            }\r\n        };\r\n        Parser.prototype.isValidImportPath = function (importPath) {\r\n            importPath = TypeScript.stripQuotes(importPath);\r\n            if(!importPath || importPath.indexOf(':') != -1 || importPath.indexOf('\\\\') != -1 || importPath.charAt(0) == '/') {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        Parser.prototype.parseImportDecl = function (errorRecoverySet, modifiers) {\r\n            var name = null;\r\n            var alias = null;\r\n            var importDecl = null;\r\n            var minChar = this.scanner.startPos;\r\n            var isDynamicImport = false;\r\n            this.tok = this.scanner.scan();\r\n            if(this.tok.tokenId == TypeScript.TokenID.ID || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                name = new TypeScript.Identifier(this.tok.getText());\r\n            } else {\r\n                this.reportParseError(\"Expected identifer after 'import'\");\r\n                name = new TypeScript.MissingIdentifier();\r\n            }\r\n            name.minChar = this.scanner.startPos;\r\n            name.limChar = this.scanner.pos;\r\n            this.tok = this.scanner.scan();\r\n            this.chkCurTok(TypeScript.TokenID.Asg, \"Expected =\", errorRecoverySet | TypeScript.ErrorRecoverySet.ID);\r\n            var aliasPreComments = this.parseComments();\r\n            var limChar;\r\n            if(this.tok.tokenId == TypeScript.TokenID.ID || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                if(this.tok.tokenId == TypeScript.TokenID.MODULE) {\r\n                    limChar = this.scanner.pos;\r\n                    this.tok = this.scanner.scan();\r\n                    if(this.tok.tokenId == TypeScript.TokenID.LParen) {\r\n                        this.tok = this.scanner.scan();\r\n                        if(this.tok.tokenId == TypeScript.TokenID.QString || this.tok.tokenId == TypeScript.TokenID.ID || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                            if(this.tok.tokenId == TypeScript.TokenID.QString) {\r\n                                if(this.topLevel) {\r\n                                    this.hasTopLevelImportOrExport = true;\r\n                                }\r\n                                var aliasText = this.tok.getText();\r\n                                if(!this.isValidImportPath(aliasText)) {\r\n                                    this.reportParseError(\"Invalid import path\");\r\n                                }\r\n                                alias = new TypeScript.Identifier(aliasText);\r\n                                alias.minChar = this.scanner.startPos;\r\n                                alias.limChar = this.scanner.pos;\r\n                                isDynamicImport = true;\r\n                                this.tok = this.scanner.scan();\r\n                                alias.preComments = aliasPreComments;\r\n                            } else {\r\n                                alias = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, TypeScript.OperatorPrecedence.Asg, true, TypeContext.NoTypes);\r\n                                alias.preComments = aliasPreComments;\r\n                            }\r\n                        }\r\n                        limChar = this.scanner.pos;\r\n                        this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.ID);\r\n                        if(alias) {\r\n                            alias.postComments = this.parseComments();\r\n                        }\r\n                        if(this.tok.tokenId == TypeScript.TokenID.SColon) {\r\n                            limChar = this.scanner.pos;\r\n                            this.tok = this.scanner.scan();\r\n                        }\r\n                    }\r\n                } else {\r\n                    alias = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, TypeScript.OperatorPrecedence.Asg, true, TypeContext.NoTypes);\r\n                    limChar = this.scanner.pos;\r\n                }\r\n            } else {\r\n                this.reportParseError(\"Expected module name\");\r\n                alias = new TypeScript.MissingIdentifier();\r\n                alias.minChar = this.scanner.startPos;\r\n                alias.limChar = this.scanner.startPos;\r\n                alias.flags |= TypeScript.ASTFlags.Error;\r\n                limChar = alias.limChar;\r\n            }\r\n            importDecl = new TypeScript.ImportDecl(name, alias);\r\n            importDecl.isDynamicImport = isDynamicImport;\r\n            if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                importDecl.varFlags |= TypeScript.VarFlags.Exported;\r\n            }\r\n            importDecl.minChar = minChar;\r\n            importDecl.limChar = limChar;\r\n            return importDecl;\r\n        };\r\n        Parser.prototype.parseModuleDecl = function (errorRecoverySet, modifiers) {\r\n            var leftCurlyCount = this.scanner.leftCurlyCount;\r\n            var rightCurlyCount = this.scanner.rightCurlyCount;\r\n            var svAmbient = this.ambientModule;\r\n            var svTopLevel = this.topLevel;\r\n            this.topLevel = false;\r\n            if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                this.ambientModule = true;\r\n            }\r\n            this.tok = this.scanner.scan();\r\n            var name = null;\r\n            var enclosedList = null;\r\n            this.pushDeclLists();\r\n            var modulePreComments = this.parseComments();\r\n            var minChar = this.scanner.startPos;\r\n            var isDynamicMod = false;\r\n            if((this.tok.tokenId == TypeScript.TokenID.ID) || (this.tok.tokenId == TypeScript.TokenID.QString) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                var nameText = this.tok.getText();\r\n                if(this.tok.tokenId == TypeScript.TokenID.QString) {\r\n                    isDynamicMod = true;\r\n                    if(!this.ambientModule) {\r\n                        this.reportParseError(\"Only ambient dynamic modules may have string literal names\");\r\n                    }\r\n                }\r\n                name = new TypeScript.Identifier(nameText);\r\n                name.minChar = this.scanner.startPos;\r\n                name.limChar = this.scanner.pos;\r\n                this.tok = this.scanner.scan();\r\n            } else {\r\n                if(this.tok.tokenId == TypeScript.TokenID.LCurly) {\r\n                    this.reportParseError(\"Module name missing\");\r\n                    name = new TypeScript.Identifier(\"\");\r\n                    name.minChar = minChar;\r\n                    name.limChar = minChar;\r\n                }\r\n            }\r\n            if(this.tok.tokenId == TypeScript.TokenID.Dot) {\r\n                enclosedList = new Array();\r\n                this.parseDottedName(enclosedList);\r\n            }\r\n            if(name == null) {\r\n                name = new TypeScript.MissingIdentifier();\r\n            }\r\n            var moduleBody = new TypeScript.ASTList();\r\n            var bodyMinChar = this.scanner.startPos;\r\n            this.chkCurTok(TypeScript.TokenID.LCurly, \"Expected '{'\", errorRecoverySet | TypeScript.ErrorRecoverySet.ID);\r\n            this.parseStmtList(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, moduleBody, true, true, TypeScript.AllowedElements.ModuleMembers, modifiers);\r\n            moduleBody.minChar = bodyMinChar;\r\n            moduleBody.limChar = this.scanner.pos;\r\n            this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n            var limChar = this.scanner.pos;\r\n            var moduleDecl;\r\n            if(enclosedList && (enclosedList.length > 0)) {\r\n                var len = enclosedList.length;\r\n                var innerName = enclosedList[len - 1];\r\n                var innerDecl = new TypeScript.ModuleDecl(innerName, moduleBody, this.topVarList(), this.topScopeList());\r\n                if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                    innerDecl.modFlags |= TypeScript.ModuleFlags.Ambient;\r\n                }\r\n                innerDecl.modFlags |= TypeScript.ModuleFlags.Exported;\r\n                innerDecl.minChar = minChar;\r\n                innerDecl.limChar = limChar;\r\n                this.popDeclLists();\r\n                var outerModBod;\r\n                for(var i = len - 2; i >= 0; i--) {\r\n                    outerModBod = new TypeScript.ASTList();\r\n                    outerModBod.append(innerDecl);\r\n                    innerName = enclosedList[i];\r\n                    innerDecl = new TypeScript.ModuleDecl(innerName, outerModBod, new TypeScript.ASTList(), new TypeScript.ASTList());\r\n                    outerModBod.minChar = innerDecl.minChar = minChar;\r\n                    outerModBod.limChar = innerDecl.limChar = limChar;\r\n                    if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                        innerDecl.modFlags |= TypeScript.ModuleFlags.Ambient;\r\n                    }\r\n                    innerDecl.modFlags |= TypeScript.ModuleFlags.Exported;\r\n                }\r\n                outerModBod = new TypeScript.ASTList();\r\n                outerModBod.append(innerDecl);\r\n                outerModBod.minChar = minChar;\r\n                outerModBod.limChar = limChar;\r\n                moduleDecl = new TypeScript.ModuleDecl(name, outerModBod, new TypeScript.ASTList(), new TypeScript.ASTList());\r\n            } else {\r\n                moduleDecl = new TypeScript.ModuleDecl(name, moduleBody, this.topVarList(), this.topScopeList());\r\n                this.popDeclLists();\r\n            }\r\n            if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                moduleDecl.modFlags |= TypeScript.ModuleFlags.Ambient;\r\n            }\r\n            if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                moduleDecl.modFlags |= TypeScript.ModuleFlags.Exported;\r\n            }\r\n            if(isDynamicMod) {\r\n                moduleDecl.modFlags |= TypeScript.ModuleFlags.IsDynamic;\r\n            }\r\n            moduleDecl.preComments = modulePreComments;\r\n            moduleDecl.postComments = this.parseComments();\r\n            this.ambientModule = svAmbient;\r\n            this.topLevel = svTopLevel;\r\n            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\r\n            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\r\n            return moduleDecl;\r\n        };\r\n        Parser.prototype.parseTypeReferenceTail = function (errorRecoverySet, minChar, term) {\r\n            var result = new TypeScript.TypeReference(term, 0);\r\n            result.minChar = minChar;\r\n            while(this.tok.tokenId == TypeScript.TokenID.LBrack) {\r\n                this.tok = this.scanner.scan();\r\n                result.arrayCount++;\r\n                this.chkCurTok(TypeScript.TokenID.RBrack, \"Expected ']'\", errorRecoverySet | TypeScript.ErrorRecoverySet.LBrack);\r\n            }\r\n            result.limChar = this.scanner.lastTokenLimChar();\r\n            return result;\r\n        };\r\n        Parser.prototype.parseNamedType = function (errorRecoverySet, minChar, term, tail) {\r\n            this.tok = this.scanner.scan();\r\n            if(this.tok.tokenId == TypeScript.TokenID.Dot) {\r\n                var curpos = this.scanner.pos;\r\n                this.tok = this.scanner.scan();\r\n                if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                    var op2 = new TypeScript.Identifier(this.tok.getText());\r\n                    op2.minChar = this.scanner.startPos;\r\n                    op2.limChar = this.scanner.pos;\r\n                    var dotNode = new TypeScript.BinaryExpression(TypeScript.NodeType.Dot, term, op2);\r\n                    dotNode.minChar = term.minChar;\r\n                    dotNode.limChar = op2.limChar;\r\n                    return this.parseNamedType(errorRecoverySet, minChar, dotNode, tail);\r\n                } else {\r\n                    this.reportParseError(\"need identifier after '.'\");\r\n                    if(this.errorRecovery) {\r\n                        term.flags |= TypeScript.ASTFlags.DotLHS;\r\n                        term.limChar = this.scanner.lastTokenLimChar();\r\n                        return term;\r\n                    } else {\r\n                        var eop2 = new TypeScript.MissingIdentifier();\r\n                        eop2.minChar = this.scanner.pos;\r\n                        eop2.limChar = this.scanner.pos;\r\n                        var edotNode = new TypeScript.BinaryExpression(TypeScript.NodeType.Dot, term, eop2);\r\n                        edotNode.flags |= TypeScript.ASTFlags.Error;\r\n                        edotNode.minChar = term.minChar;\r\n                        edotNode.limChar = eop2.limChar;\r\n                        return this.parseNamedType(errorRecoverySet, minChar, edotNode, tail);\r\n                    }\r\n                }\r\n            } else {\r\n                if(tail) {\r\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);\r\n                } else {\r\n                    return term;\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.parseTypeReference = function (errorRecoverySet, allowVoid) {\r\n            var minChar = this.scanner.startPos;\r\n            var isConstructorMember = false;\r\n            switch(this.tok.tokenId) {\r\n                case TypeScript.TokenID.VOID: {\r\n                    if(!allowVoid) {\r\n                        this.reportParseError(\"void not a valid type in this context\");\r\n                    }\r\n\r\n                }\r\n                case TypeScript.TokenID.NUMBER:\r\n                case TypeScript.TokenID.BOOL:\r\n                case TypeScript.TokenID.ANY:\r\n                case TypeScript.TokenID.STRING: {\r\n                    var text = TypeScript.tokenTable[this.tok.tokenId].text;\r\n                    var primId = new TypeScript.Identifier(text);\r\n                    primId.minChar = minChar;\r\n                    primId.limChar = this.scanner.pos;\r\n                    this.tok = this.scanner.scan();\r\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, primId);\r\n                }\r\n\r\n                case TypeScript.TokenID.ID: {\r\n                    var ident = this.createRef(this.tok.getText(), minChar);\r\n                    ident.limChar = this.scanner.pos;\r\n                    return this.parseNamedType(errorRecoverySet, minChar, ident, true);\r\n\r\n                }\r\n                case TypeScript.TokenID.LCurly: {\r\n                    this.tok = this.scanner.scan();\r\n                    var members = new TypeScript.ASTList();\r\n                    members.minChar = minChar;\r\n                    var prevInInterfaceDecl = this.inInterfaceDecl;\r\n                    this.inInterfaceDecl = true;\r\n                    this.parseInterfaceMembers(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, members);\r\n                    this.inInterfaceDecl = prevInInterfaceDecl;\r\n                    this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n                    var interfaceDecl = new TypeScript.TypeDecl(TypeScript.NodeType.Interface, this.anonId, members, null, null, null);\r\n                    interfaceDecl.minChar = minChar;\r\n                    interfaceDecl.limChar = members.limChar;\r\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);\r\n\r\n                }\r\n                case TypeScript.TokenID.NEW: {\r\n                    this.tok = this.scanner.scan();\r\n                    if(this.tok.tokenId != TypeScript.TokenID.LParen) {\r\n                        this.reportParseError(\"Expected '('\");\r\n                    } else {\r\n                        isConstructorMember = true;\r\n                    }\r\n\r\n                }\r\n                case TypeScript.TokenID.LParen: {\r\n                    var formals = new TypeScript.ASTList();\r\n                    var variableArgList = this.parseFormalParameterList(errorRecoverySet | TypeScript.ErrorRecoverySet.RParen, formals, false, true, false, false, false, null);\r\n                    this.chkCurTok(TypeScript.TokenID.Arrow, \"Expected '=>'\", errorRecoverySet);\r\n                    var returnType = this.parseTypeReference(errorRecoverySet, true);\r\n                    var funcDecl = new TypeScript.FuncDecl(null, null, false, formals, null, null, null, TypeScript.NodeType.FuncDecl);\r\n                    funcDecl.returnTypeAnnotation = returnType;\r\n                    funcDecl.variableArgList = variableArgList;\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.Signature;\r\n                    if(isConstructorMember) {\r\n                        funcDecl.fncFlags |= TypeScript.FncFlags.ConstructMember;\r\n                        funcDecl.hint = \"_construct\";\r\n                        funcDecl.classDecl = null;\r\n                    }\r\n                    funcDecl.minChar = minChar;\r\n                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);\r\n                }\r\n\r\n                default: {\r\n                    this.reportParseError(\"Expected type name\");\r\n                    var etr = new TypeScript.TypeReference(null, 0);\r\n                    etr.flags |= TypeScript.ASTFlags.Error;\r\n                    etr.minChar = this.scanner.pos;\r\n                    etr.limChar = this.scanner.pos;\r\n                    return etr;\r\n\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.parseFunctionStatements = function (errorRecoverySet, name, isConstructor, isMethod, args, allowedElements, minChar, requiresSignature, parentModifiers) {\r\n            this.pushDeclLists();\r\n            var svStmtStack = this.stmtStack;\r\n            this.resetStmtStack();\r\n            var bod = null;\r\n            var wasShorthand = false;\r\n            var isAnonLambda = false;\r\n            if(!requiresSignature) {\r\n                bod = new TypeScript.ASTList();\r\n                var bodMinChar = this.scanner.startPos;\r\n                if(this.tok.tokenId == TypeScript.TokenID.Arrow) {\r\n                    if(isMethod) {\r\n                        this.reportParseError(\"'=>' may not be used for class methods\");\r\n                    }\r\n                    wasShorthand = true;\r\n                    this.tok = this.scanner.scan();\r\n                }\r\n                if(wasShorthand && this.tok.tokenId != TypeScript.TokenID.LCurly) {\r\n                    var retExpr = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, TypeScript.OperatorPrecedence.Asg, true, TypeContext.NoTypes);\r\n                    var retStmt = new TypeScript.ReturnStatement();\r\n                    retStmt.returnExpression = retExpr;\r\n                    bod.minChar = bodMinChar;\r\n                    bod.append(retStmt);\r\n                } else {\r\n                    this.state = ParseState.StartStmtList;\r\n                    this.chkCurTok(TypeScript.TokenID.LCurly, \"Expected '{'\", errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);\r\n                    var svInFnc = this.inFnc;\r\n                    isAnonLambda = wasShorthand;\r\n                    this.inFnc = true;\r\n                    this.parseStmtList(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly | TypeScript.ErrorRecoverySet.StmtStart, bod, true, false, allowedElements, parentModifiers);\r\n                    bod.minChar = bodMinChar;\r\n                    bod.limChar = this.scanner.pos;\r\n                    this.inFnc = svInFnc;\r\n                    var ec = new TypeScript.EndCode();\r\n                    ec.minChar = bod.limChar;\r\n                    ec.limChar = ec.minChar;\r\n                    bod.append(ec);\r\n                }\r\n            }\r\n            var funcDecl = new TypeScript.FuncDecl(name, bod, isConstructor, args, this.topVarList(), this.topScopeList(), this.topStaticsList(), TypeScript.NodeType.FuncDecl);\r\n            this.popDeclLists();\r\n            var scopeList = this.topScopeList();\r\n            scopeList.append(funcDecl);\r\n            var staticFuncDecl = false;\r\n            var limChar = this.scanner.pos;\r\n            if(requiresSignature) {\r\n                this.chkCurTok(TypeScript.TokenID.SColon, \"Expected ';'\", errorRecoverySet);\r\n            } else {\r\n                if(!wasShorthand || isAnonLambda) {\r\n                    this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n                    if(isAnonLambda) {\r\n                        funcDecl.fncFlags |= TypeScript.FncFlags.IsFatArrowFunction;\r\n                    }\r\n                } else {\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.IsFatArrowFunction;\r\n                    if(this.tok.tokenId == TypeScript.TokenID.SColon) {\r\n                        this.tok = this.scanner.scan();\r\n                    }\r\n                }\r\n            }\r\n            funcDecl.minChar = minChar;\r\n            funcDecl.limChar = limChar;\r\n            if(!requiresSignature) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Definition;\r\n            }\r\n            this.stmtStack = svStmtStack;\r\n            return funcDecl;\r\n        };\r\n        Parser.prototype.transformAnonymousArgsIntoFormals = function (formals, argList) {\r\n            var _this = this;\r\n            var translateBinExOperand = function (operand) {\r\n                if(operand.nodeType == TypeScript.NodeType.Comma) {\r\n                    _this.transformAnonymousArgsIntoFormals(formals, operand);\r\n                } else {\r\n                    if(operand.nodeType == TypeScript.NodeType.Name || operand.nodeType == TypeScript.NodeType.Asg) {\r\n                        var opArg = operand.nodeType == TypeScript.NodeType.Asg ? (operand).operand1 : operand;\r\n                        var arg = new TypeScript.ArgDecl(opArg);\r\n                        arg.preComments = opArg.preComments;\r\n                        arg.postComments = opArg.postComments;\r\n                        arg.minChar = opArg.minChar;\r\n                        arg.limChar = opArg.limChar;\r\n                        if(TypeScript.hasFlag(opArg.flags, TypeScript.ASTFlags.PossibleOptionalParameter)) {\r\n                            arg.isOptional = true;\r\n                        }\r\n                        if(operand.nodeType == TypeScript.NodeType.Asg) {\r\n                            arg.init = (operand).operand2;\r\n                        }\r\n                        formals.append(arg);\r\n                    } else {\r\n                        _this.reportParseError(\"Invalid lambda argument\");\r\n                    }\r\n                }\r\n            };\r\n            if(argList) {\r\n                if(argList.nodeType == TypeScript.NodeType.Comma) {\r\n                    var commaList = argList;\r\n                    translateBinExOperand(commaList.operand1);\r\n                    translateBinExOperand(commaList.operand2);\r\n                } else {\r\n                    translateBinExOperand(argList);\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.parseFormalParameterList = function (errorRecoverySet, formals, isClassConstr, isSig, isIndexer, isGetter, isSetter, preProcessedLambdaArgs) {\r\n            formals.minChar = this.scanner.startPos;\r\n            if(isIndexer) {\r\n                this.tok = this.scanner.scan();\r\n            } else {\r\n                if(!preProcessedLambdaArgs) {\r\n                    this.chkCurTok(TypeScript.TokenID.LParen, \"Expected '('\", errorRecoverySet | TypeScript.ErrorRecoverySet.RParen);\r\n                }\r\n            }\r\n            var sawEllipsis = false;\r\n            var firstArg = true;\r\n            var hasOptional = false;\r\n            var haveFirstArgID = false;\r\n            var hasPartialArgList = false;\r\n            if(preProcessedLambdaArgs) {\r\n                this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);\r\n                haveFirstArgID = true;\r\n            }\r\n            while(true) {\r\n                var munchedArg = false;\r\n                var argFlags = TypeScript.VarFlags.None;\r\n                var argMinChar = this.scanner.startPos;\r\n                if(this.inferPropertiesFromThisAssignment && this.tok.tokenId == TypeScript.TokenID.THIS) {\r\n                    if(!isClassConstr) {\r\n                        this.reportParseError(\"Instance property declarations using 'this' may only be used in class constructors\");\r\n                    }\r\n                    this.tok = this.scanner.scan();\r\n                    argFlags |= (TypeScript.VarFlags.Public | TypeScript.VarFlags.Property);\r\n                    if(this.currentClassDefinition) {\r\n                        this.currentClassDefinition.varFlags |= TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor;\r\n                    }\r\n                }\r\n                if(this.tok.tokenId == TypeScript.TokenID.PUBLIC) {\r\n                    argFlags |= (TypeScript.VarFlags.Public | TypeScript.VarFlags.Property);\r\n                    if(this.currentClassDefinition) {\r\n                        this.currentClassDefinition.varFlags |= TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor;\r\n                    }\r\n                } else {\r\n                    if(this.tok.tokenId == TypeScript.TokenID.PRIVATE) {\r\n                        argFlags |= (TypeScript.VarFlags.Private | TypeScript.VarFlags.Property);\r\n                        if(this.currentClassDefinition) {\r\n                            this.currentClassDefinition.varFlags |= TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor;\r\n                        }\r\n                    }\r\n                }\r\n                if(argFlags != TypeScript.VarFlags.None) {\r\n                    if(!isClassConstr) {\r\n                        this.reportParseError(\"only constructor parameters can be properties\");\r\n                    }\r\n                    this.tok = this.scanner.scan();\r\n                    if(this.inferPropertiesFromThisAssignment && this.tok.tokenId == TypeScript.TokenID.THIS) {\r\n                        if(!isClassConstr) {\r\n                            this.reportParseError(\"Instance property declarations using 'this' may only be used in class constructors\");\r\n                        }\r\n                        this.tok = this.scanner.scan();\r\n                        this.tok = this.scanner.scan();\r\n                    }\r\n                } else {\r\n                    if(this.tok.tokenId == TypeScript.TokenID.Ellipsis) {\r\n                        sawEllipsis = true;\r\n                        this.tok = this.scanner.scan();\r\n                    }\r\n                }\r\n                var argId = null;\r\n                if(!haveFirstArgID && (this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                    argId = new TypeScript.Identifier(this.tok.getText());\r\n                    argId.minChar = this.scanner.startPos;\r\n                    argId.limChar = this.scanner.pos;\r\n                }\r\n                if(haveFirstArgID || argId) {\r\n                    munchedArg = true;\r\n                    var type = null;\r\n                    var arg = null;\r\n                    if(haveFirstArgID && formals.members.length) {\r\n                        arg = formals.members[formals.members.length - 1];\r\n                        if(arg.isOptional) {\r\n                            hasOptional = true;\r\n                            hasPartialArgList = true;\r\n                        }\r\n                    } else {\r\n                        arg = new TypeScript.ArgDecl(argId);\r\n                        if(isGetter) {\r\n                            this.reportParseError(\"Property getters may not take any arguments\");\r\n                        }\r\n                        if(isSetter && !firstArg) {\r\n                            this.reportParseError(\"Property setters may only take one argument\");\r\n                        }\r\n                        arg.minChar = argMinChar;\r\n                        arg.preComments = this.parseComments();\r\n                        this.tok = this.scanner.scan();\r\n                    }\r\n                    if(this.tok.tokenId == TypeScript.TokenID.QMark) {\r\n                        arg.isOptional = true;\r\n                        hasOptional = true;\r\n                        this.tok = this.scanner.scan();\r\n                    }\r\n                    if(this.tok.tokenId == TypeScript.TokenID.Colon) {\r\n                        this.tok = this.scanner.scan();\r\n                        type = this.parseTypeReference(errorRecoverySet, false);\r\n                        if(preProcessedLambdaArgs) {\r\n                            hasPartialArgList = true;\r\n                        }\r\n                    }\r\n                    if(this.tok.tokenId == TypeScript.TokenID.Asg) {\r\n                        if(isSig) {\r\n                            this.reportParseError(\"Arguments in signatures may not have default values\");\r\n                        }\r\n                        hasOptional = true;\r\n                        this.tok = this.scanner.scan();\r\n                        arg.init = this.parseExpr(TypeScript.ErrorRecoverySet.Comma | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, false, TypeContext.NoTypes);\r\n                    }\r\n                    if(hasOptional && !arg.isOptionalArg() && !sawEllipsis) {\r\n                        this.reportParseError(\"Optional parameters may only be followed by other optional parameters\");\r\n                    }\r\n                    if(sawEllipsis && arg.isOptionalArg()) {\r\n                        this.reportParseError(\"Varargs may not be optional or have default parameters\");\r\n                    }\r\n                    arg.postComments = this.parseComments();\r\n                    arg.typeExpr = type;\r\n                    arg.limChar = this.scanner.lastTokenLimChar();\r\n                    arg.varFlags |= argFlags;\r\n                    if(!haveFirstArgID) {\r\n                        formals.append(arg);\r\n                    } else {\r\n                        haveFirstArgID = false;\r\n                    }\r\n                }\r\n                firstArg = false;\r\n                if(this.tok.tokenId == TypeScript.TokenID.Comma) {\r\n                    if((munchedArg) && (!sawEllipsis)) {\r\n                        this.tok = this.scanner.scan();\r\n                        continue;\r\n                    } else {\r\n                        this.reportParseError(\"Unexpected ',' in argument list\");\r\n                        if(this.errorRecovery) {\r\n                            this.tok = this.scanner.scan();\r\n                            continue;\r\n                        }\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if(isIndexer) {\r\n                this.chkCurTok(TypeScript.TokenID.RBrack, \"Expected ']'\", errorRecoverySet | TypeScript.ErrorRecoverySet.LCurly | TypeScript.ErrorRecoverySet.SColon);\r\n            } else {\r\n                if(!preProcessedLambdaArgs || hasPartialArgList) {\r\n                    this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.LCurly | TypeScript.ErrorRecoverySet.SColon);\r\n                }\r\n            }\r\n            formals.limChar = this.scanner.lastTokenLimChar();\r\n            return sawEllipsis;\r\n        };\r\n        Parser.prototype.parseFncDecl = function (errorRecoverySet, isDecl, requiresSignature, isMethod, methodName, indexer, isStatic, markedAsAmbient, modifiers, lambdaArgContext) {\r\n            var leftCurlyCount = this.scanner.leftCurlyCount;\r\n            var rightCurlyCount = this.scanner.rightCurlyCount;\r\n            var prevInConstr = this.parsingClassConstructorDefinition;\r\n            this.parsingClassConstructorDefinition = false;\r\n            var name = null;\r\n            var fnMin = this.scanner.startPos;\r\n            var minChar = this.scanner.pos;\r\n            var prevNestingLevel = this.nestingLevel;\r\n            this.nestingLevel = 0;\r\n            if((!this.style_funcInLoop) && this.inLoop()) {\r\n                this.reportParseStyleError(\"function declaration in loop\");\r\n            }\r\n            if(!isMethod && !isStatic && !indexer && !lambdaArgContext) {\r\n                this.tok = this.scanner.scan();\r\n                this.state = ParseState.StartFncDecl;\r\n                if((this.tok.tokenId != TypeScript.TokenID.ID) && (!TypeScript.convertTokToID(this.tok, this.strictMode))) {\r\n                    if(isDecl) {\r\n                        this.reportParseError(\"Function declaration must include identifier\");\r\n                        this.nestingLevel = prevNestingLevel;\r\n                        return new TypeScript.IncompleteAST(fnMin, this.scanner.pos);\r\n                    }\r\n                } else {\r\n                    name = new TypeScript.Identifier(this.tok.getText());\r\n                    name.minChar = this.scanner.startPos;\r\n                    name.limChar = this.scanner.pos;\r\n                    this.tok = this.scanner.scan();\r\n                }\r\n            } else {\r\n                if(methodName) {\r\n                    name = methodName;\r\n                }\r\n            }\r\n            this.state = ParseState.FncDeclName;\r\n            var args = new TypeScript.ASTList();\r\n            var variableArgList = false;\r\n            var isOverload = false;\r\n            var isGetter = TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Getter);\r\n            var isSetter = TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Setter);\r\n            if((this.tok.tokenId == TypeScript.TokenID.LParen) || (indexer && (this.tok.tokenId == TypeScript.TokenID.LBrack)) || (lambdaArgContext && lambdaArgContext.preProcessedLambdaArgs)) {\r\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, requiresSignature, indexer, isGetter, isSetter, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null);\r\n            }\r\n            this.state = ParseState.FncDeclArgs;\r\n            var returnType = null;\r\n            if(this.tok.tokenId == TypeScript.TokenID.Colon) {\r\n                this.tok = this.scanner.scan();\r\n                if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Setter)) {\r\n                    this.reportParseError(\"Property setters may not declare a return type\");\r\n                }\r\n                returnType = this.parseTypeReference(errorRecoverySet, true);\r\n            }\r\n            if(indexer && args.members.length == 0) {\r\n                this.reportParseError(\"Index signatures require a parameter type to be specified\");\r\n            }\r\n            this.state = ParseState.FncDeclReturnType;\r\n            if(isDecl && !(this.parsingDeclareFile || markedAsAmbient) && (!isMethod || !(this.ambientModule || this.ambientClass || this.inInterfaceDecl)) && this.tok.tokenId == TypeScript.TokenID.SColon) {\r\n                isOverload = true;\r\n                isDecl = false;\r\n                requiresSignature = true;\r\n            }\r\n            var svInFncDecl = this.inFncDecl;\r\n            this.inFncDecl = true;\r\n            var funcDecl = this.parseFunctionStatements(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, name, false, isMethod, args, TypeScript.AllowedElements.FunctionBody, minChar, requiresSignature, TypeScript.Modifiers.None);\r\n            this.inFncDecl = svInFncDecl;\r\n            funcDecl.variableArgList = variableArgList;\r\n            funcDecl.isOverload = isOverload;\r\n            if(!requiresSignature) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Definition;\r\n            }\r\n            if(isStatic) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Static;\r\n            }\r\n            if(requiresSignature) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Signature;\r\n            }\r\n            if(indexer) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.IndexerMember;\r\n            }\r\n            funcDecl.returnTypeAnnotation = returnType;\r\n            if(isMethod) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Method;\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.ClassPropertyMethodExported;\r\n            }\r\n            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\r\n            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\r\n            this.nestingLevel = prevNestingLevel;\r\n            this.parsingClassConstructorDefinition = prevInConstr;\r\n            return funcDecl;\r\n        };\r\n        Parser.prototype.convertToTypeReference = function (ast) {\r\n            var result;\r\n            switch(ast.nodeType) {\r\n                case TypeScript.NodeType.TypeRef: {\r\n                    return ast;\r\n\r\n                }\r\n                case TypeScript.NodeType.Name: {\r\n                    result = new TypeScript.TypeReference(ast, 0);\r\n                    result.minChar = ast.minChar;\r\n                    result.limChar = ast.limChar;\r\n                    return result;\r\n\r\n                }\r\n                case TypeScript.NodeType.Index: {\r\n                    var expr = ast;\r\n                    result = this.convertToTypeReference(expr.operand1);\r\n                    if(result) {\r\n                        result.arrayCount++;\r\n                        result.minChar = expr.minChar;\r\n                        result.limChar = expr.limChar;\r\n                        return result;\r\n                    } else {\r\n                        var etr = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                        return etr;\r\n                    }\r\n                }\r\n\r\n            }\r\n            return null;\r\n        };\r\n        Parser.prototype.parseArgList = function (errorRecoverySet) {\r\n            var args = new TypeScript.ASTList();\r\n            args.minChar = this.scanner.startPos;\r\n            this.tok = this.scanner.scan();\r\n            if(this.tok.tokenId !== TypeScript.TokenID.RParen) {\r\n                while(true) {\r\n                    if(args.members.length > 65535) {\r\n                        this.reportParseError(\"max number of args exceeded\");\r\n                        break;\r\n                    }\r\n                    var arg = this.parseExpr(TypeScript.ErrorRecoverySet.Comma | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, false, TypeContext.NoTypes);\r\n                    args.append(arg);\r\n                    if(this.tok.tokenId != TypeScript.TokenID.Comma) {\r\n                        break;\r\n                    }\r\n                    this.tok = this.scanner.scan();\r\n                }\r\n            }\r\n            args.limChar = this.scanner.pos;\r\n            return args;\r\n        };\r\n        Parser.prototype.parseBaseList = function (extendsList, implementsList, errorRecoverySet, interfaceOnly, isClass) {\r\n            var keyword = true;\r\n            var currentList = extendsList;\r\n            for(; ; ) {\r\n                if(keyword) {\r\n                    if(this.tok.tokenId == TypeScript.TokenID.IMPLEMENTS) {\r\n                        if(interfaceOnly) {\r\n                            this.reportParseError(\"interfaces can not implement other types\");\r\n                        }\r\n                        currentList = implementsList;\r\n                    }\r\n                    this.tok = this.scanner.scan();\r\n                    keyword = false;\r\n                }\r\n                var baseName = null;\r\n                if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                    var minChar = this.scanner.startPos;\r\n                    baseName = new TypeScript.Identifier(this.tok.getText());\r\n                    baseName.minChar = minChar;\r\n                    baseName.limChar = this.scanner.pos;\r\n                    baseName = this.parseNamedType(errorRecoverySet | TypeScript.ErrorRecoverySet.LCurly, minChar, baseName, false);\r\n                } else {\r\n                    this.reportParseError(\"Expected base name\");\r\n                    if(this.errorRecovery) {\r\n                        baseName = new TypeScript.MissingIdentifier();\r\n                        baseName.minChar = this.scanner.pos;\r\n                        baseName.limChar = this.scanner.pos;\r\n                        baseName.flags |= TypeScript.ASTFlags.Error;\r\n                    }\r\n                }\r\n                if(this.tok.tokenId == TypeScript.TokenID.LParen) {\r\n                    if(isClass) {\r\n                        this.reportParseError(\"Base classes may only be initialized via a 'super' call within the constructor body\");\r\n                    }\r\n                    var baseArgs = this.parseArgList(errorRecoverySet | TypeScript.ErrorRecoverySet.RParen);\r\n                    var callNode = new TypeScript.CallExpression(TypeScript.NodeType.Call, baseName, baseArgs);\r\n                    this.tok = this.scanner.scan();\r\n                    callNode.limChar = this.scanner.pos;\r\n                    currentList.append(callNode);\r\n                } else {\r\n                    currentList.append(baseName);\r\n                }\r\n                if(!interfaceOnly && currentList == extendsList && extendsList.members.length > 1) {\r\n                    this.reportParseError(\"A class may only extend one other class\");\r\n                }\r\n                if(this.tok.tokenId == TypeScript.TokenID.Comma) {\r\n                    this.tok = this.scanner.scan();\r\n                    continue;\r\n                } else {\r\n                    if((this.tok.tokenId == TypeScript.TokenID.EXTENDS) || (this.tok.tokenId == TypeScript.TokenID.IMPLEMENTS)) {\r\n                        currentList = extendsList;\r\n                        keyword = true;\r\n                        continue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        Parser.prototype.parseClassDecl = function (errorRecoverySet, minChar, modifiers) {\r\n            var leftCurlyCount = this.scanner.leftCurlyCount;\r\n            var rightCurlyCount = this.scanner.rightCurlyCount;\r\n            if((modifiers & TypeScript.Modifiers.Readonly) != TypeScript.Modifiers.None) {\r\n                this.reportParseError(\"const modifier is implicit for class\");\r\n            }\r\n            if(this.parsingDeclareFile || this.ambientModule) {\r\n                modifiers |= TypeScript.Modifiers.Ambient;\r\n                modifiers |= TypeScript.Modifiers.Exported;\r\n            }\r\n            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & TypeScript.Modifiers.Ambient) != TypeScript.Modifiers.None;\r\n            var svAmbientClass = this.ambientClass;\r\n            this.ambientClass = classIsMarkedAsAmbient;\r\n            this.tok = this.scanner.scan();\r\n            var name = null;\r\n            if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                name = new TypeScript.Identifier(this.tok.getText());\r\n                name.minChar = this.scanner.startPos;\r\n                name.limChar = this.scanner.pos;\r\n                this.tok = this.scanner.scan();\r\n            } else {\r\n                this.reportParseError(\"class missing name\");\r\n                if(this.errorRecovery) {\r\n                    name = new TypeScript.MissingIdentifier();\r\n                    name.minChar = this.scanner.pos;\r\n                    name.limChar = this.scanner.pos;\r\n                    name.flags |= TypeScript.ASTFlags.Error;\r\n                }\r\n            }\r\n            var baseClass = null;\r\n            var interfacesImplemented = null;\r\n            var requiresSignature = false;\r\n            if((this.tok.tokenId == TypeScript.TokenID.EXTENDS) || (this.tok.tokenId == TypeScript.TokenID.IMPLEMENTS)) {\r\n                baseClass = new TypeScript.ASTList();\r\n                interfacesImplemented = new TypeScript.ASTList();\r\n                this.parseBaseList(baseClass, interfacesImplemented, errorRecoverySet, false, true);\r\n            }\r\n            var classDecl = new TypeScript.ClassDecl(name, new TypeScript.ASTList(), baseClass, interfacesImplemented);\r\n            this.currentClassDefinition = classDecl;\r\n            this.parseClassElements(classDecl, errorRecoverySet, modifiers);\r\n            if(this.ambientModule || this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                classDecl.varFlags |= TypeScript.VarFlags.Exported;\r\n            }\r\n            if(this.ambientModule || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                classDecl.varFlags |= TypeScript.VarFlags.Ambient;\r\n            }\r\n            classDecl.varFlags |= TypeScript.VarFlags.Class;\r\n            this.ambientClass = svAmbientClass;\r\n            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\r\n            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\r\n            return classDecl;\r\n        };\r\n        Parser.prototype.parseClassElements = function (classDecl, errorRecoverySet, parentModifiers) {\r\n            var modifiers = parentModifiers;\r\n            var resetModifiers = false;\r\n            var membersMinChar = this.scanner.startPos;\r\n            this.chkCurTok(TypeScript.TokenID.LCurly, \"Expected '{'\", errorRecoverySet);\r\n            this.nestingLevel++;\r\n            var currentMemberMinChar = this.scanner.startPos;\r\n            var wasGetOrSetId = false;\r\n            while(!(this.tok.tokenId == TypeScript.TokenID.RCurly || this.tok.tokenId == TypeScript.TokenID.EOF)) {\r\n                var scanNext = true;\r\n                var publicOrPrivateFlags = TypeScript.Modifiers.Public | TypeScript.Modifiers.Private;\r\n                if(this.tok.tokenId == TypeScript.TokenID.GET) {\r\n                    if(modifiers & TypeScript.Modifiers.Getter) {\r\n                        this.reportParseError(\"Duplicate 'get' declaration in class body\");\r\n                    }\r\n                    if(modifiers & TypeScript.Modifiers.Setter) {\r\n                        this.reportParseError(\"Getter already marked as a setter\");\r\n                    }\r\n                    modifiers |= TypeScript.Modifiers.Getter;\r\n                } else {\r\n                    if(this.tok.tokenId == TypeScript.TokenID.SET) {\r\n                        if(modifiers & TypeScript.Modifiers.Setter) {\r\n                            this.reportParseError(\"Duplicate 'set' declaration in class body\");\r\n                        }\r\n                        if(modifiers & TypeScript.Modifiers.Getter) {\r\n                            this.reportParseError(\"Setter already marked as a getter\");\r\n                        }\r\n                        modifiers |= TypeScript.Modifiers.Setter;\r\n                    } else {\r\n                        if(this.tok.tokenId == TypeScript.TokenID.PRIVATE) {\r\n                            if(modifiers & publicOrPrivateFlags) {\r\n                                this.reportParseError(\"Multiple modifiers may not be applied to class members\");\r\n                            }\r\n                            modifiers |= TypeScript.Modifiers.Private;\r\n                        } else {\r\n                            if(this.tok.tokenId == TypeScript.TokenID.PUBLIC) {\r\n                                if(modifiers & publicOrPrivateFlags) {\r\n                                    this.reportParseError(\"Multiple modifiers may not be applied to class members\");\r\n                                }\r\n                                modifiers |= TypeScript.Modifiers.Public;\r\n                            } else {\r\n                                if(this.tok.tokenId == TypeScript.TokenID.STATIC) {\r\n                                    if(modifiers & TypeScript.Modifiers.Static) {\r\n                                        this.reportParseError(\"Multiple modifiers may not be applied to class members\");\r\n                                    }\r\n                                    modifiers |= TypeScript.Modifiers.Static;\r\n                                } else {\r\n                                    if(this.tok.tokenId == TypeScript.TokenID.CONSTRUCTOR) {\r\n                                        if(modifiers != parentModifiers) {\r\n                                            this.reportParseError(\"Constructors may not have modifiers\");\r\n                                        }\r\n                                        this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);\r\n                                        scanNext = false;\r\n                                        resetModifiers = true;\r\n                                    } else {\r\n                                        if(wasGetOrSetId || this.tok.tokenId == TypeScript.TokenID.ID || TypeScript.convertTokToIDName(this.tok)) {\r\n                                            var idText = wasGetOrSetId ? ((modifiers & TypeScript.Modifiers.Getter) ? \"get\" : \"set\") : this.tok.getText();\r\n                                            var id = new TypeScript.Identifier(idText);\r\n                                            id.minChar = this.scanner.startPos;\r\n                                            id.limChar = this.scanner.pos;\r\n                                            if(wasGetOrSetId) {\r\n                                                modifiers = modifiers ^ ((modifiers & TypeScript.Modifiers.Getter) ? TypeScript.Modifiers.Getter : TypeScript.Modifiers.Setter);\r\n                                                wasGetOrSetId = false;\r\n                                            } else {\r\n                                                this.tok = this.scanner.scan();\r\n                                            }\r\n                                            if(this.tok.tokenId == TypeScript.TokenID.LParen) {\r\n                                                this.parseClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);\r\n                                                scanNext = false;\r\n                                            } else {\r\n                                                if(modifiers & TypeScript.Modifiers.Getter || modifiers & TypeScript.Modifiers.Setter) {\r\n                                                    this.reportParseError(\"Property accessors must be functions\");\r\n                                                }\r\n                                                var varDecl = this.parseClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);\r\n                                                if(varDecl.init && varDecl.init.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                                    if(this.tok.tokenId == TypeScript.TokenID.RCurly) {\r\n                                                        scanNext = false;\r\n                                                    }\r\n                                                } else {\r\n                                                    if(varDecl.init && varDecl.init.nodeType == TypeScript.NodeType.ObjectLit && this.tok.tokenId != TypeScript.TokenID.SColon) {\r\n                                                        scanNext = false;\r\n                                                        varDecl.init.flags |= TypeScript.ASTFlags.AutomaticSemicolon;\r\n                                                    } else {\r\n                                                        if(this.tok.tokenId != TypeScript.TokenID.SColon) {\r\n                                                            this.reportParseError(\"Expected ';'\");\r\n                                                            scanNext = false;\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            resetModifiers = true;\r\n                                        } else {\r\n                                            if(this.tok.tokenId == TypeScript.TokenID.SUPER) {\r\n                                                this.reportParseError(\"Base class initializers must be the first statement in a class definition\");\r\n                                            } else {\r\n                                                if(!wasGetOrSetId && ((modifiers & TypeScript.Modifiers.Getter) || (modifiers & TypeScript.Modifiers.Setter)) && (this.tok.tokenId == TypeScript.TokenID.LParen) || (this.tok.tokenId == TypeScript.TokenID.Asg)) {\r\n                                                    wasGetOrSetId = true;\r\n                                                    scanNext = false;\r\n                                                } else {\r\n                                                    if(this.tok.tokenId != TypeScript.TokenID.SColon) {\r\n                                                        this.reportParseError(\"Unexpected '\" + this.tok.getText() + \"' in class definition\");\r\n                                                        resetModifiers = true;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(scanNext) {\r\n                    this.tok = this.scanner.scan();\r\n                }\r\n                if(resetModifiers) {\r\n                    modifiers = parentModifiers;\r\n                    currentMemberMinChar = this.scanner.startPos;\r\n                    resetModifiers = false;\r\n                }\r\n            }\r\n            var membersLimChar = this.scanner.pos;\r\n            if(this.tok.tokenId == TypeScript.TokenID.RCurly) {\r\n                if(!this.currentClassDefinition.definitionMembers.members.length) {\r\n                    this.currentClassDefinition.preComments = this.parseComments();\r\n                }\r\n                this.tok = this.scanner.scan();\r\n            }\r\n            this.nestingLevel--;\r\n            this.currentClassDefinition.members.minChar = membersMinChar;\r\n            this.currentClassDefinition.members.limChar = membersLimChar;\r\n            this.currentClassDefinition.limChar = membersLimChar;\r\n            this.currentClassDefinition = null;\r\n        };\r\n        Parser.prototype.parseClassConstructorDeclaration = function (minChar, errorRecoverySet, modifiers) {\r\n            this.parsingClassConstructorDefinition = true;\r\n            var isAmbient = this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient);\r\n            var args = new TypeScript.ASTList();\r\n            var variableArgList = false;\r\n            var preComments = this.parseComments();\r\n            this.tok = this.scanner.scan();\r\n            if(this.tok.tokenId == TypeScript.TokenID.LParen) {\r\n                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, isAmbient, false, false, false, null);\r\n                if(args.members.length > 0) {\r\n                    var lastArg = args.members[args.members.length - 1];\r\n                }\r\n            }\r\n            var requiresSignature = isAmbient || this.tok.tokenId == TypeScript.TokenID.SColon;\r\n            if(requiresSignature) {\r\n                for(var i = 0; i < args.members.length; i++) {\r\n                    var arg = args.members[i];\r\n                    if(TypeScript.hasFlag(arg.varFlags, TypeScript.VarFlags.Property)) {\r\n                        this.reportParseError(\"Overload or ambient signatures may not specify parameter properties\");\r\n                    }\r\n                }\r\n            }\r\n            if(!requiresSignature) {\r\n                this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1;\r\n            }\r\n            var constructorFuncDecl = this.parseFunctionStatements(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, this.currentClassDefinition.name, true, false, args, TypeScript.AllowedElements.ClassMembers, minChar, requiresSignature, modifiers);\r\n            constructorFuncDecl.preComments = preComments;\r\n            if(requiresSignature && !isAmbient) {\r\n                constructorFuncDecl.isOverload = true;\r\n            }\r\n            constructorFuncDecl.variableArgList = variableArgList;\r\n            this.currentClassDecl = null;\r\n            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentClassDefinition.name);\r\n            constructorFuncDecl.classDecl = this.currentClassDefinition;\r\n            if(isAmbient) {\r\n                constructorFuncDecl.fncFlags |= TypeScript.FncFlags.Ambient;\r\n            }\r\n            if(requiresSignature) {\r\n                constructorFuncDecl.fncFlags |= TypeScript.FncFlags.Signature;\r\n            }\r\n            if(this.ambientModule || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                constructorFuncDecl.fncFlags |= TypeScript.FncFlags.Exported;\r\n            }\r\n            if(this.currentClassDefinition.constructorDecl) {\r\n                if(!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {\r\n                    this.reportParseError(\"Duplicate constructor definition\");\r\n                }\r\n            }\r\n            if(isAmbient || !constructorFuncDecl.isSignature()) {\r\n                this.currentClassDefinition.constructorDecl = constructorFuncDecl;\r\n            }\r\n            constructorFuncDecl.fncFlags |= TypeScript.FncFlags.ClassMethod;\r\n            this.currentClassDefinition.definitionMembers.members[this.currentClassDefinition.definitionMembers.members.length] = constructorFuncDecl;\r\n            this.parsingClassConstructorDefinition = false;\r\n            constructorFuncDecl.postComments = this.parseComments();\r\n            return constructorFuncDecl;\r\n        };\r\n        Parser.prototype.parseClassMemberVariableDeclaration = function (text, minChar, isDeclaredInConstructor, errorRecoverySet, modifiers) {\r\n            var varDecl = new TypeScript.VarDecl(text, this.nestingLevel);\r\n            varDecl.minChar = minChar;\r\n            var isStatic = false;\r\n            varDecl.preComments = this.parseComments();\r\n            if(this.tok.tokenId == TypeScript.TokenID.Colon) {\r\n                this.tok = this.scanner.scan();\r\n                varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | TypeScript.ErrorRecoverySet.Asg | TypeScript.ErrorRecoverySet.Comma, false);\r\n            }\r\n            if(this.tok.tokenId == TypeScript.TokenID.Asg) {\r\n                if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                    this.reportParseError(\"context does not permit variable initializer\");\r\n                    if(this.errorRecovery) {\r\n                        this.skip(errorRecoverySet);\r\n                        varDecl.flags |= TypeScript.ASTFlags.Error;\r\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\r\n                        return varDecl;\r\n                    }\r\n                }\r\n                this.tok = this.scanner.scan();\r\n                varDecl.init = this.parseExpr(TypeScript.ErrorRecoverySet.Comma | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, true, TypeContext.NoTypes);\r\n                varDecl.limChar = varDecl.init.limChar;\r\n                this.currentClassDefinition.varFlags |= TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor;\r\n            } else {\r\n                varDecl.limChar = this.scanner.pos;\r\n            }\r\n            if(modifiers & TypeScript.Modifiers.Static) {\r\n                varDecl.varFlags |= TypeScript.VarFlags.Static;\r\n                isStatic = true;\r\n            }\r\n            if((modifiers & TypeScript.Modifiers.Private) != TypeScript.Modifiers.None) {\r\n                varDecl.varFlags |= TypeScript.VarFlags.Private;\r\n            } else {\r\n                varDecl.varFlags |= TypeScript.VarFlags.Public;\r\n            }\r\n            varDecl.varFlags |= TypeScript.VarFlags.Property;\r\n            if(isDeclaredInConstructor) {\r\n                varDecl.varFlags |= TypeScript.VarFlags.ClassConstructorProperty;\r\n            }\r\n            if(!isDeclaredInConstructor && !isStatic) {\r\n                varDecl.varFlags |= TypeScript.VarFlags.ClassBodyProperty;\r\n            }\r\n            this.currentClassDefinition.knownMemberNames[text.text] = true;\r\n            if(!isDeclaredInConstructor) {\r\n                this.currentClassDefinition.definitionMembers.members[this.currentClassDefinition.definitionMembers.members.length] = varDecl;\r\n            }\r\n            this.currentClassDefinition.allMemberDefinitions.members[this.currentClassDefinition.allMemberDefinitions.members.length] = varDecl;\r\n            varDecl.postComments = this.parseComments();\r\n            return varDecl;\r\n        };\r\n        Parser.prototype.parseClassMemberFunctionDeclaration = function (methodName, minChar, errorRecoverySet, modifiers) {\r\n            var wasAccessorID = this.prevIDTok != null;\r\n            var isAccessor = TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Getter) || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Setter);\r\n            var isStatic = TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Static);\r\n            var isAmbient = this.ambientModule || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient);\r\n            errorRecoverySet |= TypeScript.ErrorRecoverySet.RParen;\r\n            var preComments = this.parseComments();\r\n            if(isAccessor && (modifiers & TypeScript.Modifiers.Ambient)) {\r\n                this.reportParseError(\"Property accessors may not be declared in ambient classes\");\r\n            }\r\n            var ast = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null);\r\n            if(ast.nodeType == TypeScript.NodeType.Error) {\r\n                return ast;\r\n            }\r\n            var funcDecl = ast;\r\n            funcDecl.preComments = preComments;\r\n            funcDecl.minChar = minChar;\r\n            if(funcDecl.bod !== null) {\r\n                funcDecl.limChar = funcDecl.bod.limChar;\r\n            }\r\n            if(modifiers & TypeScript.Modifiers.Private) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Private;\r\n            } else {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Public;\r\n            }\r\n            if(isStatic) {\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.Static;\r\n            }\r\n            if(isAccessor) {\r\n                if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Getter)) {\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.GetAccessor;\r\n                    funcDecl.hint = \"get\" + funcDecl.name.text;\r\n                } else {\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.SetAccessor;\r\n                    funcDecl.hint = \"set\" + funcDecl.name.text;\r\n                }\r\n                funcDecl.fncFlags |= TypeScript.FncFlags.IsFunctionExpression;\r\n                if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                    this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                }\r\n            }\r\n            funcDecl.fncFlags |= TypeScript.FncFlags.ClassMethod;\r\n            this.currentClassDefinition.knownMemberNames[methodName.text] = true;\r\n            this.currentClassDefinition.definitionMembers.members[this.currentClassDefinition.definitionMembers.members.length] = funcDecl;\r\n            funcDecl.postComments = this.parseComments();\r\n            return funcDecl;\r\n        };\r\n        Parser.prototype.parseInterfaceMember = function (errorRecoverySet) {\r\n            var minChar = this.scanner.startPos;\r\n            var propertyDecl = this.parsePropertyDecl(errorRecoverySet, TypeScript.Modifiers.Public, true, false);\r\n            if(propertyDecl.nodeType == TypeScript.NodeType.VarDecl) {\r\n                this.chkCurTok(TypeScript.TokenID.SColon, \"Expected ';'\", errorRecoverySet);\r\n            }\r\n            if(propertyDecl) {\r\n                propertyDecl.minChar = minChar;\r\n            }\r\n            return propertyDecl;\r\n        };\r\n        Parser.prototype.parseInterfaceMembers = function (errorRecoverySet, members) {\r\n            for(; ; ) {\r\n                switch(this.tok.tokenId) {\r\n                    case TypeScript.TokenID.RCurly:\r\n                    case TypeScript.TokenID.EOF: {\r\n                        members.limChar = this.scanner.pos;\r\n                        return;\r\n\r\n                    }\r\n                }\r\n                var element = this.parseInterfaceMember(errorRecoverySet | TypeScript.ErrorRecoverySet.TypeScriptS);\r\n                if(element) {\r\n                    members.append(element);\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.parseInterfaceDecl = function (errorRecoverySet, modifiers) {\r\n            var leftCurlyCount = this.scanner.leftCurlyCount;\r\n            var rightCurlyCount = this.scanner.rightCurlyCount;\r\n            this.tok = this.scanner.scan();\r\n            var minChar = this.scanner.pos;\r\n            var name = null;\r\n            if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                name = new TypeScript.Identifier(this.tok.getText());\r\n                name.minChar = this.scanner.startPos;\r\n                name.limChar = this.scanner.pos;\r\n                this.tok = this.scanner.scan();\r\n            } else {\r\n                this.reportParseError(\"interface missing name\");\r\n                if(this.errorRecovery) {\r\n                    name = new TypeScript.MissingIdentifier();\r\n                    name.minChar = this.scanner.pos;\r\n                    name.limChar = this.scanner.pos;\r\n                    name.flags |= TypeScript.ASTFlags.Error;\r\n                }\r\n            }\r\n            var interfaces = null;\r\n            if(this.tok.tokenId == TypeScript.TokenID.EXTENDS) {\r\n                interfaces = new TypeScript.ASTList();\r\n                interfaces.minChar = this.scanner.startPos;\r\n                this.parseBaseList(interfaces, null, errorRecoverySet, true, false);\r\n            }\r\n            var membersMinChar = this.scanner.startPos;\r\n            this.chkCurTok(TypeScript.TokenID.LCurly, \"Expected '{'\", errorRecoverySet | TypeScript.ErrorRecoverySet.TypeScriptS);\r\n            var members = new TypeScript.ASTList();\r\n            members.minChar = membersMinChar;\r\n            var prevInInterfaceDecl = this.inInterfaceDecl;\r\n            this.inInterfaceDecl = true;\r\n            this.parseInterfaceMembers(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, members);\r\n            this.inInterfaceDecl = prevInInterfaceDecl;\r\n            this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n            var interfaceDecl = new TypeScript.TypeDecl(TypeScript.NodeType.Interface, name, members, null, interfaces, null);\r\n            if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Private)) {\r\n                interfaceDecl.varFlags |= TypeScript.VarFlags.Private;\r\n            }\r\n            if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Public)) {\r\n                interfaceDecl.varFlags |= TypeScript.VarFlags.Public;\r\n            }\r\n            if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                interfaceDecl.varFlags |= TypeScript.VarFlags.Exported;\r\n            }\r\n            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\r\n            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\r\n            return interfaceDecl;\r\n        };\r\n        Parser.prototype.makeVarDecl = function (id, nest) {\r\n            var varDecl = new TypeScript.VarDecl(id, nest);\r\n            var currentVarList = this.topVarList();\r\n            if(currentVarList) {\r\n                currentVarList.append(varDecl);\r\n            }\r\n            return varDecl;\r\n        };\r\n        Parser.prototype.parsePropertyDecl = function (errorRecoverySet, modifiers, requireSignature, isStatic) {\r\n            var text = null;\r\n            var minChar = this.scanner.startPos;\r\n            var nameLimChar = minChar;\r\n            var isNew = false;\r\n            var isIndexer = false;\r\n            var wasAccessorID = this.prevIDTok != null;\r\n            var isAccessor = TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Getter) || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Setter);\r\n            if(this.parsingDeclareFile || this.ambientModule || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                requireSignature = true;\r\n            }\r\n            if(this.tok.tokenId == TypeScript.TokenID.LParen && !wasAccessorID) {\r\n                if(!requireSignature && !isStatic) {\r\n                    this.reportParseError(\"Expected identifier in property declaration\");\r\n                    if(this.errorRecovery) {\r\n                        this.skip(errorRecoverySet);\r\n                        text = new TypeScript.MissingIdentifier();\r\n                    }\r\n                }\r\n            } else {\r\n                if(this.tok.tokenId == TypeScript.TokenID.NEW) {\r\n                    if(requireSignature) {\r\n                        this.tok = this.scanner.scan();\r\n                        if(this.tok.tokenId == TypeScript.TokenID.LParen) {\r\n                            isNew = true;\r\n                        }\r\n                    }\r\n                    if(!isNew) {\r\n                        if(!requireSignature) {\r\n                            this.tok = this.scanner.scan();\r\n                        }\r\n                        text = new TypeScript.Identifier(\"new\");\r\n                        text.minChar = this.scanner.pos - 3;\r\n                        text.limChar = this.scanner.pos;\r\n                        nameLimChar = this.scanner.pos;\r\n                    }\r\n                } else {\r\n                    if((this.tok.tokenId == TypeScript.TokenID.LBrack) && requireSignature) {\r\n                        isIndexer = true;\r\n                        text = new TypeScript.Identifier(\"__item\");\r\n                    } else {\r\n                        if((this.tok.tokenId != TypeScript.TokenID.ID) && (!TypeScript.convertTokToIDName(this.tok)) && !wasAccessorID) {\r\n                            this.reportParseError(\"Expected identifier in property declaration\");\r\n                            if(this.errorRecovery) {\r\n                                var eminChar = this.scanner.startPos;\r\n                                var curpos = this.scanner.pos;\r\n                                this.skip(errorRecoverySet & (~TypeScript.ErrorRecoverySet.Comma));\r\n                                if(this.scanner.pos == curpos) {\r\n                                    this.tok = this.scanner.scan();\r\n                                }\r\n                                var epd = new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel);\r\n                                epd.flags |= TypeScript.ASTFlags.Error;\r\n                                epd.minChar = eminChar;\r\n                                epd.limChar = this.scanner.lastTokenLimChar();\r\n                                return epd;\r\n                            }\r\n                        } else {\r\n                            if(wasAccessorID) {\r\n                                text = new TypeScript.Identifier(this.prevIDTok.getText());\r\n                                text.minChar = this.scanner.lastTokenLimChar() - 3;\r\n                                text.limChar = this.scanner.lastTokenLimChar();\r\n                                nameLimChar = text.limChar;\r\n                                if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                    this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                                }\r\n                                if(this.tok.getText() == text.text && this.tok != this.prevIDTok) {\r\n                                    this.tok = this.scanner.scan();\r\n                                }\r\n                                this.prevIDTok = null;\r\n                            } else {\r\n                                text = new TypeScript.Identifier(this.tok.getText());\r\n                                text.minChar = this.scanner.startPos;\r\n                                text.limChar = this.scanner.pos;\r\n                                nameLimChar = this.scanner.pos;\r\n                                this.tok = this.scanner.scan();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(this.tok.tokenId == TypeScript.TokenID.QMark) {\r\n                if(this.inInterfaceDecl && text) {\r\n                    text.flags |= TypeScript.ASTFlags.OptionalName;\r\n                } else {\r\n                    this.reportParseError(\"Optional properties may only be declared on interface or object types\");\r\n                }\r\n                this.tok = this.scanner.scan();\r\n            }\r\n            if((this.tok.tokenId == TypeScript.TokenID.LParen) || (isIndexer && (this.tok.tokenId == TypeScript.TokenID.LBrack))) {\r\n                var ers = errorRecoverySet | TypeScript.ErrorRecoverySet.RParen;\r\n                if(isIndexer) {\r\n                    ers = errorRecoverySet | TypeScript.ErrorRecoverySet.RBrack;\r\n                }\r\n                var ast = this.parseFncDecl(ers, true, requireSignature, !this.inFncDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)), modifiers, null);\r\n                var funcDecl;\r\n                if(ast.nodeType == TypeScript.NodeType.Error) {\r\n                    return ast;\r\n                } else {\r\n                    funcDecl = ast;\r\n                }\r\n                if(funcDecl.name) {\r\n                    funcDecl.name.minChar = minChar;\r\n                    funcDecl.name.limChar = nameLimChar;\r\n                }\r\n                if((modifiers & TypeScript.Modifiers.Public) != TypeScript.Modifiers.None) {\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.Public;\r\n                }\r\n                if((modifiers & TypeScript.Modifiers.Private) != TypeScript.Modifiers.None) {\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.Private;\r\n                }\r\n                if(isStatic) {\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.Static;\r\n                }\r\n                if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.Ambient;\r\n                }\r\n                if(isAccessor) {\r\n                    if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Getter)) {\r\n                        funcDecl.fncFlags |= TypeScript.FncFlags.GetAccessor;\r\n                        funcDecl.hint = \"get\" + funcDecl.name.text;\r\n                    } else {\r\n                        funcDecl.fncFlags |= TypeScript.FncFlags.SetAccessor;\r\n                        funcDecl.hint = \"set\" + funcDecl.name.text;\r\n                    }\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.IsFunctionExpression;\r\n                    if(modifiers & TypeScript.Modifiers.Ambient) {\r\n                        this.reportParseError(\"Property accessors may not be declared in ambient types\");\r\n                    }\r\n                }\r\n                if(text == null) {\r\n                    if(isNew) {\r\n                        funcDecl.fncFlags |= TypeScript.FncFlags.ConstructMember;\r\n                        funcDecl.hint = \"_construct\";\r\n                        funcDecl.classDecl = this.currentClassDecl;\r\n                    } else {\r\n                        funcDecl.hint = \"_call\";\r\n                        funcDecl.fncFlags |= TypeScript.FncFlags.CallMember;\r\n                    }\r\n                }\r\n                return funcDecl;\r\n            } else {\r\n                var varDecl = new TypeScript.VarDecl(text, this.nestingLevel);\r\n                varDecl.minChar = minChar;\r\n                if(this.tok.tokenId == TypeScript.TokenID.Colon) {\r\n                    this.tok = this.scanner.scan();\r\n                    varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | TypeScript.ErrorRecoverySet.Asg | TypeScript.ErrorRecoverySet.Comma, false);\r\n                }\r\n                if(this.tok.tokenId == TypeScript.TokenID.Asg) {\r\n                    if(requireSignature) {\r\n                        this.reportParseError(\"context does not permit variable initializer\");\r\n                        if(this.errorRecovery) {\r\n                            this.skip(errorRecoverySet);\r\n                            varDecl.flags |= TypeScript.ASTFlags.Error;\r\n                            varDecl.limChar = this.scanner.lastTokenLimChar();\r\n                            return varDecl;\r\n                        }\r\n                    }\r\n                    this.tok = this.scanner.scan();\r\n                    varDecl.init = this.parseExpr(TypeScript.ErrorRecoverySet.Comma | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, true, TypeContext.NoTypes);\r\n                    varDecl.limChar = varDecl.init.limChar;\r\n                    if(varDecl.init.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                        var funcDecl = varDecl.init;\r\n                        funcDecl.hint = varDecl.id.text;\r\n                        funcDecl.boundToProperty = varDecl;\r\n                    } else {\r\n                        if(isAccessor) {\r\n                            this.reportParseError(\"Accessors may only be functions\");\r\n                        }\r\n                    }\r\n                } else {\r\n                    varDecl.limChar = this.scanner.pos;\r\n                }\r\n                if((modifiers & TypeScript.Modifiers.Readonly) != TypeScript.Modifiers.None) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Readonly;\r\n                }\r\n                if(isStatic) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Static;\r\n                }\r\n                if((modifiers & TypeScript.Modifiers.Public) != TypeScript.Modifiers.None) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Public;\r\n                }\r\n                if((modifiers & TypeScript.Modifiers.Private) != TypeScript.Modifiers.None) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Private;\r\n                }\r\n                varDecl.varFlags |= TypeScript.VarFlags.Property;\r\n                return varDecl;\r\n            }\r\n        };\r\n        Parser.prototype.parseVarDecl = function (errorRecoverySet, modifiers, allowIn, requireSignature, isStatic) {\r\n            var isConst = TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Readonly);\r\n            var minChar = this.scanner.startPos;\r\n            this.tok = this.scanner.scan();\r\n            var varDecl = null;\r\n            var declList = null;\r\n            var multivar = false;\r\n            var varDeclPreComments = this.parseComments();\r\n            for(; ; ) {\r\n                if((this.tok.tokenId != TypeScript.TokenID.ID) && (!TypeScript.convertTokToID(this.tok, this.strictMode))) {\r\n                    this.reportParseError(\"Expected identifier in variable declaration\");\r\n                    if(this.errorRecovery) {\r\n                        varDecl = new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel);\r\n                        varDecl.minChar = minChar;\r\n                        this.skip(errorRecoverySet);\r\n                        varDecl.flags |= TypeScript.ASTFlags.Error;\r\n                        varDecl.limChar = this.scanner.lastTokenLimChar();\r\n                        return varDecl;\r\n                    }\r\n                }\r\n                var text = this.tok.getText();\r\n                if(this.strictMode && (text == \"eval\")) {\r\n                    this.reportParseError(\"can not name a variable eval in strict mode\");\r\n                }\r\n                varDecl = this.makeVarDecl(new TypeScript.Identifier(text), this.nestingLevel);\r\n                varDecl.id.minChar = this.scanner.startPos;\r\n                varDecl.id.limChar = this.scanner.pos;\r\n                varDecl.preComments = varDeclPreComments;\r\n                if(isStatic) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Static;\r\n                }\r\n                if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Readonly)) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Readonly;\r\n                }\r\n                if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Ambient;\r\n                }\r\n                if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                    varDecl.varFlags |= TypeScript.VarFlags.Exported;\r\n                }\r\n                varDecl.minChar = minChar;\r\n                if(declList) {\r\n                    declList.append(varDecl);\r\n                }\r\n                this.tok = this.scanner.scan();\r\n                if(this.tok.tokenId == TypeScript.TokenID.Colon) {\r\n                    this.tok = this.scanner.scan();\r\n                    var prevInFncDecl = this.inFncDecl;\r\n                    this.inFncDecl = false;\r\n                    varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | TypeScript.ErrorRecoverySet.Asg | TypeScript.ErrorRecoverySet.Comma, false);\r\n                    this.inFncDecl = prevInFncDecl;\r\n                }\r\n                if(this.tok.tokenId == TypeScript.TokenID.Asg) {\r\n                    if(requireSignature) {\r\n                        this.reportParseError(\"context does not permit variable initializer\");\r\n                        if(this.errorRecovery) {\r\n                            this.skip(errorRecoverySet);\r\n                            varDecl.flags |= TypeScript.ASTFlags.Error;\r\n                            return varDecl;\r\n                        }\r\n                    }\r\n                    this.tok = this.scanner.scan();\r\n                    varDecl.init = this.parseExpr(TypeScript.ErrorRecoverySet.Comma | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, allowIn, TypeContext.NoTypes);\r\n                    varDecl.limChar = varDecl.init.limChar;\r\n                    if(varDecl.init.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                        var funcDecl = varDecl.init;\r\n                        funcDecl.hint = varDecl.id.text;\r\n                    }\r\n                } else {\r\n                    if(isConst) {\r\n                        this.reportParseError(\"const declaration requires initializer\");\r\n                    }\r\n                    varDecl.limChar = this.scanner.pos;\r\n                }\r\n                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);\r\n                if(this.tok.tokenId != TypeScript.TokenID.Comma) {\r\n                    if(declList) {\r\n                        declList.limChar = varDecl.limChar;\r\n                        return declList;\r\n                    } else {\r\n                        return varDecl;\r\n                    }\r\n                }\r\n                if(!multivar) {\r\n                    declList = new TypeScript.ASTList();\r\n                    declList.minChar = varDecl.minChar;\r\n                    declList.append(varDecl);\r\n                    multivar = true;\r\n                }\r\n                this.tok = this.scanner.scan();\r\n                minChar = this.scanner.startPos;\r\n            }\r\n        };\r\n        Parser.prototype.parseMemberList = function (errorRecoverySet) {\r\n            var elements = new TypeScript.ASTList();\r\n            if(this.tok.tokenId == TypeScript.TokenID.RCurly) {\r\n                return elements;\r\n            }\r\n            var idHint = null;\r\n            var memberName = null;\r\n            var memberExpr = null;\r\n            var member = null;\r\n            var minChar = this.scanner.startPos;\r\n            var isSet = false;\r\n            var skippedTokenForGetSetId = false;\r\n            var getSetTok = null;\r\n            var getSetStartPos = 0;\r\n            var getSetPos = 0;\r\n            for(; ; ) {\r\n                var accessorPattern = false;\r\n                if(this.tok.tokenId == TypeScript.TokenID.GET || this.tok.tokenId == TypeScript.TokenID.SET) {\r\n                    isSet = this.tok.tokenId == TypeScript.TokenID.SET;\r\n                    getSetTok = this.tok;\r\n                    getSetStartPos = this.scanner.startPos;\r\n                    getSetPos = this.scanner.pos;\r\n                    this.tok = this.scanner.scan();\r\n                    if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToIDName(this.tok)) {\r\n                        idHint = isSet ? \"set\" : \"get\";\r\n                        idHint = idHint + this.tok.getText();\r\n                        memberName = new TypeScript.Identifier(this.tok.getText());\r\n                        memberName.minChar = this.scanner.startPos;\r\n                        accessorPattern = true;\r\n                        if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                            this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                        }\r\n                    } else {\r\n                        if(this.tok.tokenId != TypeScript.TokenID.Colon) {\r\n                            this.reportParseError(\"Expected identifier, string or number as accessor name\");\r\n                        } else {\r\n                            skippedTokenForGetSetId = true;\r\n                            memberName = new TypeScript.Identifier(getSetTok.getText());\r\n                            memberName.minChar = getSetStartPos;\r\n                            memberName.limChar = getSetPos;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToIDName(this.tok)) {\r\n                        idHint = this.tok.getText();\r\n                        memberName = new TypeScript.Identifier(idHint);\r\n                        memberName.minChar = this.scanner.startPos;\r\n                        memberName.limChar = this.scanner.pos;\r\n                    } else {\r\n                        if(this.tok.tokenId == TypeScript.TokenID.QString) {\r\n                            idHint = this.tok.getText();\r\n                            memberName = new TypeScript.StringLiteral(idHint);\r\n                            memberName.minChar = this.scanner.startPos;\r\n                            memberName.limChar = this.scanner.pos;\r\n                        } else {\r\n                            if(this.tok.tokenId == TypeScript.TokenID.NumberLit) {\r\n                                var ntok = this.tok;\r\n                                idHint = ntok.value.toString();\r\n                                memberName = new TypeScript.StringLiteral(idHint);\r\n                                memberName.minChar = this.scanner.startPos;\r\n                                memberName.limChar = this.scanner.pos;\r\n                            } else {\r\n                                this.reportParseError(\"Expected identifier, string or number as member name\");\r\n                                if(this.errorRecovery) {\r\n                                    memberName = new TypeScript.MissingIdentifier();\r\n                                    memberName.minChar = this.scanner.startPos;\r\n                                    memberName.flags |= TypeScript.ASTFlags.Error;\r\n                                    this.skip(errorRecoverySet | TypeScript.ErrorRecoverySet.Comma);\r\n                                    memberName.limChar = this.scanner.lastTokenLimChar();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(!skippedTokenForGetSetId) {\r\n                    this.tok = this.scanner.scan();\r\n                } else {\r\n                    skippedTokenForGetSetId = false;\r\n                }\r\n                if(this.tok.tokenId == TypeScript.TokenID.QMark) {\r\n                    memberName.flags |= TypeScript.ASTFlags.OptionalName;\r\n                    this.tok = this.scanner.scan();\r\n                }\r\n                if(accessorPattern) {\r\n                    var args = new TypeScript.ASTList();\r\n                    this.parseFormalParameterList(errorRecoverySet | TypeScript.ErrorRecoverySet.RParen, args, false, true, false, !isSet, isSet, null);\r\n                    var funcDecl = this.parseFunctionStatements(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, memberName, false, true, args, TypeScript.AllowedElements.FunctionDecls, this.scanner.startPos, false, TypeScript.Modifiers.None);\r\n                    if(isSet && funcDecl.returnTypeAnnotation) {\r\n                        this.reportParseError(\"Property setters may not declare a return type\");\r\n                    }\r\n                    funcDecl.fncFlags |= isSet ? TypeScript.FncFlags.SetAccessor : TypeScript.FncFlags.GetAccessor;\r\n                    funcDecl.fncFlags |= TypeScript.FncFlags.IsFunctionExpression;\r\n                    funcDecl.hint = idHint;\r\n                    memberExpr = funcDecl;\r\n                    member = new TypeScript.BinaryExpression(TypeScript.NodeType.Member, memberName, memberExpr);\r\n                    member.minChar = memberName.minChar;\r\n                    if(memberExpr.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                        var funcDecl = memberExpr;\r\n                        funcDecl.hint = idHint;\r\n                    }\r\n                } else {\r\n                    if(this.tok.tokenId == TypeScript.TokenID.Colon) {\r\n                        this.tok = this.scanner.scan();\r\n                        memberExpr = this.parseExpr(TypeScript.ErrorRecoverySet.Comma | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, true, TypeContext.NoTypes);\r\n                        if(memberExpr.nodeType == TypeScript.NodeType.TypeRef) {\r\n                            this.reportParseError(\"Expected 'new' on array declaration in member definition\");\r\n                        }\r\n                        member = new TypeScript.BinaryExpression(TypeScript.NodeType.Member, memberName, memberExpr);\r\n                        member.minChar = memberName.minChar;\r\n                        if(memberExpr.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                            var funcDecl = memberExpr;\r\n                            funcDecl.hint = idHint;\r\n                        }\r\n                    } else {\r\n                        this.reportParseError(\"Expected ':' in member definition\");\r\n                        if(this.errorRecovery) {\r\n                            this.skip(errorRecoverySet);\r\n                            elements.flags |= TypeScript.ASTFlags.Error;\r\n                            elements.minChar = minChar;\r\n                            elements.limChar = this.scanner.lastTokenLimChar();\r\n                            return elements;\r\n                        }\r\n                    }\r\n                }\r\n                idHint = null;\r\n                elements.append(member);\r\n                member.limChar = this.scanner.lastTokenLimChar();\r\n                if(this.tok.tokenId != TypeScript.TokenID.Comma) {\r\n                    break;\r\n                } else {\r\n                    this.tok = this.scanner.scan();\r\n                }\r\n                if(this.tok.tokenId == TypeScript.TokenID.RCurly) {\r\n                    break;\r\n                }\r\n            }\r\n            if(member) {\r\n                elements.limChar = member.limChar;\r\n            }\r\n            elements.minChar = minChar;\r\n            return elements;\r\n        };\r\n        Parser.prototype.parseArrayList = function (errorRecoverySet) {\r\n            var elements = null;\r\n            if(this.tok.tokenId == TypeScript.TokenID.RBrack) {\r\n                return elements;\r\n            } else {\r\n                elements = new TypeScript.ASTList();\r\n                elements.minChar = this.scanner.startPos;\r\n            }\r\n            var arg;\r\n            for(; ; ) {\r\n                if((this.tok.tokenId == TypeScript.TokenID.Comma) || (this.tok.tokenId == TypeScript.TokenID.RBrack)) {\r\n                    arg = new TypeScript.AST(TypeScript.NodeType.EmptyExpr);\r\n                } else {\r\n                    arg = this.parseExpr(TypeScript.ErrorRecoverySet.Comma | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, true, TypeContext.NoTypes);\r\n                }\r\n                elements.append(arg);\r\n                if(this.tok.tokenId != TypeScript.TokenID.Comma) {\r\n                    break;\r\n                }\r\n                this.tok = this.scanner.scan();\r\n            }\r\n            elements.limChar = this.scanner.lastTokenLimChar();\r\n            return elements;\r\n        };\r\n        Parser.prototype.parseArrayLiteral = function (errorRecoverySet) {\r\n            var arrayLiteral = null;\r\n            arrayLiteral = new TypeScript.UnaryExpression(TypeScript.NodeType.ArrayLit, this.parseArrayList(errorRecoverySet));\r\n            return arrayLiteral;\r\n        };\r\n        Parser.prototype.parseTerm = function (errorRecoverySet, allowCall, typeContext, inCast) {\r\n            var ast = null;\r\n            var sawId = false;\r\n            var inNew = false;\r\n            var minChar = this.scanner.startPos;\r\n            var limChar = this.scanner.pos;\r\n            var parseAsLambda = false;\r\n            switch(this.tok.tokenId) {\r\n                case TypeScript.TokenID.NUMBER:\r\n                case TypeScript.TokenID.BOOL:\r\n                case TypeScript.TokenID.ANY:\r\n                case TypeScript.TokenID.STRING: {\r\n                    var tid = new TypeScript.Identifier(TypeScript.tokenTable[this.tok.tokenId].text);\r\n                    if(TypeScript.hasFlag(typeContext, TypeContext.Primitive)) {\r\n                        ast = new TypeScript.TypeReference(tid, 0);\r\n                        sawId = true;\r\n                    } else {\r\n                        ast = tid;\r\n                        sawId = true;\r\n                    }\r\n                    ast.minChar = minChar;\r\n                    this.tok = this.scanner.scan();\r\n                    limChar = this.scanner.lastTokenLimChar();\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.TokenID.THIS: {\r\n                    ast = new TypeScript.AST(TypeScript.NodeType.This);\r\n                    ast.minChar = minChar;\r\n                    this.tok = this.scanner.scan();\r\n                    limChar = this.scanner.lastTokenLimChar();\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.TokenID.SUPER: {\r\n                    ast = new TypeScript.AST(TypeScript.NodeType.Super);\r\n                    ast.minChar = minChar;\r\n                    this.tok = this.scanner.scan();\r\n                    limChar = this.scanner.lastTokenLimChar();\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.TokenID.TRUE: {\r\n                    ast = new TypeScript.AST(TypeScript.NodeType.True);\r\n                    this.tok = this.scanner.scan();\r\n                    ast.minChar = minChar;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.TokenID.FALSE: {\r\n                    ast = new TypeScript.AST(TypeScript.NodeType.False);\r\n                    this.tok = this.scanner.scan();\r\n                    ast.minChar = minChar;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.TokenID.NULL: {\r\n                    ast = new TypeScript.AST(TypeScript.NodeType.Null);\r\n                    this.tok = this.scanner.scan();\r\n                    ast.minChar = minChar;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.TokenID.NEW: {\r\n                    minChar = this.scanner.pos;\r\n                    this.tok = this.scanner.scan();\r\n                    ast = new TypeScript.CallExpression(TypeScript.NodeType.New, this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast), null);\r\n                    ast.minChar = minChar;\r\n                    limChar = this.scanner.lastTokenLimChar();\r\n                    inNew = true;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.TokenID.FUNCTION: {\r\n                    minChar = this.scanner.pos;\r\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, TypeScript.Modifiers.None, null);\r\n                    (ast).fncFlags |= TypeScript.FncFlags.IsFunctionExpression;\r\n                    ast.minChar = minChar;\r\n                    limChar = this.scanner.lastTokenLimChar();\r\n                    ast.limChar = limChar;\r\n                    break;\r\n\r\n                }\r\n            }\r\n            if(ast == null) {\r\n                if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                    var idText = this.tok.getText();\r\n                    ast = this.createRef(idText, minChar);\r\n                    sawId = true;\r\n                    ast.minChar = minChar;\r\n                    this.tok = this.scanner.scan();\r\n                    if(this.tok.tokenId == TypeScript.TokenID.QMark) {\r\n                        ast.flags |= TypeScript.ASTFlags.PossibleOptionalParameter;\r\n                    } else {\r\n                        if(this.tok.tokenId == TypeScript.TokenID.Arrow) {\r\n                            parseAsLambda = true;\r\n                        }\r\n                    }\r\n                    limChar = this.scanner.lastTokenLimChar();\r\n                }\r\n            }\r\n            if(inCast) {\r\n                this.chkCurTok(TypeScript.TokenID.GT, \"Expected '>'\", errorRecoverySet);\r\n            }\r\n            if(ast == null) {\r\n                switch(this.tok.tokenId) {\r\n                    case TypeScript.TokenID.LParen: {\r\n                        minChar = this.scanner.pos;\r\n                        var prevTokId = this.scanner.previousToken().tokenId;\r\n                        this.tok = this.scanner.scan();\r\n                        var couldBeLambda = prevTokId == TypeScript.TokenID.LParen || prevTokId == TypeScript.TokenID.Comma || prevTokId == TypeScript.TokenID.EQ || prevTokId == TypeScript.TokenID.Colon;\r\n                        if(couldBeLambda && this.tok.tokenId == TypeScript.TokenID.RParen) {\r\n                            parseAsLambda = true;\r\n                            this.tok = this.scanner.scan();\r\n                        } else {\r\n                            ast = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.RParen, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                            limChar = this.scanner.lastTokenLimChar();\r\n                            parseAsLambda = couldBeLambda && (ast.nodeType == TypeScript.NodeType.Name || ast.nodeType == TypeScript.NodeType.Comma) && (this.tok.tokenId == TypeScript.TokenID.Colon || this.tok.tokenId == TypeScript.TokenID.QMark);\r\n                        }\r\n                        if((ast && !parseAsLambda)) {\r\n                            this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet);\r\n                            ast.isParenthesized = true;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.NumberLit: {\r\n                        var numTok = this.tok;\r\n                        this.tok = this.scanner.scan();\r\n                        ast = new TypeScript.NumberLiteral(numTok.value);\r\n                        ast.minChar = minChar;\r\n                        limChar = this.scanner.lastTokenLimChar();\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.QString: {\r\n                        ast = new TypeScript.StringLiteral(this.tok.getText());\r\n                        this.tok = this.scanner.scan();\r\n                        ast.minChar = minChar;\r\n                        limChar = this.scanner.lastTokenLimChar();\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.Regex: {\r\n                        var rtok = this.tok;\r\n                        ast = new TypeScript.RegexLiteral(rtok.regex);\r\n                        this.tok = this.scanner.scan();\r\n                        ast.minChar = minChar;\r\n                        limChar = this.scanner.lastTokenLimChar();\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.LBrack: {\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        ast = this.parseArrayLiteral(TypeScript.ErrorRecoverySet.RBrack | errorRecoverySet);\r\n                        ast.minChar = minChar;\r\n                        limChar = this.scanner.pos;\r\n                        this.chkCurTok(TypeScript.TokenID.RBrack, \"Expected ']'\", errorRecoverySet);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.LCurly: {\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        var members = this.parseMemberList(TypeScript.ErrorRecoverySet.RCurly | errorRecoverySet);\r\n                        this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n                        ast = new TypeScript.UnaryExpression(TypeScript.NodeType.ObjectLit, members);\r\n                        ast.minChar = minChar;\r\n                        limChar = this.scanner.lastTokenLimChar();\r\n                        members.minChar = minChar;\r\n                        members.limChar = limChar;\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.LT: {\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        var term = this.parseTypeReference(TypeScript.ErrorRecoverySet.BinOp, false);\r\n                        this.chkCurTok(TypeScript.TokenID.GT, \"Expected '>'\", errorRecoverySet);\r\n                        ast = new TypeScript.UnaryExpression(TypeScript.NodeType.TypeAssertion, this.parseExpr(errorRecoverySet, TypeScript.OperatorPrecedence.Uni, false, TypeContext.NoTypes));\r\n                        (ast).castTerm = term;\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        if(this.prevExpr && TypeScript.hasFlag(this.prevExpr.flags, TypeScript.ASTFlags.PossibleOptionalParameter)) {\r\n                            parseAsLambda = true;\r\n                            ast = this.prevExpr;\r\n                        } else {\r\n                            this.reportParseError(\"Check format of expression term\");\r\n                            if(this.errorRecovery) {\r\n                                var ident = new TypeScript.MissingIdentifier();\r\n                                ident.minChar = minChar;\r\n                                ident.flags |= TypeScript.ASTFlags.Error;\r\n                                this.skip(errorRecoverySet | TypeScript.ErrorRecoverySet.Postfix);\r\n                                if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                                    ident.text = this.tok.getText();\r\n                                    this.tok = this.scanner.scan();\r\n                                    limChar = this.scanner.lastTokenLimChar();\r\n                                } else {\r\n                                    limChar = this.scanner.lastTokenLimChar();\r\n                                }\r\n                                ast = ident;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            if(parseAsLambda) {\r\n                if(this.tok.tokenId == TypeScript.TokenID.Arrow || this.tok.tokenId == TypeScript.TokenID.Colon || this.tok.tokenId == TypeScript.TokenID.Comma || this.tok.tokenId == TypeScript.TokenID.RParen) {\r\n                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, TypeScript.Modifiers.None, {\r\n                        preProcessedLambdaArgs: ast\r\n                    });\r\n                    (ast).fncFlags |= TypeScript.FncFlags.IsFunctionExpression;\r\n                    (ast).fncFlags |= TypeScript.FncFlags.IsFatArrowFunction;\r\n                    ast.minChar = minChar;\r\n                    limChar = this.scanner.lastTokenLimChar();\r\n                    ast.limChar = limChar;\r\n                } else {\r\n                    if(ast) {\r\n                        ast.isParenthesized = true;\r\n                    }\r\n                }\r\n            }\r\n            if(sawId && (typeContext != TypeContext.NoTypes)) {\r\n                typeContext |= TypeContext.ArraySuffix;\r\n            }\r\n            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);\r\n            if(postFix) {\r\n                if(sawId && (postFix.nodeType == TypeScript.NodeType.Index)) {\r\n                    var binExpr = postFix;\r\n                    if(binExpr.operand2 == null) {\r\n                        postFix = this.convertToTypeReference(postFix);\r\n                    }\r\n                }\r\n                postFix.minChar = minChar;\r\n                postFix.limChar = TypeScript.max(postFix.limChar, this.scanner.lastTokenLimChar());\r\n                return postFix;\r\n            } else {\r\n                return new TypeScript.AST(TypeScript.NodeType.Error);\r\n            }\r\n        };\r\n        Parser.prototype.parseExpr = function (errorRecoverySet, minPrecedence, allowIn, typeContext) {\r\n            var ast = null;\r\n            var tokenInfo = TypeScript.lookupToken(this.tok.tokenId);\r\n            var canAssign = true;\r\n            var idHint = null;\r\n            var minChar = this.scanner.startPos;\r\n            var preComments = this.parseComments();\r\n            var exprIsAnonLambda = false;\r\n            if((tokenInfo != undefined) && (tokenInfo.unopNodeType != TypeScript.NodeType.None)) {\r\n                canAssign = false;\r\n                this.tok = this.scanner.scan();\r\n                var tempExpr = this.parseExpr(TypeScript.ErrorRecoverySet.BinOp | errorRecoverySet, tokenInfo.unopPrecedence, allowIn, TypeContext.NoTypes);\r\n                if((tokenInfo.unopNodeType == TypeScript.NodeType.Pos) && (tempExpr.nodeType == TypeScript.NodeType.NumberLit)) {\r\n                    ast = tempExpr;\r\n                } else {\r\n                    if((tokenInfo.unopNodeType == TypeScript.NodeType.Neg) && (tempExpr.nodeType == TypeScript.NodeType.NumberLit)) {\r\n                        var numLit = tempExpr;\r\n                        numLit.value = (-numLit.value);\r\n                        if(numLit.value == 0) {\r\n                            numLit.isNegativeZero = true;\r\n                        }\r\n                        ast = tempExpr;\r\n                    } else {\r\n                        ast = new TypeScript.UnaryExpression(tokenInfo.unopNodeType, tempExpr);\r\n                        ast.limChar = tempExpr.limChar;\r\n                    }\r\n                }\r\n                ast.minChar = minChar;\r\n            } else {\r\n                ast = this.parseTerm(TypeScript.ErrorRecoverySet.BinOp | TypeScript.ErrorRecoverySet.AddOp | errorRecoverySet, true, typeContext, false);\r\n                var id;\r\n                var temp;\r\n                if(ast.nodeType == TypeScript.NodeType.Name) {\r\n                    id = ast;\r\n                    idHint = id.text;\r\n                } else {\r\n                    if(ast.nodeType == TypeScript.NodeType.Dot) {\r\n                        var subsumedExpr = false;\r\n                        if(this.inferPropertiesFromThisAssignment && (this.tok.tokenId == TypeScript.TokenID.Colon || this.tok.tokenId == TypeScript.TokenID.Asg) && this.parsingClassConstructorDefinition && this.nestingLevel == this.currentClassDefinition.constructorNestingLevel && (ast).operand1.nodeType == TypeScript.NodeType.This) {\r\n                            if((ast).operand2.nodeType == TypeScript.NodeType.Name) {\r\n                                var op2ID = ((ast).operand2);\r\n                                if(!this.currentClassDefinition.knownMemberNames[op2ID.text]) {\r\n                                    ast = this.parseClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, TypeScript.Modifiers.Public);\r\n                                    subsumedExpr = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        if(!subsumedExpr) {\r\n                            temp = ast;\r\n                            while(temp.nodeType == TypeScript.NodeType.Dot) {\r\n                                var binExpr = temp;\r\n                                temp = binExpr.operand2;\r\n                            }\r\n                            if(temp.nodeType == TypeScript.NodeType.Name) {\r\n                                id = temp;\r\n                                idHint = id.text;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if((!this.scanner.lastTokenHadNewline()) && ((this.tok.tokenId == TypeScript.TokenID.Inc) || (this.tok.tokenId == TypeScript.TokenID.Dec))) {\r\n                    canAssign = false;\r\n                    var operand = ast;\r\n                    ast = new TypeScript.UnaryExpression((this.tok.tokenId == TypeScript.TokenID.Inc) ? TypeScript.NodeType.IncPost : TypeScript.NodeType.DecPost, operand);\r\n                    ast.limChar = this.scanner.pos;\r\n                    ast.minChar = operand.minChar;\r\n                    this.tok = this.scanner.scan();\r\n                }\r\n            }\r\n            for(; ; ) {\r\n                tokenInfo = TypeScript.lookupToken(this.tok.tokenId);\r\n                if((tokenInfo == undefined) || (tokenInfo.binopNodeType == TypeScript.NodeType.None)) {\r\n                    break;\r\n                }\r\n                if((!allowIn) && (tokenInfo.binopNodeType == TypeScript.NodeType.In)) {\r\n                    break;\r\n                }\r\n                if(tokenInfo.binopPrecedence == TypeScript.OperatorPrecedence.Asg) {\r\n                    if(tokenInfo.binopPrecedence < minPrecedence) {\r\n                        break;\r\n                    }\r\n                    if(!canAssign) {\r\n                        this.reportParseError(\"illegal assignment\");\r\n                    }\r\n                } else {\r\n                    if(tokenInfo.binopPrecedence <= minPrecedence) {\r\n                        break;\r\n                    }\r\n                }\r\n                this.tok = this.scanner.scan();\r\n                canAssign = false;\r\n                if(tokenInfo.binopNodeType == TypeScript.NodeType.QMark) {\r\n                    this.prevExpr = ast;\r\n                    var qmarkNode = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.Colon, TypeScript.OperatorPrecedence.Asg, allowIn, TypeContext.NoTypes);\r\n                    this.prevExpr = null;\r\n                    if(!(qmarkNode.nodeType == TypeScript.NodeType.FuncDecl && TypeScript.hasFlag((qmarkNode).fncFlags, TypeScript.FncFlags.IsFatArrowFunction))) {\r\n                        this.chkCurTok(TypeScript.TokenID.Colon, \"Expected :\", errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);\r\n                        ast = new TypeScript.TrinaryExpression(TypeScript.NodeType.QMark, ast, qmarkNode, this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.BinOp, TypeScript.OperatorPrecedence.Asg, allowIn, TypeContext.NoTypes));\r\n                    } else {\r\n                        ast = qmarkNode;\r\n                        exprIsAnonLambda = true;\r\n                    }\r\n                } else {\r\n                    var tc = TypeContext.NoTypes;\r\n                    var binExpr2;\r\n                    binExpr2 = new TypeScript.BinaryExpression(tokenInfo.binopNodeType, ast, this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.BinOp, tokenInfo.binopPrecedence, allowIn, TypeContext.NoTypes));\r\n                    if(binExpr2.operand2.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                        var funcDecl = binExpr2.operand2;\r\n                        funcDecl.hint = idHint;\r\n                    }\r\n                    binExpr2.minChar = ast.minChar;\r\n                    binExpr2.limChar = this.scanner.lastTokenLimChar();\r\n                    idHint = null;\r\n                    ast = binExpr2;\r\n                }\r\n            }\r\n            if(canAssign) {\r\n                ast.flags |= TypeScript.ASTFlags.Writeable;\r\n            }\r\n            if(!exprIsAnonLambda) {\r\n                ast.minChar = minChar;\r\n                ast.limChar = TypeScript.max(ast.limChar, this.scanner.lastTokenLimChar());\r\n                ast.preComments = preComments;\r\n                ast.postComments = this.parseCommentsForLine(this.scanner.line);\r\n            }\r\n            return ast;\r\n        };\r\n        Parser.prototype.parsePostfixOperators = function (errorRecoverySet, ast, allowCall, inNew, typeContext, lhsMinChar, lhsLimChar) {\r\n            var count = 0;\r\n            if(!ast) {\r\n                ast = new TypeScript.AST(TypeScript.NodeType.EmptyExpr);\r\n                ast.isParenthesized = true;\r\n            }\r\n            ast.minChar = lhsMinChar;\r\n            ast.limChar = lhsLimChar;\r\n            for(; ; ) {\r\n                switch(this.tok.tokenId) {\r\n                    case TypeScript.TokenID.LParen: {\r\n                        if(inNew) {\r\n                            var callExpr = ast;\r\n                            callExpr.args = this.parseArgList(errorRecoverySet);\r\n                            inNew = false;\r\n                        } else {\r\n                            if(!allowCall) {\r\n                                return ast;\r\n                            }\r\n                            ast = new TypeScript.CallExpression(TypeScript.NodeType.Call, ast, this.parseArgList(errorRecoverySet));\r\n                            ast.minChar = lhsMinChar;\r\n                        }\r\n                        ast.limChar = this.scanner.pos;\r\n                        this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.LBrack: {\r\n                        this.tok = this.scanner.scan();\r\n                        if(this.tok.tokenId == TypeScript.TokenID.RBrack) {\r\n                            if(TypeScript.hasFlag(typeContext, TypeContext.ArraySuffix)) {\r\n                                this.tok = this.scanner.scan();\r\n                                if(ast.nodeType == TypeScript.NodeType.TypeRef) {\r\n                                    var typeRef = ast;\r\n                                    typeRef.arrayCount++;\r\n                                } else {\r\n                                    ast = new TypeScript.BinaryExpression(TypeScript.NodeType.Index, ast, null);\r\n                                }\r\n                                ast.limChar = this.scanner.pos;\r\n                                break;\r\n                            }\r\n                        }\r\n                        ast = new TypeScript.BinaryExpression(TypeScript.NodeType.Index, ast, this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.RBrack, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes));\r\n                        ast.minChar = lhsMinChar;\r\n                        ast.limChar = this.scanner.pos;\r\n                        this.chkCurTok(TypeScript.TokenID.RBrack, \"Expected ']'\", errorRecoverySet);\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.Dot: {\r\n                        var name = null;\r\n                        var curpos = this.scanner.pos;\r\n                        this.tok = this.scanner.scan();\r\n                        if((this.tok.tokenId == TypeScript.TokenID.ID) || (!this.scanner.lastTokenHadNewline() && TypeScript.convertTokToIDName(this.tok))) {\r\n                            ast.flags |= TypeScript.ASTFlags.DotLHS;\r\n                            name = this.createRef(this.tok.getText(), this.scanner.startPos);\r\n                            name.limChar = this.scanner.pos;\r\n                            this.tok = this.scanner.scan();\r\n                        } else {\r\n                            this.reportParseError(\"Expected identifier following dot\");\r\n                            if(this.errorRecovery) {\r\n                                this.skip(errorRecoverySet);\r\n                                ast.flags |= (TypeScript.ASTFlags.Error | TypeScript.ASTFlags.DotLHS);\r\n                                return ast;\r\n                            } else {\r\n                                name = new TypeScript.MissingIdentifier();\r\n                            }\r\n                        }\r\n                        ast = new TypeScript.BinaryExpression(TypeScript.NodeType.Dot, ast, name);\r\n                        ast.minChar = lhsMinChar;\r\n                        ast.limChar = this.scanner.lastTokenLimChar();\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.Arrow: {\r\n                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, TypeScript.Modifiers.None, {\r\n                            preProcessedLambdaArgs: ast\r\n                        });\r\n                        (ast).fncFlags |= TypeScript.FncFlags.IsFunctionExpression;\r\n                        ast.minChar = lhsMinChar;\r\n                        ast.limChar = this.scanner.lastTokenLimChar();\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        return ast;\r\n\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.parseTry = function (tryNode, errorRecoverySet, allowedElements, parentModifiers) {\r\n            var minChar = this.scanner.startPos;\r\n            var preComments = this.parseComments();\r\n            this.tok = this.scanner.scan();\r\n            if(this.tok.tokenId != TypeScript.TokenID.LCurly) {\r\n                this.reportParseError(\"Expected '{'\");\r\n                if(this.errorRecovery) {\r\n                    var etryNode = tryNode;\r\n                    etryNode.minChar = minChar;\r\n                    etryNode.limChar = this.scanner.lastTokenLimChar();\r\n                    etryNode.flags |= TypeScript.ASTFlags.Error;\r\n                    return etryNode;\r\n                }\r\n            }\r\n            tryNode.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n            tryNode.minChar = minChar;\r\n            tryNode.limChar = tryNode.body.limChar;\r\n            tryNode.preComments = preComments;\r\n            tryNode.postComments = this.parseComments();\r\n            return tryNode;\r\n        };\r\n        Parser.prototype.parseCatch = function (errorRecoverySet, allowedElements, parentModifiers) {\r\n            var catchMinChar = this.scanner.startPos;\r\n            var preComments = this.parseComments();\r\n            this.tok = this.scanner.scan();\r\n            this.chkCurTok(TypeScript.TokenID.LParen, \"Expected '('\", errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);\r\n            if((this.tok.tokenId != TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                this.reportParseError(\"Expected identifier in catch header\");\r\n                if(this.errorRecovery) {\r\n                    this.skip(errorRecoverySet);\r\n                    var ecatch = new TypeScript.Catch(new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel), new TypeScript.Statement(TypeScript.NodeType.Empty));\r\n                    ecatch.minChar = this.scanner.startPos;\r\n                    ecatch.limChar = this.scanner.pos;\r\n                    ecatch.flags |= TypeScript.ASTFlags.Error;\r\n                    return ecatch;\r\n                }\r\n            }\r\n            var param = new TypeScript.VarDecl(new TypeScript.Identifier(this.tok.getText()), this.nestingLevel);\r\n            param.id.minChar = this.scanner.startPos;\r\n            param.id.limChar = this.scanner.pos;\r\n            param.minChar = param.id.minChar;\r\n            param.limChar = param.id.limChar;\r\n            this.tok = this.scanner.scan();\r\n            this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);\r\n            if(this.tok.tokenId != TypeScript.TokenID.LCurly) {\r\n                this.reportParseError(\"Expected '{' to start catch body\");\r\n                if(this.errorRecovery) {\r\n                    this.skip(errorRecoverySet);\r\n                    var ecatch = new TypeScript.Catch(new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel), new TypeScript.Statement(TypeScript.NodeType.Empty));\r\n                    ecatch.minChar = this.scanner.startPos;\r\n                    ecatch.limChar = this.scanner.pos;\r\n                    ecatch.flags |= TypeScript.ASTFlags.Error;\r\n                    return ecatch;\r\n                }\r\n            }\r\n            var catchStmt = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n            var catchNode = new TypeScript.Catch(param, catchStmt);\r\n            catchNode.minChar = catchMinChar;\r\n            catchNode.limChar = catchStmt.limChar;\r\n            catchNode.preComments = preComments;\r\n            catchNode.postComments = this.parseComments();\r\n            return catchNode;\r\n        };\r\n        Parser.prototype.parseFinally = function (errorRecoverySet, allowedElements, parentModifiers) {\r\n            var finMinChar = this.scanner.startPos;\r\n            var preComments = this.parseComments();\r\n            this.tok = this.scanner.scan();\r\n            if(this.tok.tokenId != TypeScript.TokenID.LCurly) {\r\n                this.reportParseError(\"Expected '{' to start body of finally statement\");\r\n                if(this.errorRecovery) {\r\n                    this.skip(errorRecoverySet);\r\n                    var efin = new TypeScript.Finally(new TypeScript.Statement(TypeScript.NodeType.Empty));\r\n                    efin.flags |= TypeScript.ASTFlags.Error;\r\n                    efin.minChar = this.scanner.startPos;\r\n                    efin.limChar = this.scanner.pos;\r\n                    return efin;\r\n                }\r\n            }\r\n            var finBody = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n            var fin = new TypeScript.Finally(finBody);\r\n            fin.minChar = finMinChar;\r\n            fin.limChar = fin.body.limChar;\r\n            fin.preComments = preComments;\r\n            fin.postComments = this.parseComments();\r\n            return fin;\r\n        };\r\n        Parser.prototype.parseTryCatchFinally = function (errorRecoverySet, allowedElements, parentModifiers, labelList) {\r\n            var tryPart = new TypeScript.Try(null);\r\n            var tryMinChar = this.scanner.startPos;\r\n            this.pushStmt(tryPart, labelList);\r\n            this.parseTry(tryPart, errorRecoverySet | TypeScript.ErrorRecoverySet.Catch, allowedElements, parentModifiers);\r\n            this.popStmt();\r\n            var tc = null;\r\n            var tf = null;\r\n            if(this.tok.tokenId == TypeScript.TokenID.CATCH) {\r\n                var catchPart = this.parseCatch(errorRecoverySet | TypeScript.ErrorRecoverySet.Catch, allowedElements, parentModifiers);\r\n                tc = new TypeScript.TryCatch(tryPart, catchPart);\r\n                tc.minChar = tryPart.minChar;\r\n                tc.limChar = catchPart.limChar;\r\n            }\r\n            if(this.tok.tokenId != TypeScript.TokenID.FINALLY) {\r\n                if(tc == null) {\r\n                    this.reportParseError(\"try with neither catch nor finally\");\r\n                    if(this.errorRecovery) {\r\n                        var etf = new TypeScript.TryFinally(tryPart, new TypeScript.Finally(new TypeScript.AST(TypeScript.NodeType.Empty)));\r\n                        etf.flags |= TypeScript.ASTFlags.Error;\r\n                        etf.minChar = this.scanner.startPos;\r\n                        etf.limChar = this.scanner.pos;\r\n                        return etf;\r\n                    }\r\n                    return new TypeScript.TryFinally(tryPart, new TypeScript.Finally(new TypeScript.AST(TypeScript.NodeType.Empty)));\r\n                } else {\r\n                    return tc;\r\n                }\r\n            } else {\r\n                if(tc) {\r\n                    tryPart = tc;\r\n                }\r\n                var finallyPart = this.parseFinally(errorRecoverySet, allowedElements, parentModifiers);\r\n                tf = new TypeScript.TryFinally(tryPart, finallyPart);\r\n                tf.minChar = tryMinChar;\r\n                tf.limChar = finallyPart.limChar;\r\n                return tf;\r\n            }\r\n        };\r\n        Parser.prototype.parseStatement = function (errorRecoverySet, allowedElements, parentModifiers) {\r\n            var ast = null;\r\n            var labelList = null;\r\n            var astList = null;\r\n            var temp;\r\n            var modifiers = TypeScript.Modifiers.None;\r\n            var minChar = this.scanner.startPos;\r\n            var forInOk = false;\r\n            var needTerminator = false;\r\n            var fnOrVar = null;\r\n            var preComments = this.parseComments();\r\n            this.state = ParseState.StartStatement;\r\n            function isAmbient() {\r\n                return TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient) || TypeScript.hasFlag(parentModifiers, TypeScript.Modifiers.Ambient);\r\n            }\r\n            function mayNotBeExported() {\r\n                if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                    this.reportError(\"Statement may not be exported\");\r\n                }\r\n            }\r\n            for(; ; ) {\r\n                switch(this.tok.tokenId) {\r\n                    case TypeScript.TokenID.EOF: {\r\n                        ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                        ast.minChar = minChar;\r\n                        ast.limChar = this.scanner.pos;\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.FUNCTION: {\r\n                        if(this.inStaticFnc) {\r\n                            this.reportParseError(\"Ambient static function delarations may only contain other ambient static function declarations\");\r\n                        }\r\n                        if(this.parsingDeclareFile || isAmbient() || this.ambientModule) {\r\n                            this.tok = this.scanner.scan();\r\n                            fnOrVar = this.parsePropertyDecl(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, modifiers, true, false);\r\n                            if(fnOrVar.nodeType == TypeScript.NodeType.VarDecl) {\r\n                                this.reportParseError(\"function keyword can only introduce function declaration\");\r\n                            } else {\r\n                                if((fnOrVar.nodeType == TypeScript.NodeType.FuncDecl) && ((fnOrVar).fncFlags , TypeScript.FncFlags.IsFatArrowFunction)) {\r\n                                    needTerminator = true;\r\n                                }\r\n                            }\r\n                            ast = fnOrVar;\r\n                        } else {\r\n                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null);\r\n                            if(TypeScript.hasFlag((ast).fncFlags, TypeScript.FncFlags.IsFatArrowFunction)) {\r\n                                needTerminator = true;\r\n                            }\r\n                            if(this.ambientModule) {\r\n                                this.reportParseError(\"function declaration not permitted within ambient module\");\r\n                            }\r\n                            if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                                (ast).fncFlags |= TypeScript.FncFlags.Exported;\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.MODULE: {\r\n                        if((allowedElements & TypeScript.AllowedElements.ModuleDecls) == TypeScript.AllowedElements.None) {\r\n                            this.reportParseError(\"module not allowed in this context\");\r\n                            this.tok = this.scanner.scan();\r\n                            ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                            ast.minChar = minChar;\r\n                            ast.limChar = this.scanner.lastTokenLimChar();\r\n                        } else {\r\n                            ast = this.parseModuleDecl(errorRecoverySet, modifiers);\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.IMPORT: {\r\n                        if((allowedElements & TypeScript.AllowedElements.ModuleDecls) == TypeScript.AllowedElements.None) {\r\n                            this.reportParseError(\"module not allowed in this context\");\r\n                            this.tok = this.scanner.scan();\r\n                            ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                            ast.minChar = minChar;\r\n                            ast.limChar = this.scanner.lastTokenLimChar();\r\n                        } else {\r\n                            ast = this.parseImportDecl(errorRecoverySet, modifiers);\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.EXPORT: {\r\n                        if((allowedElements & TypeScript.AllowedElements.ModuleDecls) == TypeScript.AllowedElements.None) {\r\n                            this.reportParseError(\"'export' statements are only allowed at the global and module levels\");\r\n                            this.tok = this.scanner.scan();\r\n                            ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                            ast.minChar = minChar;\r\n                            ast.limChar = this.scanner.lastTokenLimChar();\r\n                        }\r\n                        if(this.topLevel) {\r\n                            this.hasTopLevelImportOrExport = true;\r\n                        }\r\n                        modifiers |= TypeScript.Modifiers.Exported;\r\n                        this.tok = this.scanner.scan();\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.PRIVATE: {\r\n                        modifiers |= TypeScript.Modifiers.Private;\r\n                        this.tok = this.scanner.scan();\r\n                        if(this.parsingClassConstructorDefinition) {\r\n                            if(!this.inferPropertiesFromThisAssignment) {\r\n                                this.reportParseError(\"Property declarations are not permitted within constructor bodies\");\r\n                            }\r\n                            minChar = this.scanner.pos;\r\n                            if(this.inferPropertiesFromThisAssignment && (this.tok.tokenId != TypeScript.TokenID.THIS || (this.tok = this.scanner.scan()).tokenId != TypeScript.TokenID.Dot)) {\r\n                                this.reportParseError(\"Expected 'this.' for property declaration\");\r\n                                this.tok = this.scanner.scan();\r\n                                ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                                ast.minChar = minChar;\r\n                                ast.limChar = this.scanner.lastTokenLimChar();\r\n                            } else {\r\n                                this.tok = this.scanner.scan();\r\n                                var id = new TypeScript.Identifier(this.tok.getText());\r\n                                id.minChar = this.scanner.startPos;\r\n                                id.limChar = this.scanner.pos;\r\n                                this.tok = this.scanner.scan();\r\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\r\n                            }\r\n                        } else {\r\n                            if(this.tok.tokenId != TypeScript.TokenID.INTERFACE) {\r\n                                if(this.tok.tokenId == TypeScript.TokenID.GET) {\r\n                                    this.prevIDTok = this.tok;\r\n                                    this.tok = this.scanner.scan();\r\n                                    if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                        this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                                    }\r\n                                    if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                                        modifiers |= TypeScript.Modifiers.Getter;\r\n                                        this.prevIDTok = null;\r\n                                    }\r\n                                } else {\r\n                                    if(this.tok.tokenId == TypeScript.TokenID.SET) {\r\n                                        this.prevIDTok = this.tok;\r\n                                        this.tok = this.scanner.scan();\r\n                                        if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                            this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                                        }\r\n                                        if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                                            modifiers |= TypeScript.Modifiers.Setter;\r\n                                            this.prevIDTok = null;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                fnOrVar = this.parsePropertyDecl(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, modifiers, isAmbient(), false);\r\n                                if((fnOrVar.nodeType == TypeScript.NodeType.VarDecl) || ((fnOrVar.nodeType == TypeScript.NodeType.FuncDecl) && (TypeScript.hasFlag((fnOrVar).fncFlags, TypeScript.FncFlags.IsFatArrowFunction)))) {\r\n                                    needTerminator = true;\r\n                                }\r\n                                ast = fnOrVar;\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.PUBLIC: {\r\n                        if(this.parsingClassConstructorDefinition) {\r\n                            if(!this.inferPropertiesFromThisAssignment) {\r\n                                this.reportParseError(\"Property declarations are not permitted within constructor bodies\");\r\n                            }\r\n                            this.tok = this.scanner.scan();\r\n                            minChar = this.scanner.pos;\r\n                            modifiers |= TypeScript.Modifiers.Public;\r\n                            if(this.inferPropertiesFromThisAssignment && (this.tok.tokenId != TypeScript.TokenID.THIS || (this.tok = this.scanner.scan()).tokenId != TypeScript.TokenID.Dot)) {\r\n                                this.reportParseError(\"Expected 'this.' for property declaration\");\r\n                                this.tok = this.scanner.scan();\r\n                                ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                                ast.minChar = minChar;\r\n                                ast.limChar = this.scanner.lastTokenLimChar();\r\n                            } else {\r\n                                this.tok = this.scanner.scan();\r\n                                var id = new TypeScript.Identifier(this.tok.getText());\r\n                                id.minChar = this.scanner.startPos;\r\n                                id.limChar = this.scanner.pos;\r\n                                this.tok = this.scanner.scan();\r\n                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);\r\n                            }\r\n                        } else {\r\n                            if((allowedElements & TypeScript.AllowedElements.Properties) == TypeScript.AllowedElements.None) {\r\n                                this.reportParseError(\"'property' statements are only allowed within classes\");\r\n                                this.tok = this.scanner.scan();\r\n                                ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                                ast.minChar = minChar;\r\n                                ast.limChar = this.scanner.lastTokenLimChar();\r\n                            } else {\r\n                                modifiers |= TypeScript.Modifiers.Public;\r\n                                this.tok = this.scanner.scan();\r\n                                if(this.tok.tokenId == TypeScript.TokenID.GET) {\r\n                                    this.prevIDTok = this.tok;\r\n                                    this.tok = this.scanner.scan();\r\n                                    if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                        this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                                    }\r\n                                    if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                                        modifiers |= TypeScript.Modifiers.Getter;\r\n                                        this.prevIDTok = null;\r\n                                    }\r\n                                } else {\r\n                                    if(this.tok.tokenId == TypeScript.TokenID.SET) {\r\n                                        this.prevIDTok = this.tok;\r\n                                        this.tok = this.scanner.scan();\r\n                                        if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                            this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                                        }\r\n                                        if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                                            modifiers |= TypeScript.Modifiers.Setter;\r\n                                            this.prevIDTok = null;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                fnOrVar = this.parsePropertyDecl(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, modifiers, isAmbient(), false);\r\n                                if((fnOrVar.nodeType == TypeScript.NodeType.VarDecl) || ((fnOrVar.nodeType == TypeScript.NodeType.FuncDecl) && TypeScript.hasFlag((fnOrVar).fncFlags, TypeScript.FncFlags.IsFatArrowFunction))) {\r\n                                    needTerminator = true;\r\n                                }\r\n                                ast = fnOrVar;\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.DECLARE: {\r\n                        if(!(allowedElements & TypeScript.AllowedElements.AmbientDecls)) {\r\n                            this.reportParseError(\"Ambient declarations are only allowed at the top-level or module scopes\");\r\n                        }\r\n                        if(!this.parsingDeclareFile && TypeScript.hasFlag(parentModifiers, TypeScript.Modifiers.Ambient)) {\r\n                            this.reportParseError(\"Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)\");\r\n                        }\r\n                        modifiers |= TypeScript.Modifiers.Ambient;\r\n                        this.tok = this.scanner.scan();\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.CLASS: {\r\n                        if((allowedElements & TypeScript.AllowedElements.ClassDecls) == TypeScript.AllowedElements.None) {\r\n                            this.reportParseError(\"class not allowed in this context\");\r\n                            this.tok = this.scanner.scan();\r\n                            ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                            ast.minChar = minChar;\r\n                            ast.limChar = this.scanner.lastTokenLimChar();\r\n                        } else {\r\n                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.INTERFACE: {\r\n                        if((allowedElements & TypeScript.AllowedElements.InterfaceDecls) == TypeScript.AllowedElements.None) {\r\n                            this.reportParseError(\"interface not allowed in this context\");\r\n                            this.tok = this.scanner.scan();\r\n                            ast = new TypeScript.AST(TypeScript.NodeType.Error);\r\n                            ast.minChar = minChar;\r\n                            ast.limChar = this.scanner.lastTokenLimChar();\r\n                        } else {\r\n                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.VAR: {\r\n                        var declAst = this.parseVarDecl(errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart, modifiers, true, false, false);\r\n                        if(declAst.nodeType == TypeScript.NodeType.VarDecl) {\r\n                            ast = declAst;\r\n                        } else {\r\n                            ast = new TypeScript.Block(declAst, false);\r\n                        }\r\n                        needTerminator = true;\r\n                        if(this.parsingDeclareFile || this.ambientModule && ast.nodeType == TypeScript.NodeType.VarDecl) {\r\n                            (ast).varFlags |= TypeScript.VarFlags.Exported;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.STATIC: {\r\n                        if(this.currentClassDecl == null) {\r\n                            this.reportParseError(\"Statics may only be class members\");\r\n                        }\r\n                        mayNotBeExported();\r\n                        modifiers |= TypeScript.Modifiers.Public;\r\n                        this.tok = this.scanner.scan();\r\n                        if(this.tok.tokenId == TypeScript.TokenID.GET) {\r\n                            this.prevIDTok = this.tok;\r\n                            this.tok = this.scanner.scan();\r\n                            if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                            }\r\n                            if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                                modifiers |= TypeScript.Modifiers.Getter;\r\n                                this.prevIDTok = null;\r\n                            }\r\n                        } else {\r\n                            if(this.tok.tokenId == TypeScript.TokenID.SET) {\r\n                                this.tok = this.scanner.scan();\r\n                                if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                    this.reportParseError(\"Property accessors are only available when targeting ES5 or greater\");\r\n                                }\r\n                                if((this.tok.tokenId == TypeScript.TokenID.ID) || TypeScript.convertTokToID(this.tok, this.strictMode)) {\r\n                                    modifiers |= TypeScript.Modifiers.Setter;\r\n                                }\r\n                            }\r\n                        }\r\n                        if(isAmbient()) {\r\n                            modifiers |= TypeScript.Modifiers.Ambient;\r\n                        }\r\n                        fnOrVar = this.parsePropertyDecl(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, modifiers, this.parsingDeclareFile || (modifiers & TypeScript.Modifiers.Ambient) != TypeScript.Modifiers.None, true);\r\n                        var staticsList = this.topStaticsList();\r\n                        if(staticsList && fnOrVar.nodeType == TypeScript.NodeType.VarDecl) {\r\n                            staticsList.append(fnOrVar);\r\n                        }\r\n                        if(fnOrVar.nodeType == TypeScript.NodeType.VarDecl || ((fnOrVar.nodeType == TypeScript.NodeType.FuncDecl) && TypeScript.hasFlag((fnOrVar).fncFlags, TypeScript.FncFlags.IsFatArrowFunction))) {\r\n                            needTerminator = true;\r\n                        }\r\n                        ast = fnOrVar;\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.FOR: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"syntax error: for statement does not take modifiers\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.chkNxtTok(TypeScript.TokenID.LParen, \"Expected '('\", errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart | TypeScript.ErrorRecoverySet.Var);\r\n                        this.state = ParseState.ForInit;\r\n                        forInOk = true;\r\n                        switch(this.tok.tokenId) {\r\n                            case TypeScript.TokenID.VAR: {\r\n                                temp = this.parseVarDecl(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon | TypeScript.ErrorRecoverySet.In, TypeScript.Modifiers.None, false, false, false);\r\n                                break;\r\n\r\n                            }\r\n                            case TypeScript.TokenID.SColon: {\r\n                                temp = null;\r\n                                this.state = ParseState.ForCondStart;\r\n                                break;\r\n\r\n                            }\r\n                            default: {\r\n                                temp = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon | TypeScript.ErrorRecoverySet.In, TypeScript.OperatorPrecedence.No, false, TypeContext.NoTypes);\r\n                                break;\r\n\r\n                            }\r\n                        }\r\n                        this.state = ParseState.ForInitAfterVar;\r\n                        if(this.tok.tokenId == TypeScript.TokenID.IN) {\r\n                            if((temp == null) || (!forInOk)) {\r\n                                this.reportParseError(\"malformed for statement\");\r\n                                if(this.errorRecovery) {\r\n                                    this.skip(errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);\r\n                                    ast = new TypeScript.AST(TypeScript.NodeType.Empty);\r\n                                    ast.flags |= TypeScript.ASTFlags.Error;\r\n                                }\r\n                            } else {\r\n                                this.tok = this.scanner.scan();\r\n                                var forInStmt = new TypeScript.ForInStatement(temp, this.parseExpr(TypeScript.ErrorRecoverySet.RParen | errorRecoverySet, TypeScript.OperatorPrecedence.Cma, false, TypeContext.NoTypes));\r\n                                forInStmt.limChar = this.scanner.pos;\r\n                                this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", TypeScript.ErrorRecoverySet.StmtStart | errorRecoverySet);\r\n                                this.pushStmt(forInStmt, labelList);\r\n                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n                                this.popStmt();\r\n                                forInStmt.minChar = minChar;\r\n                                ast = forInStmt;\r\n                            }\r\n                        } else {\r\n                            var forStmt = new TypeScript.ForStatement(temp);\r\n                            forStmt.minChar = minChar;\r\n                            this.chkCurTok(TypeScript.TokenID.SColon, \"Expected ';'\", errorRecoverySet);\r\n                            if(this.tok.tokenId == TypeScript.TokenID.SColon) {\r\n                                forStmt.cond = null;\r\n                            } else {\r\n                                forStmt.cond = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon | TypeScript.ErrorRecoverySet.RParen, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                                if(this.tok.tokenId != TypeScript.TokenID.SColon) {\r\n                                    this.skip(errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);\r\n                                    ast = forStmt;\r\n                                    ast.flags |= TypeScript.ASTFlags.Error;\r\n                                }\r\n                            }\r\n                            this.tok = this.scanner.scan();\r\n                            if(this.tok.tokenId == TypeScript.TokenID.RParen) {\r\n                                forStmt.incr = null;\r\n                            } else {\r\n                                forStmt.incr = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon | TypeScript.ErrorRecoverySet.RParen, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                            }\r\n                            this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.LCurly);\r\n                            this.pushStmt(forStmt, labelList);\r\n                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n                            this.popStmt();\r\n                            forStmt.limChar = forStmt.body.limChar;\r\n                            ast = forStmt;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.WITH: {\r\n {\r\n                            if(TypeScript.codeGenTarget < TypeScript.CodeGenTarget.ES5) {\r\n                                this.reportParseError(\"'with' statements are only available in ES5 codegen mode or better\");\r\n                            }\r\n                            if(this.strictMode) {\r\n                                this.reportParseError(\"'with' statements are not available in strict mode\");\r\n                            }\r\n                            mayNotBeExported();\r\n                            if(modifiers != TypeScript.Modifiers.None) {\r\n                                this.reportParseError(\"'with' statement does not take modifiers\");\r\n                            }\r\n                            minChar = this.scanner.startPos;\r\n                            this.chkNxtTok(TypeScript.TokenID.LParen, \"Expected '('\", errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart | TypeScript.ErrorRecoverySet.Var);\r\n                            var expr = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.Colon, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                            this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.LCurly);\r\n                            var withStmt = new TypeScript.WithStatement(expr);\r\n                            withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n                            withStmt.minChar = minChar;\r\n                            withStmt.limChar = withStmt.body.limChar;\r\n                            ast = withStmt;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.SWITCH: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"'switch' statement does not take modifiers\");\r\n                        }\r\n                        this.chkNxtTok(TypeScript.TokenID.LParen, \"Expected '('\", errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);\r\n                        var switchStmt = new TypeScript.SwitchStatement(this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.RParen, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes));\r\n                        this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.LCurly);\r\n                        var caseListMinChar = this.scanner.startPos;\r\n                        this.chkCurTok(TypeScript.TokenID.LCurly, \"Expected '{'\", errorRecoverySet | TypeScript.ErrorRecoverySet.SCase);\r\n                        switchStmt.defaultCase = null;\r\n                        switchStmt.caseList = new TypeScript.ASTList();\r\n                        var caseStmt = null;\r\n                        this.pushStmt(switchStmt, labelList);\r\n                        for(; ; ) {\r\n                            if((this.tok.tokenId == TypeScript.TokenID.CASE) || (this.tok.tokenId == TypeScript.TokenID.DEFAULT)) {\r\n                                var isDefault = (this.tok.tokenId == TypeScript.TokenID.DEFAULT);\r\n                                caseStmt = new TypeScript.CaseStatement();\r\n                                caseStmt.minChar = this.scanner.startPos;\r\n                                this.tok = this.scanner.scan();\r\n                                if(isDefault) {\r\n                                    switchStmt.defaultCase = caseStmt;\r\n                                } else {\r\n                                    caseStmt.expr = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.Colon, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                                }\r\n                                this.chkCurTok(TypeScript.TokenID.Colon, \"Expected ':'\", errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);\r\n                                caseStmt.body = new TypeScript.ASTList();\r\n                                this.parseStmtList(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, caseStmt.body, false, true, allowedElements, modifiers);\r\n                                caseStmt.limChar = caseStmt.body.limChar;\r\n                                switchStmt.caseList.append(caseStmt);\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        switchStmt.caseList.minChar = caseListMinChar;\r\n                        switchStmt.caseList.limChar = this.scanner.pos;\r\n                        switchStmt.limChar = switchStmt.caseList.limChar;\r\n                        this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n                        this.popStmt();\r\n                        ast = switchStmt;\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.WHILE: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"'while' statement does not take modifiers\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.chkNxtTok(TypeScript.TokenID.LParen, \"Expected '('\", TypeScript.ErrorRecoverySet.ExprStart | errorRecoverySet);\r\n                        var whileStmt = new TypeScript.WhileStatement(this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.RParen, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes));\r\n                        whileStmt.minChar = minChar;\r\n                        this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);\r\n                        this.pushStmt(whileStmt, labelList);\r\n                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n                        whileStmt.limChar = whileStmt.body.limChar;\r\n                        this.popStmt();\r\n                        ast = whileStmt;\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.DO: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"'do' statement does not take modifiers\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        var doStmt = new TypeScript.DoWhileStatement();\r\n                        doStmt.minChar = minChar;\r\n                        this.pushStmt(doStmt, labelList);\r\n                        doStmt.body = this.parseStatement(errorRecoverySet | TypeScript.ErrorRecoverySet.While, allowedElements, parentModifiers);\r\n                        this.popStmt();\r\n                        doStmt.whileAST = new TypeScript.Identifier(\"while\");\r\n                        doStmt.whileAST.minChar = this.scanner.startPos;\r\n                        this.chkCurTok(TypeScript.TokenID.WHILE, \"Expected 'while'\", errorRecoverySet | TypeScript.ErrorRecoverySet.LParen);\r\n                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;\r\n                        this.chkCurTok(TypeScript.TokenID.LParen, \"Expected '('\", errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);\r\n                        doStmt.cond = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.RParen, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                        doStmt.limChar = this.scanner.pos;\r\n                        this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet);\r\n                        ast = doStmt;\r\n                        if(this.tok.tokenId == TypeScript.TokenID.SColon) {\r\n                            this.tok = this.scanner.scan();\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.IF: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"if statement does not take modifiers\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.chkNxtTok(TypeScript.TokenID.LParen, \"Expected '('\", errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);\r\n                        var ifStmt = new TypeScript.IfStatement(this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.LParen, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes));\r\n                        ifStmt.minChar = minChar;\r\n                        this.chkCurTok(TypeScript.TokenID.RParen, \"Expected ')'\", errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);\r\n                        this.pushStmt(ifStmt, labelList);\r\n                        ifStmt.thenBod = this.parseStatement(TypeScript.ErrorRecoverySet.Else | errorRecoverySet, allowedElements, parentModifiers);\r\n                        ifStmt.limChar = ifStmt.thenBod.limChar;\r\n                        if(this.tok.tokenId == TypeScript.TokenID.ELSE) {\r\n                            this.tok = this.scanner.scan();\r\n                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);\r\n                            ifStmt.limChar = ifStmt.elseBod.limChar;\r\n                        }\r\n                        this.popStmt();\r\n                        ast = ifStmt;\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.TRY: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"try statement does not take modifiers\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        ast = this.parseTryCatchFinally(errorRecoverySet, TypeScript.AllowedElements.FunctionBody, parentModifiers, labelList);\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.LCurly: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"block does not take modifiers\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        var block = new TypeScript.Block(new TypeScript.ASTList(), true);\r\n                        this.pushStmt(block, labelList);\r\n                        this.parseStmtList(errorRecoverySet | TypeScript.ErrorRecoverySet.RCurly, block.stmts, false, false, TypeScript.AllowedElements.Block, modifiers);\r\n                        this.popStmt();\r\n                        block.stmts.minChar = minChar;\r\n                        block.stmts.limChar = this.scanner.pos;\r\n                        block.minChar = block.stmts.minChar;\r\n                        block.limChar = block.stmts.limChar;\r\n                        this.chkCurTok(TypeScript.TokenID.RCurly, \"Expected '}'\", errorRecoverySet);\r\n                        ast = block;\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.SColon: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"modifier can not appear here\");\r\n                        }\r\n                        ast = new TypeScript.AST(TypeScript.NodeType.Empty);\r\n                        this.tok = this.scanner.scan();\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.BREAK:\r\n                    case TypeScript.TokenID.CONTINUE: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"modifiers can not appear before jump statement\");\r\n                        }\r\n                        var jump = new TypeScript.Jump((this.tok.tokenId == TypeScript.TokenID.BREAK) ? TypeScript.NodeType.Break : TypeScript.NodeType.Continue);\r\n                        this.tok = this.scanner.scan();\r\n                        if((this.tok.tokenId == TypeScript.TokenID.ID) && (!this.scanner.lastTokenHadNewline())) {\r\n                            jump.target = this.tok.getText();\r\n                            this.tok = this.scanner.scan();\r\n                        }\r\n                        this.resolveJumpTarget(jump);\r\n                        ast = jump;\r\n                        needTerminator = true;\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.RETURN: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"modifiers can not appear before return statement\");\r\n                        }\r\n                        if(!this.inFnc) {\r\n                            this.reportParseError(\"return statement outside of function body\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        var retStmt = new TypeScript.ReturnStatement();\r\n                        retStmt.minChar = minChar;\r\n                        if((this.tok.tokenId != TypeScript.TokenID.SColon) && (this.tok.tokenId != TypeScript.TokenID.RCurly) && (!(this.scanner.lastTokenHadNewline()))) {\r\n                            retStmt.returnExpression = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                        }\r\n                        needTerminator = true;\r\n                        retStmt.limChar = this.scanner.lastTokenLimChar();\r\n                        ast = retStmt;\r\n                        break;\r\n                    }\r\n\r\n                    case TypeScript.TokenID.THROW: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"modifiers can not appear before a throw statement\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        if((this.tok.tokenId != TypeScript.TokenID.SColon) && (this.tok.tokenId != TypeScript.TokenID.RCurly) && (!(this.scanner.lastTokenHadNewline()))) {\r\n                            temp = this.parseExpr(errorRecoverySet | TypeScript.ErrorRecoverySet.SColon, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                        } else {\r\n                            this.reportParseError(\"throw with no target\");\r\n                            temp = null;\r\n                        }\r\n                        ast = new TypeScript.UnaryExpression(TypeScript.NodeType.Throw, temp);\r\n                        ast.limChar = this.scanner.lastTokenLimChar();\r\n                        needTerminator = true;\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.ENUM: {\r\n                        this.tok = this.scanner.scan();\r\n                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);\r\n                        ast.minChar = minChar;\r\n                        ast.limChar = this.scanner.lastTokenLimChar();\r\n                        if(this.parsingDeclareFile || TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Ambient)) {\r\n                            (ast).modFlags |= TypeScript.ModuleFlags.Ambient;\r\n                        }\r\n                        if(TypeScript.hasFlag(modifiers, TypeScript.Modifiers.Exported)) {\r\n                            (ast).modFlags |= TypeScript.ModuleFlags.Exported;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.DEBUGGER: {\r\n                        mayNotBeExported();\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"modifiers can not appear before debugger statement\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        this.tok = this.scanner.scan();\r\n                        var debuggerStmt = new TypeScript.DebuggerStatement();\r\n                        debuggerStmt.minChar = minChar;\r\n                        needTerminator = true;\r\n                        debuggerStmt.limChar = this.scanner.lastTokenLimChar();\r\n                        ast = debuggerStmt;\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        if(modifiers != TypeScript.Modifiers.None) {\r\n                            this.reportParseError(\"modifiers can not appear before an expression statement or label\");\r\n                        }\r\n                        minChar = this.scanner.startPos;\r\n                        var svPos = this.scanner.pos;\r\n                        temp = this.parseExpr(TypeScript.ErrorRecoverySet.Colon | TypeScript.ErrorRecoverySet.StmtStart | errorRecoverySet, TypeScript.OperatorPrecedence.No, true, TypeContext.NoTypes);\r\n                        if(this.scanner.pos == svPos) {\r\n                            this.tok = this.scanner.scan();\r\n                            ast = temp;\r\n                        } else {\r\n                            if((this.tok.tokenId == TypeScript.TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) && temp && (temp.nodeType == TypeScript.NodeType.Name)) {\r\n                                if(labelList == null) {\r\n                                    labelList = new TypeScript.ASTList();\r\n                                }\r\n                                labelList.append(new TypeScript.Label(temp));\r\n                                this.tok = this.scanner.scan();\r\n                            } else {\r\n                                ast = temp;\r\n                                needTerminator = true;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n                if(ast) {\r\n                    break;\r\n                }\r\n            }\r\n            if(needTerminator) {\r\n                switch(this.tok.tokenId) {\r\n                    case TypeScript.TokenID.SColon: {\r\n                        this.tok = this.scanner.scan();\r\n                        ast.flags |= TypeScript.ASTFlags.ExplicitSemicolon;\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.TokenID.EOF:\r\n                    case TypeScript.TokenID.RCurly: {\r\n                        ast.flags |= TypeScript.ASTFlags.AutomaticSemicolon;\r\n                        if(this.style_requireSemi) {\r\n                            this.reportParseStyleError(\"no automatic semicolon\");\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        if(!this.scanner.lastTokenHadNewline()) {\r\n                            this.reportParseError(\"Expected ';'\");\r\n                        } else {\r\n                            ast.flags |= TypeScript.ASTFlags.AutomaticSemicolon;\r\n                            if(this.style_requireSemi) {\r\n                                this.reportParseStyleError(\"no automatic semicolon\");\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                }\r\n            }\r\n            if(labelList) {\r\n                ast = new TypeScript.LabeledStatement(labelList, ast);\r\n            }\r\n            ast.minChar = minChar;\r\n            ast.limChar = TypeScript.max(ast.limChar, this.scanner.lastTokenLimChar());\r\n            ast.preComments = preComments;\r\n            if(this.ambientModule && (!this.okAmbientModuleMember(ast))) {\r\n                this.reportParseError(\"statement not permitted within ambient module\");\r\n            }\r\n            ast.flags |= TypeScript.ASTFlags.IsStatement;\r\n            return ast;\r\n        };\r\n        Parser.prototype.okAmbientModuleMember = function (ast) {\r\n            var nt = ast.nodeType;\r\n            return (nt == TypeScript.NodeType.Class) || (nt == TypeScript.NodeType.Import) || (nt == TypeScript.NodeType.Interface) || (nt == TypeScript.NodeType.Module) || (nt == TypeScript.NodeType.Empty) || ((nt == TypeScript.NodeType.VarDecl) && (TypeScript.hasFlag((ast).varFlags, TypeScript.VarFlags.Property) || TypeScript.hasFlag((ast).varFlags, TypeScript.VarFlags.Exported))) || ((nt == TypeScript.NodeType.FuncDecl) && ((ast).isMethod()));\r\n        };\r\n        Parser.prototype.parseStmtList = function (errorRecoverySet, stmts, sourceElms, noLeadingCase, allowedElements, parentModifiers) {\r\n            var directivePrologue = sourceElms;\r\n            stmts.minChar = this.scanner.startPos;\r\n            var limChar = this.scanner.pos;\r\n            var innerStmts = (allowedElements & TypeScript.AllowedElements.ModuleDecls) == TypeScript.AllowedElements.None;\r\n            var classNope = (allowedElements & TypeScript.AllowedElements.ClassDecls) == TypeScript.AllowedElements.None;\r\n            errorRecoverySet |= TypeScript.ErrorRecoverySet.TypeScriptS | TypeScript.ErrorRecoverySet.RCurly;\r\n            this.state = ParseState.StartStmtList;\r\n            var oldStrictMode = this.strictMode;\r\n            this.nestingLevel++;\r\n            for(; ; ) {\r\n                if((this.tok.tokenId == TypeScript.TokenID.RCurly) || (noLeadingCase && ((this.tok.tokenId == TypeScript.TokenID.CASE) || (this.tok.tokenId == TypeScript.TokenID.DEFAULT))) || (innerStmts && (this.tok.tokenId == TypeScript.TokenID.EXPORT)) || (classNope && (this.tok.tokenId == TypeScript.TokenID.CLASS)) || (this.tok.tokenId == TypeScript.TokenID.EOF)) {\r\n                    this.state = ParseState.EndStmtList;\r\n                    stmts.limChar = limChar;\r\n                    if(stmts.members.length == 0) {\r\n                        stmts.preComments = this.parseComments();\r\n                    } else {\r\n                        stmts.postComments = this.parseComments();\r\n                    }\r\n                    this.strictMode = oldStrictMode;\r\n                    this.nestingLevel--;\r\n                    return;\r\n                }\r\n                var stmt = this.parseStatement(errorRecoverySet & (~(TypeScript.ErrorRecoverySet.Else | TypeScript.ErrorRecoverySet.RParen | TypeScript.ErrorRecoverySet.Catch | TypeScript.ErrorRecoverySet.Colon)), allowedElements, parentModifiers);\r\n                if(stmt) {\r\n                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));\r\n                    stmts.append(stmt);\r\n                    limChar = stmt.limChar;\r\n                    if(directivePrologue) {\r\n                        if(stmt.nodeType == TypeScript.NodeType.QString) {\r\n                            var qstring = stmt;\r\n                            if(qstring.text == \"use strict\") {\r\n                                stmts.flags |= TypeScript.ASTFlags.StrictMode;\r\n                                this.strictMode = true;\r\n                            } else {\r\n                                directivePrologue = false;\r\n                            }\r\n                        } else {\r\n                            directivePrologue = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Parser.prototype.quickParse = function (sourceText, filename, unitIndex) {\r\n            var svGenTarget = TypeScript.moduleGenTarget;\r\n            try  {\r\n                TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Local;\r\n                var script = this.parse(sourceText, filename, unitIndex, TypeScript.AllowedElements.QuickParse);\r\n                return new QuickParseResult(script, this.scanner.lexState);\r\n            }finally {\r\n                TypeScript.moduleGenTarget = svGenTarget;\r\n            }\r\n        };\r\n        Parser.prototype.parse = function (sourceText, filename, unitIndex, allowedElements) {\r\n            if (typeof allowedElements === \"undefined\") { allowedElements = TypeScript.AllowedElements.Global; }\r\n            this.ambientModule = false;\r\n            this.topLevel = true;\r\n            this.parseError = false;\r\n            this.hasTopLevelImportOrExport = false;\r\n            this.fname = filename;\r\n            this.currentUnitIndex = unitIndex;\r\n            this.amdDependencies = [];\r\n            this.scanner.resetComments();\r\n            this.scanner.setSourceText(sourceText, TypeScript.LexMode.File);\r\n            var leftCurlyCount = this.scanner.leftCurlyCount;\r\n            var rightCurlyCount = this.scanner.rightCurlyCount;\r\n            var minChar = this.scanner.pos;\r\n            this.tok = this.scanner.scan();\r\n            this.pushDeclLists();\r\n            var bod = new TypeScript.ASTList();\r\n            bod.minChar = minChar;\r\n            this.state = ParseState.StartScript;\r\n            this.parsingDeclareFile = TypeScript.isDSTRFile(filename) || TypeScript.isDTSFile(filename);\r\n            this.parseStmtList(TypeScript.ErrorRecoverySet.EOF | TypeScript.ErrorRecoverySet.Func, bod, true, false, allowedElements, TypeScript.Modifiers.None);\r\n            if(this.tok.tokenId != TypeScript.TokenID.EOF) {\r\n                var badToken = TypeScript.tokenTable[this.tok.tokenId];\r\n                this.reportParseError(\"Unexpected statement block terminator '\" + badToken.text + \"'\");\r\n            }\r\n            this.state = ParseState.EndScript;\r\n            bod.limChar = this.scanner.pos;\r\n            var topLevelMod = null;\r\n            if(TypeScript.moduleGenTarget != TypeScript.ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {\r\n                var correctedFileName = TypeScript.switchToForwardSlashes(filename);\r\n                var id = new TypeScript.Identifier(correctedFileName);\r\n                topLevelMod = new TypeScript.ModuleDecl(id, bod, this.topVarList(), this.topScopeList());\r\n                topLevelMod.modFlags |= TypeScript.ModuleFlags.IsDynamic;\r\n                topLevelMod.modFlags |= TypeScript.ModuleFlags.IsWholeFile;\r\n                topLevelMod.modFlags |= TypeScript.ModuleFlags.Exported;\r\n                if(this.parsingDeclareFile) {\r\n                    topLevelMod.modFlags |= TypeScript.ModuleFlags.Ambient;\r\n                }\r\n                topLevelMod.minChar = minChar;\r\n                topLevelMod.limChar = this.scanner.pos;\r\n                topLevelMod.prettyName = TypeScript.getPrettyName(correctedFileName);\r\n                topLevelMod.amdDependencies = this.amdDependencies;\r\n                bod = new TypeScript.ASTList();\r\n                bod.minChar = topLevelMod.minChar;\r\n                bod.limChar = topLevelMod.limChar;\r\n                bod.append(topLevelMod);\r\n            }\r\n            var script = new TypeScript.Script(this.topVarList(), this.topScopeList());\r\n            script.bod = bod;\r\n            this.popDeclLists();\r\n            script.minChar = minChar;\r\n            script.limChar = this.scanner.pos;\r\n            script.locationInfo = new TypeScript.LocationInfo(filename, this.scanner.lineMap, unitIndex);\r\n            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;\r\n            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;\r\n            script.isDeclareFile = this.parsingDeclareFile;\r\n            script.topLevelMod = topLevelMod;\r\n            return script;\r\n        };\r\n        return Parser;\r\n    })();\r\n    TypeScript.Parser = Parser;    \r\n    function quickParse(logger, scopeStartAST, sourceText, minChar, limChar, errorCapture) {\r\n        var fragment = sourceText.getText(minChar, limChar);\r\n        logger.log(\"Quick parse range (\" + minChar + \",\" + limChar + \"): \\\"\" + TypeScript.stringToLiteral(fragment, 100) + \"\\\"\");\r\n        var quickParser = new Parser();\r\n        quickParser.setErrorRecovery(null, -1, -1);\r\n        quickParser.errorCallback = errorCapture;\r\n        var quickClassDecl = new TypeScript.TypeDecl(TypeScript.NodeType.Class, null, null, null, null, null);\r\n        quickParser.currentClassDecl = quickClassDecl;\r\n        var result = quickParser.quickParse(new TypeScript.StringSourceText(fragment), \"\", 0);\r\n        return result;\r\n    }\r\n    TypeScript.quickParse = quickParse;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var PrintContext = (function () {\r\n        function PrintContext(outfile, parser) {\r\n            this.outfile = outfile;\r\n            this.parser = parser;\r\n            this.builder = \"\";\r\n            this.indent1 = \"  \";\r\n            this.indentStrings = [];\r\n            this.indentAmt = 0;\r\n        }\r\n        PrintContext.prototype.increaseIndent = function () {\r\n            this.indentAmt++;\r\n        };\r\n        PrintContext.prototype.decreaseIndent = function () {\r\n            this.indentAmt--;\r\n        };\r\n        PrintContext.prototype.startLine = function () {\r\n            if(this.builder.length > 0) {\r\n                TypeScript.CompilerDiagnostics.Alert(this.builder);\r\n            }\r\n            var indentString = this.indentStrings[this.indentAmt];\r\n            if(indentString === undefined) {\r\n                indentString = \"\";\r\n                for(var i = 0; i < this.indentAmt; i++) {\r\n                    indentString += this.indent1;\r\n                }\r\n                this.indentStrings[this.indentAmt] = indentString;\r\n            }\r\n            this.builder += indentString;\r\n        };\r\n        PrintContext.prototype.write = function (s) {\r\n            this.builder += s;\r\n        };\r\n        PrintContext.prototype.writeLine = function (s) {\r\n            this.builder += s;\r\n            this.outfile.WriteLine(this.builder);\r\n            this.builder = \"\";\r\n        };\r\n        return PrintContext;\r\n    })();\r\n    TypeScript.PrintContext = PrintContext;    \r\n    function prePrintAST(ast, parent, walker) {\r\n        var pc = walker.state;\r\n        ast.print(pc);\r\n        pc.increaseIndent();\r\n        return ast;\r\n    }\r\n    TypeScript.prePrintAST = prePrintAST;\r\n    function postPrintAST(ast, parent, walker) {\r\n        var pc = walker.state;\r\n        pc.decreaseIndent();\r\n        return ast;\r\n    }\r\n    TypeScript.postPrintAST = postPrintAST;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    TypeScript.LexEOF = (-1);\r\n    TypeScript.LexCodeNWL = 10;\r\n    TypeScript.LexCodeRET = 13;\r\n    TypeScript.LexCodeTAB = 9;\r\n    TypeScript.LexCodeVTAB = 11;\r\n    TypeScript.LexCode_e = 'e'.charCodeAt(0);\r\n    TypeScript.LexCode_E = 'E'.charCodeAt(0);\r\n    TypeScript.LexCode_x = 'x'.charCodeAt(0);\r\n    TypeScript.LexCode_X = 'X'.charCodeAt(0);\r\n    TypeScript.LexCode_a = 'a'.charCodeAt(0);\r\n    TypeScript.LexCode_A = 'A'.charCodeAt(0);\r\n    TypeScript.LexCode_f = 'f'.charCodeAt(0);\r\n    TypeScript.LexCode_F = 'F'.charCodeAt(0);\r\n    TypeScript.LexCode_g = 'g'.charCodeAt(0);\r\n    TypeScript.LexCode_m = 'm'.charCodeAt(0);\r\n    TypeScript.LexCode_i = 'i'.charCodeAt(0);\r\n    TypeScript.LexCode_0 = '0'.charCodeAt(0);\r\n    TypeScript.LexCode_9 = '9'.charCodeAt(0);\r\n    TypeScript.LexCode_8 = '8'.charCodeAt(0);\r\n    TypeScript.LexCode_7 = '7'.charCodeAt(0);\r\n    TypeScript.LexCodeBSL = '\\\\'.charCodeAt(0);\r\n    TypeScript.LexCodeSHP = '#'.charCodeAt(0);\r\n    TypeScript.LexCodeBNG = '!'.charCodeAt(0);\r\n    TypeScript.LexCodeQUO = '\"'.charCodeAt(0);\r\n    TypeScript.LexCodeAPO = '\\''.charCodeAt(0);\r\n    TypeScript.LexCodePCT = '%'.charCodeAt(0);\r\n    TypeScript.LexCodeAMP = '&'.charCodeAt(0);\r\n    TypeScript.LexCodeLPR = '('.charCodeAt(0);\r\n    TypeScript.LexCodeRPR = ')'.charCodeAt(0);\r\n    TypeScript.LexCodePLS = '+'.charCodeAt(0);\r\n    TypeScript.LexCodeMIN = '-'.charCodeAt(0);\r\n    TypeScript.LexCodeMUL = '*'.charCodeAt(0);\r\n    TypeScript.LexCodeSLH = '/'.charCodeAt(0);\r\n    TypeScript.LexCodeXOR = '^'.charCodeAt(0);\r\n    TypeScript.LexCodeCMA = ','.charCodeAt(0);\r\n    TypeScript.LexCodeDOT = '.'.charCodeAt(0);\r\n    TypeScript.LexCodeLT = '<'.charCodeAt(0);\r\n    TypeScript.LexCodeEQ = '='.charCodeAt(0);\r\n    TypeScript.LexCodeGT = '>'.charCodeAt(0);\r\n    TypeScript.LexCodeQUE = '?'.charCodeAt(0);\r\n    TypeScript.LexCodeLBR = '['.charCodeAt(0);\r\n    TypeScript.LexCodeRBR = ']'.charCodeAt(0);\r\n    TypeScript.LexCodeUSC = '_'.charCodeAt(0);\r\n    TypeScript.LexCodeLC = '{'.charCodeAt(0);\r\n    TypeScript.LexCodeRC = '}'.charCodeAt(0);\r\n    TypeScript.LexCodeBAR = '|'.charCodeAt(0);\r\n    TypeScript.LexCodeTIL = '~'.charCodeAt(0);\r\n    TypeScript.LexCodeCOL = ':'.charCodeAt(0);\r\n    TypeScript.LexCodeSMC = ';'.charCodeAt(0);\r\n    TypeScript.LexCodeUnderscore = '_'.charCodeAt(0);\r\n    TypeScript.LexCodeDollar = '$'.charCodeAt(0);\r\n    TypeScript.LexCodeSpace = 32;\r\n    TypeScript.LexKeywordTable = undefined;\r\n    var autoToken = new Array(128);\r\n    var lexIdStartTable = new Array(128);\r\n    function LexInitialize() {\r\n        TypeScript.initializeStaticTokens();\r\n        autoToken[TypeScript.LexCodeLPR] = TypeScript.staticTokens[TypeScript.TokenID.LParen];\r\n        autoToken[TypeScript.LexCodeRPR] = TypeScript.staticTokens[TypeScript.TokenID.RParen];\r\n        autoToken[TypeScript.LexCodeCMA] = TypeScript.staticTokens[TypeScript.TokenID.Comma];\r\n        autoToken[TypeScript.LexCodeSMC] = TypeScript.staticTokens[TypeScript.TokenID.SColon];\r\n        autoToken[TypeScript.LexCodeLBR] = TypeScript.staticTokens[TypeScript.TokenID.LBrack];\r\n        autoToken[TypeScript.LexCodeRBR] = TypeScript.staticTokens[TypeScript.TokenID.RBrack];\r\n        autoToken[TypeScript.LexCodeTIL] = TypeScript.staticTokens[TypeScript.TokenID.Tilde];\r\n        autoToken[TypeScript.LexCodeQUE] = TypeScript.staticTokens[TypeScript.TokenID.QMark];\r\n        autoToken[TypeScript.LexCodeLC] = TypeScript.staticTokens[TypeScript.TokenID.LCurly];\r\n        autoToken[TypeScript.LexCodeRC] = TypeScript.staticTokens[TypeScript.TokenID.RCurly];\r\n        autoToken[TypeScript.LexCodeCOL] = TypeScript.staticTokens[TypeScript.TokenID.Colon];\r\n        TypeScript.LexKeywordTable = new TypeScript.StringHashTable();\r\n        for(var i in (TypeScript.TokenID)._map) {\r\n            if((i) <= TypeScript.TokenID.LimKeyword) {\r\n                TypeScript.LexKeywordTable.add((TypeScript.TokenID)._map[i].toLowerCase(), i);\r\n            }\r\n        }\r\n        for(var j = 0; j < 128; j++) {\r\n            if(LexIsIdentifierStartChar(j)) {\r\n                lexIdStartTable[j] = true;\r\n            } else {\r\n                lexIdStartTable[j] = false;\r\n            }\r\n        }\r\n    }\r\n    TypeScript.LexInitialize = LexInitialize;\r\n    function LexAdjustIndent(code, indentAmt) {\r\n        if((code == TypeScript.LexCodeLBR) || (code == TypeScript.LexCodeLC) || (code == TypeScript.LexCodeLPR)) {\r\n            return indentAmt + 1;\r\n        } else {\r\n            if((code == TypeScript.LexCodeRBR) || (code == TypeScript.LexCodeRC) || (code == TypeScript.LexCodeRPR)) {\r\n                return indentAmt - 1;\r\n            } else {\r\n                return indentAmt;\r\n            }\r\n        }\r\n    }\r\n    TypeScript.LexAdjustIndent = LexAdjustIndent;\r\n    function LexIsIdentifierStartChar(code) {\r\n        return (((code >= 97) && (code <= 122)) || ((code >= 65) && (code <= 90)) || (code == TypeScript.LexCodeDollar) || (code == TypeScript.LexCodeUnderscore));\r\n    }\r\n    TypeScript.LexIsIdentifierStartChar = LexIsIdentifierStartChar;\r\n    function LexIsDigit(code) {\r\n        return ((code >= 48) && (code <= 57));\r\n    }\r\n    TypeScript.LexIsDigit = LexIsDigit;\r\n    function LexIsIdentifierChar(code) {\r\n        return lexIdStartTable[code] || LexIsDigit(code);\r\n    }\r\n    TypeScript.LexIsIdentifierChar = LexIsIdentifierChar;\r\n    function LexMatchingOpen(code) {\r\n        if(code == TypeScript.LexCodeRBR) {\r\n            return TypeScript.LexCodeLBR;\r\n        } else {\r\n            if(code == TypeScript.LexCodeRC) {\r\n                return TypeScript.LexCodeLC;\r\n            } else {\r\n                if(code == TypeScript.LexCodeRPR) {\r\n                    return TypeScript.LexCodeLPR;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    TypeScript.LexMatchingOpen = LexMatchingOpen;\r\n    (function (NumberScanState) {\r\n        NumberScanState._map = [];\r\n        NumberScanState._map[0] = \"Start\";\r\n        NumberScanState.Start = 0;\r\n        NumberScanState._map[1] = \"InFraction\";\r\n        NumberScanState.InFraction = 1;\r\n        NumberScanState._map[2] = \"InExponent\";\r\n        NumberScanState.InExponent = 2;\r\n    })(TypeScript.NumberScanState || (TypeScript.NumberScanState = {}));\r\n    var NumberScanState = TypeScript.NumberScanState;\r\n\r\n    (function (LexState) {\r\n        LexState._map = [];\r\n        LexState._map[0] = \"Start\";\r\n        LexState.Start = 0;\r\n        LexState._map[1] = \"InMultilineComment\";\r\n        LexState.InMultilineComment = 1;\r\n    })(TypeScript.LexState || (TypeScript.LexState = {}));\r\n    var LexState = TypeScript.LexState;\r\n\r\n    (function (LexMode) {\r\n        LexMode._map = [];\r\n        LexMode._map[0] = \"Line\";\r\n        LexMode.Line = 0;\r\n        LexMode._map[1] = \"File\";\r\n        LexMode.File = 1;\r\n    })(TypeScript.LexMode || (TypeScript.LexMode = {}));\r\n    var LexMode = TypeScript.LexMode;\r\n\r\n    (function (CommentStyle) {\r\n        CommentStyle._map = [];\r\n        CommentStyle._map[0] = \"Line\";\r\n        CommentStyle.Line = 0;\r\n        CommentStyle._map[1] = \"Block\";\r\n        CommentStyle.Block = 1;\r\n    })(TypeScript.CommentStyle || (TypeScript.CommentStyle = {}));\r\n    var CommentStyle = TypeScript.CommentStyle;\r\n\r\n    var StringSourceText = (function () {\r\n        function StringSourceText(text) {\r\n            this.text = text;\r\n        }\r\n        StringSourceText.prototype.getText = function (start, end) {\r\n            return this.text.substring(start, end);\r\n        };\r\n        StringSourceText.prototype.getLength = function () {\r\n            return this.text.length;\r\n        };\r\n        return StringSourceText;\r\n    })();\r\n    TypeScript.StringSourceText = StringSourceText;    \r\n    var SourceTextSegment = (function () {\r\n        function SourceTextSegment(segmentStart, segmentEnd, segment) {\r\n            this.segmentStart = segmentStart;\r\n            this.segmentEnd = segmentEnd;\r\n            this.segment = segment;\r\n        }\r\n        SourceTextSegment.prototype.charCodeAt = function (index) {\r\n            return this.segment.charCodeAt(index - this.segmentStart);\r\n        };\r\n        SourceTextSegment.prototype.substring = function (start, end) {\r\n            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);\r\n        };\r\n        return SourceTextSegment;\r\n    })();\r\n    TypeScript.SourceTextSegment = SourceTextSegment;    \r\n    var AggerateSourceTextSegment = (function () {\r\n        function AggerateSourceTextSegment(seg1, seg2) {\r\n            this.seg1 = seg1;\r\n            this.seg2 = seg2;\r\n        }\r\n        AggerateSourceTextSegment.prototype.charCodeAt = function (index) {\r\n            if(this.seg1.segmentStart <= index && index < this.seg1.segmentEnd) {\r\n                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);\r\n            }\r\n            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);\r\n        };\r\n        AggerateSourceTextSegment.prototype.substring = function (start, end) {\r\n            if(this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd) {\r\n                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);\r\n            }\r\n            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substring(0, end - this.seg1.segmentStart);\r\n        };\r\n        return AggerateSourceTextSegment;\r\n    })();\r\n    TypeScript.AggerateSourceTextSegment = AggerateSourceTextSegment;    \r\n    var ScannerTextStream = (function () {\r\n        function ScannerTextStream(sourceText) {\r\n            this.sourceText = sourceText;\r\n            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment);\r\n            this.len = this.sourceText.getLength();\r\n        }\r\n        ScannerTextStream.emptySegment = new SourceTextSegment(0, 0, \"\");\r\n        ScannerTextStream.prototype.max = function (a, b) {\r\n            return a >= b ? a : b;\r\n        };\r\n        ScannerTextStream.prototype.min = function (a, b) {\r\n            return a <= b ? a : b;\r\n        };\r\n        ScannerTextStream.prototype.fetchSegment = function (start, end) {\r\n            if(this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd) {\r\n                return this.agg.seg1;\r\n            }\r\n            if(this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd) {\r\n                return this.agg;\r\n            }\r\n            var prev = this.agg.seg1;\r\n            var s = prev.segmentEnd;\r\n            var e = TypeScript.max(s + 512, end);\r\n            e = TypeScript.min(e, this.len);\r\n            var src = this.sourceText.getText(s, e);\r\n            var newSeg = new SourceTextSegment(s, e, src);\r\n            this.agg.seg2 = prev;\r\n            this.agg.seg1 = newSeg;\r\n            return this.agg;\r\n        };\r\n        ScannerTextStream.prototype.charCodeAt = function (index) {\r\n            return this.fetchSegment(index, index + 1).charCodeAt(index);\r\n        };\r\n        ScannerTextStream.prototype.substring = function (start, end) {\r\n            return this.fetchSegment(start, end).substring(start, end);\r\n        };\r\n        return ScannerTextStream;\r\n    })();\r\n    TypeScript.ScannerTextStream = ScannerTextStream;    \r\n    var SavedTokens = (function () {\r\n        function SavedTokens() {\r\n            this.prevToken = null;\r\n            this.curSavedToken = null;\r\n            this.prevSavedToken = null;\r\n            this.prevToken = null;\r\n            this.currentToken = 0;\r\n            this.tokens = new Array();\r\n            this.prevLine = 1;\r\n            this.line = 1;\r\n            this.col = 0;\r\n            this.lexState = LexState.Start;\r\n            this.commentStack = new Array();\r\n        }\r\n        SavedTokens.prototype.previousToken = function () {\r\n            return this.prevToken;\r\n        };\r\n        SavedTokens.prototype.close = function () {\r\n            this.currentToken = 0;\r\n        };\r\n        SavedTokens.prototype.addToken = function (tok, scanner) {\r\n            this.tokens[this.currentToken++] = new TypeScript.SavedToken(tok, scanner.startPos, scanner.pos);\r\n        };\r\n        SavedTokens.prototype.scan = function () {\r\n            this.startLine = this.line;\r\n            this.startPos = this.col;\r\n            if(this.currentTokenIndex == this.currentTokens.length) {\r\n                if(this.line < this.lineMap.length) {\r\n                    this.line++;\r\n                    this.col = 0;\r\n                    this.currentTokenIndex = 0;\r\n                    this.currentTokens = this.tokensByLine[this.line];\r\n                } else {\r\n                    return TypeScript.staticTokens[TypeScript.TokenID.EOF];\r\n                }\r\n            }\r\n            if(this.currentTokenIndex < this.currentTokens.length) {\r\n                this.prevToken = this.curSavedToken.tok;\r\n                this.prevSavedToken = this.curSavedToken;\r\n                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];\r\n                var curToken = this.curSavedToken.tok;\r\n                this.pos = this.curSavedToken.limChar;\r\n                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);\r\n                this.startPos = this.curSavedToken.minChar;\r\n                this.prevLine = this.line;\r\n                return curToken;\r\n            } else {\r\n                return TypeScript.staticTokens[TypeScript.TokenID.EOF];\r\n            }\r\n        };\r\n        SavedTokens.prototype.syncToTok = function (offset) {\r\n            this.line = getLineNumberFromPosition(this.lineMap, offset);\r\n            this.currentTokenIndex = 0;\r\n            var tmpCol = offset - this.lineMap[this.line];\r\n            while((this.lexStateByLine[this.line] == LexState.InMultilineComment) && (this.line > 0)) {\r\n                this.line--;\r\n                tmpCol = 0;\r\n            }\r\n            var lenMin1 = this.lineMap.length - 1;\r\n            this.currentTokens = this.tokensByLine[this.line];\r\n            while((this.currentTokens.length == 0) && (this.line < lenMin1)) {\r\n                this.line++;\r\n                this.currentTokens = this.tokensByLine[this.line];\r\n                tmpCol = 0;\r\n            }\r\n            if(this.line <= lenMin1) {\r\n                while((this.currentTokenIndex < this.currentTokens.length) && (tmpCol > this.currentTokens[this.currentTokenIndex].limChar)) {\r\n                    this.currentTokenIndex++;\r\n                }\r\n                if(this.currentTokenIndex < this.currentTokens.length) {\r\n                    this.col = this.currentTokens[this.currentTokenIndex].minChar;\r\n                    return this.col + this.lineMap[this.line];\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        SavedTokens.prototype.lastTokenLimChar = function () {\r\n            if(this.prevSavedToken !== null) {\r\n                return this.prevSavedToken.limChar;\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n        SavedTokens.prototype.lastTokenHadNewline = function () {\r\n            return this.prevLine != this.startLine;\r\n        };\r\n        SavedTokens.prototype.pushComment = function (comment) {\r\n            this.commentStack.push(comment);\r\n        };\r\n        SavedTokens.prototype.getComments = function () {\r\n            var stack = this.commentStack;\r\n            this.commentStack = [];\r\n            return stack;\r\n        };\r\n        SavedTokens.prototype.getCommentsForLine = function (line) {\r\n            var comments = null;\r\n            while((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\r\n                if(comments == null) {\r\n                    comments = [\r\n                        this.commentStack.shift()\r\n                    ];\r\n                } else {\r\n                    comments = comments.concat([\r\n                        this.commentStack.shift()\r\n                    ]);\r\n                }\r\n            }\r\n            return comments;\r\n        };\r\n        SavedTokens.prototype.resetComments = function () {\r\n            this.commentStack = [];\r\n        };\r\n        SavedTokens.prototype.setSourceText = function (newSrc, textMode) {\r\n        };\r\n        return SavedTokens;\r\n    })();\r\n    TypeScript.SavedTokens = SavedTokens;    \r\n    var Scanner = (function () {\r\n        function Scanner() {\r\n            this.prevLine = 1;\r\n            this.line = 1;\r\n            this.col = 0;\r\n            this.pos = 0;\r\n            this.startPos = 0;\r\n            this.len = 0;\r\n            this.lineMap = [];\r\n            this.ch = TypeScript.LexEOF;\r\n            this.lexState = LexState.Start;\r\n            this.mode = LexMode.File;\r\n            this.scanComments = true;\r\n            this.interveningWhitespace = false;\r\n            this.interveningWhitespacePos = 0;\r\n            this.leftCurlyCount = 0;\r\n            this.rightCurlyCount = 0;\r\n            this.commentStack = new Array();\r\n            this.saveScan = null;\r\n            this.prevTok = TypeScript.staticTokens[TypeScript.TokenID.EOF];\r\n            this.startCol = this.col;\r\n            this.startLine = this.line;\r\n            this.lineMap[1] = 0;\r\n            if(!TypeScript.LexKeywordTable) {\r\n                LexInitialize();\r\n            }\r\n        }\r\n        Scanner.prototype.previousToken = function () {\r\n            return this.prevTok;\r\n        };\r\n        Scanner.prototype.setSourceText = function (newSrc, textMode) {\r\n            this.mode = textMode;\r\n            this.scanComments = (this.mode === LexMode.Line);\r\n            this.pos = 0;\r\n            this.interveningWhitespacePos = 0;\r\n            this.startPos = 0;\r\n            this.line = 1;\r\n            this.col = 0;\r\n            this.startCol = this.col;\r\n            this.startLine = this.line;\r\n            this.len = 0;\r\n            this.src = newSrc.getText(0, newSrc.getLength());\r\n            this.len = this.src.length;\r\n            this.lineMap = [];\r\n            this.lineMap[1] = 0;\r\n            this.commentStack = [];\r\n            this.leftCurlyCount = 0;\r\n            this.rightCurlyCount = 0;\r\n        };\r\n        Scanner.prototype.setSaveScan = function (savedTokens) {\r\n            this.saveScan = savedTokens;\r\n        };\r\n        Scanner.prototype.setText = function (newSrc, textMode) {\r\n            this.setSourceText(new StringSourceText(newSrc), textMode);\r\n        };\r\n        Scanner.prototype.setScanComments = function (value) {\r\n            this.scanComments = value;\r\n        };\r\n        Scanner.prototype.getLexState = function () {\r\n            return this.lexState;\r\n        };\r\n        Scanner.prototype.scanLine = function (line, initialState) {\r\n            this.lexState = initialState;\r\n            var result = new Array();\r\n            this.setText(line, LexMode.Line);\r\n            var t = this.scan();\r\n            while(t.tokenId != TypeScript.TokenID.EOF) {\r\n                result[result.length] = t;\r\n                t = this.scan();\r\n            }\r\n            return result;\r\n        };\r\n        Scanner.prototype.tokenStart = function () {\r\n            this.startPos = this.pos;\r\n            this.startLine = this.line;\r\n            this.startCol = this.col;\r\n            this.interveningWhitespace = false;\r\n        };\r\n        Scanner.prototype.peekChar = function () {\r\n            if(this.pos < this.len) {\r\n                return this.src.charCodeAt(this.pos);\r\n            } else {\r\n                return TypeScript.LexEOF;\r\n            }\r\n        };\r\n        Scanner.prototype.peekCharAt = function (index) {\r\n            if(index < this.len) {\r\n                return this.src.charCodeAt(index);\r\n            } else {\r\n                return TypeScript.LexEOF;\r\n            }\r\n        };\r\n        Scanner.prototype.IsHexDigit = function (c) {\r\n            return ((c >= TypeScript.LexCode_0) && (c <= TypeScript.LexCode_9)) || ((c >= TypeScript.LexCode_A) && (c <= TypeScript.LexCode_F)) || ((c >= TypeScript.LexCode_a) && (c <= TypeScript.LexCode_f));\r\n        };\r\n        Scanner.prototype.IsOctalDigit = function (c) {\r\n            return ((c >= TypeScript.LexCode_0) && (c <= TypeScript.LexCode_7)) || ((c >= TypeScript.LexCode_a) && (c <= TypeScript.LexCode_f));\r\n        };\r\n        Scanner.prototype.scanHexDigits = function () {\r\n            var atLeastOneDigit = false;\r\n            for(; ; ) {\r\n                if(this.IsHexDigit(this.ch)) {\r\n                    this.nextChar();\r\n                    atLeastOneDigit = true;\r\n                } else {\r\n                    if(atLeastOneDigit) {\r\n                        return new TypeScript.NumberToken(parseInt(this.src.substring(this.startPos, this.pos)));\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Scanner.prototype.scanOctalDigits = function () {\r\n            var atLeastOneDigit = false;\r\n            for(; ; ) {\r\n                if(this.IsOctalDigit(this.ch)) {\r\n                    this.nextChar();\r\n                    atLeastOneDigit = true;\r\n                } else {\r\n                    if(atLeastOneDigit) {\r\n                        return new TypeScript.NumberToken(parseInt(this.src.substring(this.startPos, this.pos)));\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Scanner.prototype.scanDecimalNumber = function (state) {\r\n            var atLeastOneDigit = false;\r\n            var svPos = this.pos;\r\n            var svCol = this.col;\r\n            for(; ; ) {\r\n                if(LexIsDigit(this.ch)) {\r\n                    atLeastOneDigit = true;\r\n                    this.nextChar();\r\n                } else {\r\n                    if(this.ch == TypeScript.LexCodeDOT) {\r\n                        if(state == NumberScanState.Start) {\r\n                            this.nextChar();\r\n                            state = NumberScanState.InFraction;\r\n                        } else {\r\n                            if(atLeastOneDigit) {\r\n                                return new TypeScript.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\r\n                            } else {\r\n                                this.pos = svPos;\r\n                                this.col = svCol;\r\n                                return null;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if((this.ch == TypeScript.LexCode_e) || (this.ch == TypeScript.LexCode_E)) {\r\n                            if(state == NumberScanState.Start) {\r\n                                if(atLeastOneDigit) {\r\n                                    atLeastOneDigit = false;\r\n                                    this.nextChar();\r\n                                    state = NumberScanState.InExponent;\r\n                                } else {\r\n                                    this.pos = svPos;\r\n                                    this.col = svCol;\r\n                                    return null;\r\n                                }\r\n                            } else {\r\n                                if(state == NumberScanState.InFraction) {\r\n                                    this.nextChar();\r\n                                    state = NumberScanState.InExponent;\r\n                                    atLeastOneDigit = false;\r\n                                } else {\r\n                                    if(atLeastOneDigit) {\r\n                                        return new TypeScript.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\r\n                                    } else {\r\n                                        this.pos = svPos;\r\n                                        this.col = svCol;\r\n                                        return null;\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if((this.ch == TypeScript.LexCodePLS) || (this.ch == TypeScript.LexCodeMIN)) {\r\n                                if(state == NumberScanState.InExponent) {\r\n                                    if(!atLeastOneDigit) {\r\n                                        this.nextChar();\r\n                                    } else {\r\n                                        this.pos = svPos;\r\n                                        this.col = svCol;\r\n                                        return null;\r\n                                    }\r\n                                } else {\r\n                                    if(state == NumberScanState.InFraction) {\r\n                                        return new TypeScript.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\r\n                                    } else {\r\n                                        if(!atLeastOneDigit) {\r\n                                            this.pos = svPos;\r\n                                            this.col = svCol;\r\n                                            return null;\r\n                                        } else {\r\n                                            return new TypeScript.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                if(!atLeastOneDigit) {\r\n                                    this.pos = svPos;\r\n                                    this.col = svCol;\r\n                                    return null;\r\n                                } else {\r\n                                    return new TypeScript.NumberToken(parseFloat(this.src.substring(this.startPos, this.pos)));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Scanner.prototype.scanNumber = function () {\r\n            if(this.peekChar() == TypeScript.LexCode_0) {\r\n                switch(this.peekCharAt(this.pos + 1)) {\r\n                    case TypeScript.LexCode_x:\r\n                    case TypeScript.LexCode_X: {\r\n                        this.advanceChar(2);\r\n                        return this.scanHexDigits();\r\n\r\n                    }\r\n                    case TypeScript.LexCode_8:\r\n                    case TypeScript.LexCode_9:\r\n                    case TypeScript.LexCodeDOT: {\r\n                        return this.scanDecimalNumber(NumberScanState.Start);\r\n\r\n                    }\r\n                    default: {\r\n                        return this.scanOctalDigits();\r\n\r\n                    }\r\n                }\r\n            } else {\r\n                return this.scanDecimalNumber(NumberScanState.Start);\r\n            }\r\n        };\r\n        Scanner.prototype.scanFraction = function () {\r\n            return this.scanDecimalNumber(NumberScanState.InFraction);\r\n        };\r\n        Scanner.prototype.newLine = function () {\r\n            this.col = 0;\r\n            if(this.mode == LexMode.File) {\r\n                this.line++;\r\n                this.lineMap[this.line] = this.pos + 1;\r\n            }\r\n        };\r\n        Scanner.prototype.finishMultilineComment = function () {\r\n            var ch2;\r\n            this.lexState = LexState.InMultilineComment;\r\n            while(this.pos < this.len) {\r\n                if(this.ch == TypeScript.LexCodeMUL) {\r\n                    ch2 = this.peekCharAt(this.pos + 1);\r\n                    if(ch2 == TypeScript.LexCodeSLH) {\r\n                        this.advanceChar(2);\r\n                        if(this.mode == LexMode.File) {\r\n                            this.tokenStart();\r\n                        }\r\n                        this.lexState = LexState.Start;\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if(this.ch == TypeScript.LexCodeNWL) {\r\n                        this.newLine();\r\n                        if(this.mode == LexMode.Line) {\r\n                            this.nextChar();\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                this.nextChar();\r\n            }\r\n            return false;\r\n        };\r\n        Scanner.prototype.pushComment = function (comment) {\r\n            this.commentStack.push(comment);\r\n        };\r\n        Scanner.prototype.getComments = function () {\r\n            var stack = this.commentStack;\r\n            this.commentStack = [];\r\n            return stack;\r\n        };\r\n        Scanner.prototype.getCommentsForLine = function (line) {\r\n            var comments = null;\r\n            while((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {\r\n                if(comments == null) {\r\n                    comments = [\r\n                        this.commentStack.shift()\r\n                    ];\r\n                } else {\r\n                    comments = comments.concat([\r\n                        this.commentStack.shift()\r\n                    ]);\r\n                }\r\n            }\r\n            return comments;\r\n        };\r\n        Scanner.prototype.resetComments = function () {\r\n            this.commentStack = [];\r\n        };\r\n        Scanner.prototype.endsLine = function (c) {\r\n            return (c == TypeScript.LexCodeNWL) || (c == TypeScript.LexCodeRET) || (c == 8232) || (c == 8233);\r\n        };\r\n        Scanner.prototype.finishSinglelineComment = function () {\r\n            while(this.pos < this.len) {\r\n                if(this.endsLine(this.ch)) {\r\n                    break;\r\n                }\r\n                this.nextChar();\r\n            }\r\n            if(this.mode == LexMode.File) {\r\n                this.tokenStart();\r\n            }\r\n        };\r\n        Scanner.prototype.tokenText = function () {\r\n            return this.src.substring(this.startPos, this.pos);\r\n        };\r\n        Scanner.prototype.findClosingSLH = function () {\r\n            var index = this.pos;\r\n            var ch2 = this.src.charCodeAt(index);\r\n            var prevCh = 0;\r\n            var liveEsc = false;\r\n            while(!this.endsLine(ch2) && (index < this.len)) {\r\n                if((ch2 == TypeScript.LexCodeSLH) && (!liveEsc)) {\r\n                    return index;\r\n                }\r\n                prevCh = ch2;\r\n                index++;\r\n                if(liveEsc) {\r\n                    liveEsc = false;\r\n                } else {\r\n                    liveEsc = (prevCh == TypeScript.LexCodeBSL);\r\n                }\r\n                ch2 = this.src.charCodeAt(index);\r\n            }\r\n            return -1;\r\n        };\r\n        Scanner.prototype.speculateRegex = function () {\r\n            if(TypeScript.noRegexTable[this.prevTok.tokenId] != undefined) {\r\n                return null;\r\n            }\r\n            var svPos = this.pos;\r\n            var svCol = this.col;\r\n            var index = this.findClosingSLH();\r\n            if(index > 0) {\r\n                var pattern = this.src.substring(svPos, index);\r\n                var flags = \"\";\r\n                this.pos = index + 1;\r\n                this.ch = this.peekChar();\r\n                var flagsStart = this.pos;\r\n                while((this.ch == TypeScript.LexCode_i) || (this.ch == TypeScript.LexCode_g) || (this.ch == TypeScript.LexCode_m)) {\r\n                    this.nextChar();\r\n                }\r\n                if((this.pos - flagsStart) > 3) {\r\n                    return null;\r\n                } else {\r\n                    flags = this.src.substring(flagsStart, this.pos);\r\n                }\r\n                var regex = undefined;\r\n                try  {\r\n                    regex = new RegExp(pattern, flags);\r\n                } catch (regexException) {\r\n                }\r\n                if(regex) {\r\n                    this.col = svCol + (this.pos - this.startPos);\r\n                    return new TypeScript.RegexToken(regex);\r\n                }\r\n            }\r\n            this.pos = svPos;\r\n            this.col = svCol;\r\n            return null;\r\n        };\r\n        Scanner.prototype.lastTokenHadNewline = function () {\r\n            return this.prevLine != this.startLine;\r\n        };\r\n        Scanner.prototype.lastTokenLimChar = function () {\r\n            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;\r\n        };\r\n        Scanner.prototype.advanceChar = function (amt) {\r\n            this.pos += amt;\r\n            this.col += amt;\r\n            this.ch = this.peekChar();\r\n        };\r\n        Scanner.prototype.nextChar = function () {\r\n            this.pos++;\r\n            this.col++;\r\n            this.ch = this.peekChar();\r\n        };\r\n        Scanner.prototype.scan = function () {\r\n            if((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {\r\n                this.ch = this.peekChar();\r\n                var commentLine = this.line;\r\n                this.finishMultilineComment();\r\n                if(this.startPos < this.pos) {\r\n                    var commentText = this.src.substring(this.startPos, this.pos);\r\n                    this.tokenStart();\r\n                    return new TypeScript.CommentToken(TypeScript.TokenID.Comment, commentText, true, this.startPos, commentLine, true);\r\n                } else {\r\n                    return TypeScript.staticTokens[TypeScript.TokenID.EOF];\r\n                }\r\n            }\r\n            this.prevLine = this.line;\r\n            this.prevTok = this.innerScan();\r\n            if(this.saveScan) {\r\n                this.saveScan.addToken(this.prevTok, this);\r\n            }\r\n            return this.prevTok;\r\n        };\r\n        Scanner.prototype.innerScan = function () {\r\n            var rtok;\r\n            this.tokenStart();\r\n            this.ch = this.peekChar();\r\n            while(this.pos < this.len) {\r\n                if(lexIdStartTable[this.ch]) {\r\n                    do {\r\n                        this.nextChar();\r\n                    }while(lexIdStartTable[this.ch] || LexIsDigit(this.ch))\r\n                    var idText = this.src.substring(this.startPos, this.pos);\r\n                    var id;\r\n                    if((id = TypeScript.LexKeywordTable.lookup(idText)) != null) {\r\n                        return TypeScript.staticTokens[id];\r\n                    } else {\r\n                        return new TypeScript.StringToken(TypeScript.TokenID.ID, idText);\r\n                    }\r\n                } else {\r\n                    if(this.ch == TypeScript.LexCodeSpace) {\r\n                        if(!this.interveningWhitespace) {\r\n                            this.interveningWhitespacePos = this.pos;\r\n                        }\r\n                        do {\r\n                            this.nextChar();\r\n                        }while(this.ch == TypeScript.LexCodeSpace)\r\n                        if(this.mode == LexMode.Line) {\r\n                            var whitespaceText = this.src.substring(this.startPos, this.pos);\r\n                            return new TypeScript.WhitespaceToken(TypeScript.TokenID.Whitespace, whitespaceText);\r\n                        } else {\r\n                            this.tokenStart();\r\n                            this.interveningWhitespace = true;\r\n                        }\r\n                    } else {\r\n                        if(this.ch == TypeScript.LexCodeSLH) {\r\n                            this.nextChar();\r\n                            var commentText;\r\n                            if(this.ch == TypeScript.LexCodeSLH) {\r\n                                if(!this.interveningWhitespace) {\r\n                                    this.interveningWhitespacePos = this.pos - 1;\r\n                                }\r\n                                var commentStartPos = this.pos - 1;\r\n                                var commentStartLine = this.line;\r\n                                this.finishSinglelineComment();\r\n                                var commentText = this.src.substring(commentStartPos, this.pos);\r\n                                var commentToken = new TypeScript.CommentToken(TypeScript.TokenID.Comment, commentText, false, commentStartPos, commentStartLine, false);\r\n                                if(this.scanComments) {\r\n                                    this.startPos = commentStartPos;\r\n                                    return commentToken;\r\n                                } else {\r\n                                    this.pushComment(commentToken);\r\n                                }\r\n                                this.interveningWhitespace = true;\r\n                            } else {\r\n                                if(this.ch == TypeScript.LexCodeMUL) {\r\n                                    if(!this.interveningWhitespace) {\r\n                                        this.interveningWhitespacePos = this.pos - 1;\r\n                                    }\r\n                                    var commentStartPos = this.pos - 1;\r\n                                    var commentStartLine = this.line;\r\n                                    this.nextChar();\r\n                                    this.finishMultilineComment();\r\n                                    var commentText = this.src.substring(commentStartPos, this.pos);\r\n                                    var endsLine = this.peekChar() == TypeScript.LexCodeNWL || this.peekChar() == TypeScript.LexCodeRET;\r\n                                    var commentToken = new TypeScript.CommentToken(TypeScript.TokenID.Comment, commentText, true, commentStartPos, commentStartLine, endsLine);\r\n                                    if(this.scanComments) {\r\n                                        this.startPos = commentStartPos;\r\n                                        return commentToken;\r\n                                    } else {\r\n                                        this.pushComment(commentToken);\r\n                                    }\r\n                                    this.interveningWhitespace = true;\r\n                                } else {\r\n                                    var regexTok = this.speculateRegex();\r\n                                    if(regexTok) {\r\n                                        return regexTok;\r\n                                    } else {\r\n                                        if(this.peekCharAt(this.pos) == TypeScript.LexCodeEQ) {\r\n                                            this.nextChar();\r\n                                            return TypeScript.staticTokens[TypeScript.TokenID.AsgDiv];\r\n                                        } else {\r\n                                            return TypeScript.staticTokens[TypeScript.TokenID.Div];\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if(this.ch == TypeScript.LexCodeSMC) {\r\n                                this.nextChar();\r\n                                return TypeScript.staticTokens[TypeScript.TokenID.SColon];\r\n                            } else {\r\n                                if((this.ch == TypeScript.LexCodeAPO) || (this.ch == TypeScript.LexCodeQUO)) {\r\n                                    var endCode = this.ch;\r\n                                    var prevCh = 0;\r\n                                    var liveEsc = false;\r\n                                    do {\r\n                                        prevCh = this.ch;\r\n                                        if(liveEsc) {\r\n                                            liveEsc = false;\r\n                                        } else {\r\n                                            liveEsc = (prevCh == TypeScript.LexCodeBSL);\r\n                                        }\r\n                                        this.nextChar();\r\n                                    }while((this.ch != TypeScript.LexEOF) && (liveEsc || (this.ch != endCode)))\r\n                                    if(this.ch != TypeScript.LexEOF) {\r\n                                        this.nextChar();\r\n                                    }\r\n                                    return new TypeScript.StringToken(TypeScript.TokenID.QString, this.src.substring(this.startPos, this.pos));\r\n                                } else {\r\n                                    if(autoToken[this.ch]) {\r\n                                        var atok = autoToken[this.ch];\r\n                                        if(atok.tokenId == TypeScript.TokenID.LCurly) {\r\n                                            this.leftCurlyCount++;\r\n                                        } else {\r\n                                            if(atok.tokenId == TypeScript.TokenID.RCurly) {\r\n                                                this.rightCurlyCount++;\r\n                                            }\r\n                                        }\r\n                                        this.nextChar();\r\n                                        return atok;\r\n                                    } else {\r\n                                        if((this.ch >= TypeScript.LexCode_0) && (this.ch <= TypeScript.LexCode_9)) {\r\n                                            rtok = this.scanNumber();\r\n                                            if(rtok) {\r\n                                                return rtok;\r\n                                            } else {\r\n                                                this.nextChar();\r\n                                                return TypeScript.staticTokens[TypeScript.TokenID.Error];\r\n                                            }\r\n                                        } else {\r\n                                            switch(this.ch) {\r\n                                                case TypeScript.LexCodeTAB:\r\n                                                case TypeScript.LexCodeVTAB: {\r\n                                                    if(!this.interveningWhitespace) {\r\n                                                        this.interveningWhitespacePos = this.pos;\r\n                                                    }\r\n                                                    if(this.mode == LexMode.Line) {\r\n                                                        do {\r\n                                                            this.nextChar();\r\n                                                        }while((this.ch == TypeScript.LexCodeSpace) || (this.ch == 9))\r\n                                                        var wsText = this.src.substring(this.startPos, this.pos);\r\n                                                        return new TypeScript.WhitespaceToken(TypeScript.TokenID.Whitespace, wsText);\r\n                                                    } else {\r\n                                                        this.interveningWhitespace = true;\r\n                                                    }\r\n\r\n                                                }\r\n                                                case 255:\r\n                                                case 254:\r\n                                                case 239:\r\n                                                case 187:\r\n                                                case 191:\r\n                                                case 8232:\r\n                                                case 8233:\r\n                                                case TypeScript.LexCodeNWL:\r\n                                                case TypeScript.LexCodeRET: {\r\n                                                    if(this.ch == TypeScript.LexCodeNWL) {\r\n                                                        this.newLine();\r\n                                                        if(this.mode == LexMode.Line) {\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.EOF];\r\n                                                        }\r\n                                                    }\r\n                                                    if(!this.interveningWhitespace) {\r\n                                                        this.interveningWhitespacePos = this.pos;\r\n                                                    }\r\n                                                    this.nextChar();\r\n                                                    this.tokenStart();\r\n                                                    this.interveningWhitespace = true;\r\n                                                    break;\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeDOT: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeDOT) {\r\n                                                        if(this.peekCharAt(this.pos + 2) == TypeScript.LexCodeDOT) {\r\n                                                            this.advanceChar(3);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Ellipsis];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Dot];\r\n                                                        }\r\n                                                    } else {\r\n                                                        this.nextChar();\r\n                                                        rtok = this.scanFraction();\r\n                                                        if(rtok) {\r\n                                                            return rtok;\r\n                                                        } else {\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Dot];\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                case TypeScript.LexCodeEQ: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        if(this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {\r\n                                                            this.advanceChar(3);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Eqv];\r\n                                                        } else {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.EQ];\r\n                                                        }\r\n                                                    } else {\r\n                                                        if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeGT) {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Arrow];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Asg];\r\n                                                        }\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeBNG: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        if(this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {\r\n                                                            this.advanceChar(3);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.NEqv];\r\n                                                        } else {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.NE];\r\n                                                        }\r\n                                                    } else {\r\n                                                        this.nextChar();\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.Bang];\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodePLS: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        this.advanceChar(2);\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.AsgAdd];\r\n                                                    } else {\r\n                                                        if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodePLS) {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Inc];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Add];\r\n                                                        }\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeMIN: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        this.advanceChar(2);\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.AsgSub];\r\n                                                    } else {\r\n                                                        if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeMIN) {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Dec];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Sub];\r\n                                                        }\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeMUL: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        this.advanceChar(2);\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.AsgMul];\r\n                                                    } else {\r\n                                                        this.nextChar();\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.Mult];\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodePCT: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        this.advanceChar(2);\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.AsgMod];\r\n                                                    } else {\r\n                                                        this.nextChar();\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.Pct];\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeLT: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeLT) {\r\n                                                        if(this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {\r\n                                                            this.advanceChar(3);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.AsgLsh];\r\n                                                        } else {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Lsh];\r\n                                                        }\r\n                                                    } else {\r\n                                                        if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.LE];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.LT];\r\n                                                        }\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeGT: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeGT) {\r\n                                                        if(this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {\r\n                                                            this.advanceChar(3);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.AsgRsh];\r\n                                                        } else {\r\n                                                            if(this.peekCharAt(this.pos + 2) == TypeScript.LexCodeGT) {\r\n                                                                if(this.peekCharAt(this.pos + 3) == TypeScript.LexCodeEQ) {\r\n                                                                    this.advanceChar(4);\r\n                                                                    return TypeScript.staticTokens[TypeScript.TokenID.AsgRs2];\r\n                                                                } else {\r\n                                                                    this.advanceChar(3);\r\n                                                                    return TypeScript.staticTokens[TypeScript.TokenID.Rs2];\r\n                                                                }\r\n                                                            } else {\r\n                                                                this.advanceChar(2);\r\n                                                                return TypeScript.staticTokens[TypeScript.TokenID.Rsh];\r\n                                                            }\r\n                                                        }\r\n                                                    } else {\r\n                                                        if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.GE];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.GT];\r\n                                                        }\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeXOR: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        this.advanceChar(2);\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.AsgXor];\r\n                                                    } else {\r\n                                                        this.nextChar();\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.Xor];\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeBAR: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        this.advanceChar(2);\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.AsgOr];\r\n                                                    } else {\r\n                                                        if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeBAR) {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.LogOr];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.Or];\r\n                                                        }\r\n                                                    }\r\n\r\n                                                }\r\n                                                case TypeScript.LexCodeAMP: {\r\n                                                    if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {\r\n                                                        this.advanceChar(2);\r\n                                                        return TypeScript.staticTokens[TypeScript.TokenID.AsgAnd];\r\n                                                    } else {\r\n                                                        if(this.peekCharAt(this.pos + 1) == TypeScript.LexCodeAMP) {\r\n                                                            this.advanceChar(2);\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.LogAnd];\r\n                                                        } else {\r\n                                                            this.nextChar();\r\n                                                            return TypeScript.staticTokens[TypeScript.TokenID.And];\r\n                                                        }\r\n                                                    }\r\n\r\n                                                }\r\n                                                default: {\r\n                                                    return TypeScript.staticTokens[TypeScript.TokenID.EOF];\r\n\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return TypeScript.staticTokens[TypeScript.TokenID.EOF];\r\n        };\r\n        return Scanner;\r\n    })();\r\n    TypeScript.Scanner = Scanner;    \r\n    function convertTokToIDName(tok) {\r\n        return convertTokToIDBase(tok, true, false);\r\n    }\r\n    TypeScript.convertTokToIDName = convertTokToIDName;\r\n    function convertTokToID(tok, strictMode) {\r\n        return convertTokToIDBase(tok, false, strictMode);\r\n    }\r\n    TypeScript.convertTokToID = convertTokToID;\r\n    function convertTokToIDBase(tok, identifierName, strictMode) {\r\n        if(tok.tokenId <= TypeScript.TokenID.LimKeyword) {\r\n            var tokInfo = TypeScript.lookupToken(tok.tokenId);\r\n            if(tokInfo != undefined) {\r\n                var resFlags = TypeScript.Reservation.Javascript | TypeScript.Reservation.JavascriptFuture;\r\n                if(strictMode) {\r\n                    resFlags |= TypeScript.Reservation.JavascriptFutureStrict;\r\n                }\r\n                if(identifierName || !TypeScript.hasFlag(tokInfo.reservation, resFlags)) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function getLineNumberFromPosition(lineMap, position) {\r\n        if(position === -1) {\r\n            return 0;\r\n        }\r\n        var min = 0;\r\n        var max = lineMap.length - 1;\r\n        while(min < max) {\r\n            var med = (min + max) >> 1;\r\n            if(position < lineMap[med]) {\r\n                max = med - 1;\r\n            } else {\r\n                if(position < lineMap[med + 1]) {\r\n                    min = max = med;\r\n                } else {\r\n                    min = med + 1;\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    TypeScript.getLineNumberFromPosition = getLineNumberFromPosition;\r\n    function getSourceLineColFromMap(lineCol, minChar, lineMap) {\r\n        var line = getLineNumberFromPosition(lineMap, minChar);\r\n        if(line > 0) {\r\n            lineCol.line = line;\r\n            lineCol.col = (minChar - lineMap[line]);\r\n        }\r\n    }\r\n    TypeScript.getSourceLineColFromMap = getSourceLineColFromMap;\r\n    function getLineColumnFromPosition(script, position) {\r\n        var result = {\r\n            line: -1,\r\n            col: -1\r\n        };\r\n        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);\r\n        if(result.col >= 0) {\r\n            result.col++;\r\n        }\r\n        return result;\r\n    }\r\n    TypeScript.getLineColumnFromPosition = getLineColumnFromPosition;\r\n    function getPositionFromLineColumn(script, line, column) {\r\n        return script.locationInfo.lineMap[line] + (column - 1);\r\n    }\r\n    TypeScript.getPositionFromLineColumn = getPositionFromLineColumn;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var AssignScopeContext = (function () {\r\n        function AssignScopeContext(scopeChain, typeFlow, modDeclChain) {\r\n            this.scopeChain = scopeChain;\r\n            this.typeFlow = typeFlow;\r\n            this.modDeclChain = modDeclChain;\r\n        }\r\n        return AssignScopeContext;\r\n    })();\r\n    TypeScript.AssignScopeContext = AssignScopeContext;    \r\n    function pushAssignScope(scope, context, type, classType, fnc) {\r\n        var chain = new TypeScript.ScopeChain(null, context.scopeChain, scope);\r\n        chain.thisType = type;\r\n        chain.classType = classType;\r\n        chain.fnc = fnc;\r\n        context.scopeChain = chain;\r\n    }\r\n    TypeScript.pushAssignScope = pushAssignScope;\r\n    function popAssignScope(context) {\r\n        context.scopeChain = context.scopeChain.previous;\r\n    }\r\n    TypeScript.popAssignScope = popAssignScope;\r\n    function instanceCompare(a, b) {\r\n        if(((a == null) || (!a.isInstanceProperty()))) {\r\n            return b;\r\n        } else {\r\n            return a;\r\n        }\r\n    }\r\n    TypeScript.instanceCompare = instanceCompare;\r\n    function instanceFilterStop(s) {\r\n        return s.isInstanceProperty();\r\n    }\r\n    TypeScript.instanceFilterStop = instanceFilterStop;\r\n    var ScopeSearchFilter = (function () {\r\n        function ScopeSearchFilter(select, stop) {\r\n            this.select = select;\r\n            this.stop = stop;\r\n            this.result = null;\r\n        }\r\n        ScopeSearchFilter.prototype.reset = function () {\r\n            this.result = null;\r\n        };\r\n        ScopeSearchFilter.prototype.update = function (b) {\r\n            this.result = this.select(this.result, b);\r\n            if(this.result) {\r\n                return this.stop(this.result);\r\n            } else {\r\n                return false;\r\n            }\r\n        };\r\n        return ScopeSearchFilter;\r\n    })();\r\n    TypeScript.ScopeSearchFilter = ScopeSearchFilter;    \r\n    TypeScript.instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);\r\n    function preAssignModuleScopes(ast, context) {\r\n        var moduleDecl = ast;\r\n        var memberScope = null;\r\n        var aggScope = null;\r\n        if(moduleDecl.name && moduleDecl.mod) {\r\n            moduleDecl.name.sym = moduleDecl.mod.symbol;\r\n        }\r\n        var mod = moduleDecl.mod;\r\n        if(!mod) {\r\n            return;\r\n        }\r\n        memberScope = new TypeScript.SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);\r\n        mod.memberScope = memberScope;\r\n        context.modDeclChain.push(moduleDecl);\r\n        context.typeFlow.checker.currentModDecl = moduleDecl;\r\n        aggScope = new TypeScript.SymbolAggregateScope(mod.symbol);\r\n        aggScope.addParentScope(memberScope);\r\n        aggScope.addParentScope(context.scopeChain.scope);\r\n        pushAssignScope(aggScope, context, null, null, null);\r\n        mod.containedScope = aggScope;\r\n        if(mod.symbol) {\r\n            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);\r\n        }\r\n    }\r\n    TypeScript.preAssignModuleScopes = preAssignModuleScopes;\r\n    function preAssignClassScopes(ast, context) {\r\n        var classDecl = ast;\r\n        var memberScope = null;\r\n        var aggScope = null;\r\n        if(classDecl.name && classDecl.type) {\r\n            classDecl.name.sym = classDecl.type.symbol;\r\n        }\r\n        var classType = ast.type;\r\n        if(classType) {\r\n            var classSym = classType.symbol;\r\n            memberScope = context.typeFlow.checker.scopeOf(classType);\r\n            aggScope = new TypeScript.SymbolAggregateScope(classType.symbol);\r\n            aggScope.addParentScope(memberScope);\r\n            aggScope.addParentScope(context.scopeChain.scope);\r\n            classType.containedScope = aggScope;\r\n            classType.memberScope = memberScope;\r\n            var instanceType = classType.instanceType;\r\n            memberScope = context.typeFlow.checker.scopeOf(instanceType);\r\n            instanceType.memberScope = memberScope;\r\n            aggScope = new TypeScript.SymbolAggregateScope(instanceType.symbol);\r\n            aggScope.addParentScope(context.scopeChain.scope);\r\n            pushAssignScope(aggScope, context, instanceType, classType, null);\r\n            instanceType.containedScope = aggScope;\r\n        } else {\r\n            ast.type = context.typeFlow.anyType;\r\n        }\r\n    }\r\n    TypeScript.preAssignClassScopes = preAssignClassScopes;\r\n    function preAssignInterfaceScopes(ast, context) {\r\n        var interfaceDecl = ast;\r\n        var memberScope = null;\r\n        var aggScope = null;\r\n        if(interfaceDecl.name && interfaceDecl.type) {\r\n            interfaceDecl.name.sym = interfaceDecl.type.symbol;\r\n        }\r\n        var interfaceType = ast.type;\r\n        memberScope = context.typeFlow.checker.scopeOf(interfaceType);\r\n        interfaceType.memberScope = memberScope;\r\n        aggScope = new TypeScript.SymbolAggregateScope(interfaceType.symbol);\r\n        aggScope.addParentScope(memberScope);\r\n        aggScope.addParentScope(context.scopeChain.scope);\r\n        pushAssignScope(aggScope, context, null, null, null);\r\n        interfaceType.containedScope = aggScope;\r\n    }\r\n    TypeScript.preAssignInterfaceScopes = preAssignInterfaceScopes;\r\n    function preAssignWithScopes(ast, context) {\r\n        var withStmt = ast;\r\n        var withType = withStmt.type;\r\n        var members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n        var ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n        var withType = new TypeScript.Type();\r\n        var withSymbol = new TypeScript.WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);\r\n        withType.members = members;\r\n        withType.ambientMembers = ambientMembers;\r\n        withType.symbol = withSymbol;\r\n        withType.setHasImplementation();\r\n        withStmt.type = withType;\r\n        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);\r\n        pushAssignScope(withScope, context, null, null, null);\r\n        withType.containedScope = withScope;\r\n    }\r\n    TypeScript.preAssignWithScopes = preAssignWithScopes;\r\n    function preAssignFuncDeclScopes(ast, context) {\r\n        var funcDecl = ast;\r\n        var container = null;\r\n        var localContainer = null;\r\n        if(funcDecl.type) {\r\n            localContainer = ast.type.symbol;\r\n        }\r\n        var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Static);\r\n        var isInnerStatic = isStatic && context.scopeChain.fnc != null;\r\n        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;\r\n        if(context.scopeChain.thisType && (!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod))) {\r\n            var instType = context.scopeChain.thisType;\r\n            if(!(instType.typeFlags & TypeScript.TypeFlags.IsClass) && !TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) {\r\n                if(!funcDecl.isMethod() || isStatic) {\r\n                    parentScope = instType.constructorScope;\r\n                } else {\r\n                    parentScope = instType.containedScope;\r\n                }\r\n            } else {\r\n                if(context.scopeChain.previous.scope.container && context.scopeChain.previous.scope.container.declAST && context.scopeChain.previous.scope.container.declAST.nodeType == TypeScript.NodeType.FuncDecl && (context.scopeChain.previous.scope.container.declAST).isConstructor) {\r\n                    parentScope = instType.constructorScope;\r\n                } else {\r\n                    if(isStatic && context.scopeChain.classType) {\r\n                        parentScope = context.scopeChain.classType.containedScope;\r\n                    } else {\r\n                        parentScope = instType.containedScope;\r\n                    }\r\n                }\r\n            }\r\n            container = instType.symbol;\r\n        } else {\r\n            if(funcDecl.isConstructor && context.scopeChain.thisType) {\r\n                container = context.scopeChain.thisType.symbol;\r\n            }\r\n        }\r\n        if(funcDecl.type == null || TypeScript.hasFlag(funcDecl.type.symbol.flags, TypeScript.SymbolFlags.TypeSetDuringScopeAssignment)) {\r\n            if(context.scopeChain.fnc && context.scopeChain.fnc.type) {\r\n                container = context.scopeChain.fnc.type.symbol;\r\n            }\r\n            var funcScope = null;\r\n            var outerFnc = context.scopeChain.fnc;\r\n            var nameText = funcDecl.name ? funcDecl.name.text : null;\r\n            var fgSym = null;\r\n            if(isStatic) {\r\n                if(outerFnc.type.members == null && container.getType().memberScope) {\r\n                    outerFnc.type.members = ((container).type.memberScope).valueMembers;\r\n                }\r\n                funcScope = context.scopeChain.fnc.type.memberScope;\r\n                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;\r\n            } else {\r\n                if(!funcDecl.isConstructor && container && container.declAST && container.declAST.nodeType == TypeScript.NodeType.FuncDecl && (container.declAST).isConstructor && !funcDecl.isMethod()) {\r\n                    funcScope = context.scopeChain.thisType.constructorScope;\r\n                } else {\r\n                    funcScope = context.scopeChain.scope;\r\n                }\r\n            }\r\n            if(nameText && nameText != \"__missing\" && !funcDecl.isAccessor()) {\r\n                if(isStatic) {\r\n                    fgSym = funcScope.findLocal(nameText, false, false);\r\n                } else {\r\n                    fgSym = funcScope.findLocal(nameText, false, false);\r\n                }\r\n            }\r\n            context.typeFlow.checker.createFunctionSignature(funcDecl, container, funcScope, fgSym, fgSym == null);\r\n            if(!funcDecl.accessorSymbol && (funcDecl.fncFlags & TypeScript.FncFlags.ClassMethod) && container && ((!fgSym || fgSym.declAST.nodeType != TypeScript.NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {\r\n                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);\r\n            }\r\n            funcDecl.type.symbol.flags |= TypeScript.SymbolFlags.TypeSetDuringScopeAssignment;\r\n        }\r\n        if(funcDecl.name && funcDecl.type) {\r\n            funcDecl.name.sym = funcDecl.type.symbol;\r\n        }\r\n        funcDecl.scopeType = funcDecl.type;\r\n        if(funcDecl.isOverload) {\r\n            return;\r\n        }\r\n        var funcTable = new TypeScript.StringHashTable();\r\n        var funcMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(funcTable, new TypeScript.StringHashTable()));\r\n        var ambientFuncTable = new TypeScript.StringHashTable();\r\n        var ambientFuncMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(ambientFuncTable, new TypeScript.StringHashTable()));\r\n        var funcStaticTable = new TypeScript.StringHashTable();\r\n        var funcStaticMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(funcStaticTable, new TypeScript.StringHashTable()));\r\n        var ambientFuncStaticTable = new TypeScript.StringHashTable();\r\n        var ambientFuncStaticMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(ambientFuncStaticTable, new TypeScript.StringHashTable()));\r\n        funcDecl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;\r\n        var locals = new TypeScript.SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);\r\n        var statics = new TypeScript.SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);\r\n        if(funcDecl.isConstructor && context.scopeChain.thisType) {\r\n            context.scopeChain.thisType.constructorScope = locals;\r\n        }\r\n        funcDecl.symbols = funcTable;\r\n        if(!funcDecl.isSpecialFn()) {\r\n            var group = funcDecl.type;\r\n            var signature = funcDecl.signature;\r\n            if(!funcDecl.isConstructor) {\r\n                group.containedScope = locals;\r\n                locals.container = group.symbol;\r\n                group.memberScope = statics;\r\n                statics.container = group.symbol;\r\n            }\r\n            funcDecl.enclosingFnc = context.scopeChain.fnc;\r\n            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;\r\n            var fgSym = ast.type.symbol;\r\n            if(((funcDecl.fncFlags & TypeScript.FncFlags.Signature) == TypeScript.FncFlags.None) && funcDecl.vars) {\r\n                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars, funcTable, false);\r\n                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics, funcStaticTable, false);\r\n            }\r\n            if(signature.parameters) {\r\n                var len = signature.parameters.length;\r\n                for(var i = 0; i < len; i++) {\r\n                    var paramSym = signature.parameters[i];\r\n                    context.typeFlow.checker.resolveTypeLink(locals, paramSym.parameter.typeLink, true);\r\n                }\r\n            }\r\n            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType, funcDecl.isSignature());\r\n        }\r\n        if(!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) {\r\n            var thisType = (funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) ? context.scopeChain.thisType : null;\r\n            pushAssignScope(locals, context, thisType, null, funcDecl);\r\n        }\r\n    }\r\n    TypeScript.preAssignFuncDeclScopes = preAssignFuncDeclScopes;\r\n    function preAssignCatchScopes(ast, context) {\r\n        var catchBlock = ast;\r\n        if(catchBlock.param) {\r\n            var catchTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            var catchLocals = new TypeScript.SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope, context.scopeChain.scope.container);\r\n            catchBlock.containedScope = catchLocals;\r\n            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);\r\n        }\r\n    }\r\n    TypeScript.preAssignCatchScopes = preAssignCatchScopes;\r\n    function preAssignScopes(ast, parent, walker) {\r\n        var context = walker.state;\r\n        var go = true;\r\n        if(ast) {\r\n            if(ast.nodeType == TypeScript.NodeType.List) {\r\n                var list = ast;\r\n                list.enclosingScope = context.scopeChain.scope;\r\n            } else {\r\n                if(ast.nodeType == TypeScript.NodeType.Module) {\r\n                    preAssignModuleScopes(ast, context);\r\n                } else {\r\n                    if(ast.nodeType == TypeScript.NodeType.Class) {\r\n                        preAssignClassScopes(ast, context);\r\n                    } else {\r\n                        if(ast.nodeType == TypeScript.NodeType.Interface) {\r\n                            preAssignInterfaceScopes(ast, context);\r\n                        } else {\r\n                            if(ast.nodeType == TypeScript.NodeType.With) {\r\n                                preAssignWithScopes(ast, context);\r\n                            } else {\r\n                                if(ast.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                    preAssignFuncDeclScopes(ast, context);\r\n                                } else {\r\n                                    if(ast.nodeType == TypeScript.NodeType.Catch) {\r\n                                        preAssignCatchScopes(ast, context);\r\n                                    } else {\r\n                                        if(ast.nodeType == TypeScript.NodeType.TypeRef) {\r\n                                            go = false;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        walker.options.goChildren = go;\r\n        return ast;\r\n    }\r\n    TypeScript.preAssignScopes = preAssignScopes;\r\n    function postAssignScopes(ast, parent, walker) {\r\n        var context = walker.state;\r\n        var go = true;\r\n        if(ast) {\r\n            if(ast.nodeType == TypeScript.NodeType.Module) {\r\n                var prevModDecl = ast;\r\n                popAssignScope(context);\r\n                context.modDeclChain.pop();\r\n                if(context.modDeclChain.length >= 1) {\r\n                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];\r\n                }\r\n            } else {\r\n                if(ast.nodeType == TypeScript.NodeType.Class) {\r\n                    popAssignScope(context);\r\n                } else {\r\n                    if(ast.nodeType == TypeScript.NodeType.Interface) {\r\n                        popAssignScope(context);\r\n                    } else {\r\n                        if(ast.nodeType == TypeScript.NodeType.With) {\r\n                            popAssignScope(context);\r\n                        } else {\r\n                            if(ast.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                var funcDecl = ast;\r\n                                if((!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) && !funcDecl.isOverload) {\r\n                                    popAssignScope(context);\r\n                                }\r\n                            } else {\r\n                                if(ast.nodeType == TypeScript.NodeType.Catch) {\r\n                                    var catchBlock = ast;\r\n                                    if(catchBlock.param) {\r\n                                        popAssignScope(context);\r\n                                    }\r\n                                } else {\r\n                                    go = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        walker.options.goChildren = go;\r\n        return ast;\r\n    }\r\n    TypeScript.postAssignScopes = postAssignScopes;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var TypeCollectionContext = (function () {\r\n        function TypeCollectionContext(scopeChain, checker) {\r\n            this.scopeChain = scopeChain;\r\n            this.checker = checker;\r\n            this.script = null;\r\n        }\r\n        return TypeCollectionContext;\r\n    })();\r\n    TypeScript.TypeCollectionContext = TypeCollectionContext;    \r\n    var MemberScopeContext = (function () {\r\n        function MemberScopeContext(flow, pos, matchFlag) {\r\n            this.flow = flow;\r\n            this.pos = pos;\r\n            this.matchFlag = matchFlag;\r\n            this.type = null;\r\n            this.ast = null;\r\n            this.options = new TypeScript.AstWalkOptions();\r\n        }\r\n        return MemberScopeContext;\r\n    })();\r\n    TypeScript.MemberScopeContext = MemberScopeContext;    \r\n    var EnclosingScopeContext = (function () {\r\n        function EnclosingScopeContext(logger, script, text, pos, isMemberCompletion) {\r\n            this.logger = logger;\r\n            this.script = script;\r\n            this.text = text;\r\n            this.pos = pos;\r\n            this.isMemberCompletion = isMemberCompletion;\r\n            this.scopeGetter = null;\r\n            this.objectLiteralScopeGetter = null;\r\n            this.scopeStartAST = null;\r\n            this.skipNextFuncDeclForClass = false;\r\n            this.deepestModuleDecl = null;\r\n            this.enclosingClassDecl = null;\r\n            this.enclosingObjectLit = null;\r\n            this.publicsOnly = true;\r\n            this.useFullAst = false;\r\n        }\r\n        EnclosingScopeContext.prototype.getScope = function () {\r\n            return this.scopeGetter();\r\n        };\r\n        EnclosingScopeContext.prototype.getObjectLiteralScope = function () {\r\n            return this.objectLiteralScopeGetter();\r\n        };\r\n        EnclosingScopeContext.prototype.getScopeAST = function () {\r\n            return this.scopeStartAST;\r\n        };\r\n        EnclosingScopeContext.prototype.getScopePosition = function () {\r\n            return this.scopeStartAST.minChar;\r\n        };\r\n        EnclosingScopeContext.prototype.getScriptFragmentStartAST = function () {\r\n            return this.scopeStartAST;\r\n        };\r\n        EnclosingScopeContext.prototype.getScriptFragmentPosition = function () {\r\n            return this.getScriptFragmentStartAST().minChar;\r\n        };\r\n        EnclosingScopeContext.prototype.getScriptFragment = function () {\r\n            if(this.scriptFragment == null) {\r\n                var ast = this.getScriptFragmentStartAST();\r\n                var minChar = ast.minChar;\r\n                var limChar = (this.isMemberCompletion ? this.pos : this.pos + 1);\r\n                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null).Script;\r\n            }\r\n            return this.scriptFragment;\r\n        };\r\n        return EnclosingScopeContext;\r\n    })();\r\n    TypeScript.EnclosingScopeContext = EnclosingScopeContext;    \r\n    function preFindMemberScope(ast, parent, walker) {\r\n        var memScope = walker.state;\r\n        if(TypeScript.hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {\r\n            memScope.ast = ast;\r\n            if((ast.type == null) && (memScope.pos >= 0)) {\r\n                memScope.flow.inScopeTypeCheck(ast, memScope.scope);\r\n            }\r\n            memScope.type = ast.type;\r\n            memScope.options.stopWalk();\r\n        }\r\n        return ast;\r\n    }\r\n    TypeScript.preFindMemberScope = preFindMemberScope;\r\n    function pushTypeCollectionScope(container, valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, context, thisType, classType, moduleDecl) {\r\n        var builder = new TypeScript.SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);\r\n        var chain = new TypeScript.ScopeChain(container, context.scopeChain, builder);\r\n        chain.thisType = thisType;\r\n        chain.classType = classType;\r\n        chain.moduleDecl = moduleDecl;\r\n        context.scopeChain = chain;\r\n    }\r\n    TypeScript.pushTypeCollectionScope = pushTypeCollectionScope;\r\n    function popTypeCollectionScope(context) {\r\n        context.scopeChain = context.scopeChain.previous;\r\n    }\r\n    TypeScript.popTypeCollectionScope = popTypeCollectionScope;\r\n    function preFindEnclosingScope(ast, parent, walker) {\r\n        var context = walker.state;\r\n        var minChar = ast.minChar;\r\n        var limChar = ast.limChar;\r\n        if(ast.nodeType == TypeScript.NodeType.Script && context.pos > limChar) {\r\n            limChar = context.pos;\r\n        }\r\n        if((minChar <= context.pos) && (limChar >= context.pos)) {\r\n            switch(ast.nodeType) {\r\n                case TypeScript.NodeType.Script: {\r\n                    var script = ast;\r\n                    context.scopeGetter = function () {\r\n                        return script.bod === null ? null : script.bod.enclosingScope;\r\n                    };\r\n                    context.scopeStartAST = script;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Class: {\r\n                    context.scopeGetter = function () {\r\n                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;\r\n                    };\r\n                    context.scopeStartAST = ast;\r\n                    context.enclosingClassDecl = ast;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.ObjectLit: {\r\n                    var objectLit = ast;\r\n                    if(objectLit.targetType) {\r\n                        context.scopeGetter = function () {\r\n                            return objectLit.targetType.containedScope;\r\n                        };\r\n                        context.objectLiteralScopeGetter = function () {\r\n                            return objectLit.targetType.memberScope;\r\n                        };\r\n                        context.enclosingObjectLit = objectLit;\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Module: {\r\n                    context.deepestModuleDecl = ast;\r\n                    context.scopeGetter = function () {\r\n                        return ast.type === null ? null : ast.type.containedScope;\r\n                    };\r\n                    context.scopeStartAST = ast;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.Interface: {\r\n                    context.scopeGetter = function () {\r\n                        return (ast.type === null) ? null : ast.type.containedScope;\r\n                    };\r\n                    context.scopeStartAST = ast;\r\n                    break;\r\n\r\n                }\r\n                case TypeScript.NodeType.FuncDecl: {\r\n {\r\n                        var funcDecl = ast;\r\n                        if(context.skipNextFuncDeclForClass) {\r\n                            context.skipNextFuncDeclForClass = false;\r\n                        } else {\r\n                            context.scopeGetter = function () {\r\n                                if(funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) {\r\n                                    if(ast.type && ast.type.enclosingType) {\r\n                                        return ast.type.enclosingType.constructorScope;\r\n                                    }\r\n                                }\r\n                                if(funcDecl.scopeType) {\r\n                                    return funcDecl.scopeType.containedScope;\r\n                                }\r\n                                if(funcDecl.type) {\r\n                                    return funcDecl.type.containedScope;\r\n                                }\r\n                                return null;\r\n                            };\r\n                            context.scopeStartAST = ast;\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                }\r\n            }\r\n            walker.options.goChildren = true;\r\n        } else {\r\n            walker.options.goChildren = false;\r\n        }\r\n        return ast;\r\n    }\r\n    TypeScript.preFindEnclosingScope = preFindEnclosingScope;\r\n    function findEnclosingScopeAt(logger, script, text, pos, isMemberCompletion) {\r\n        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);\r\n        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);\r\n        if(context.scopeStartAST === null) {\r\n            return null;\r\n        }\r\n        return context;\r\n    }\r\n    TypeScript.findEnclosingScopeAt = findEnclosingScopeAt;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var Signature = (function () {\r\n        function Signature() {\r\n            this.hasVariableArgList = false;\r\n            this.parameters = null;\r\n            this.declAST = null;\r\n            this.typeCheckStatus = TypeScript.TypeCheckStatus.NotStarted;\r\n            this.nonOptionalParameterCount = 0;\r\n        }\r\n        Signature.prototype.specializeType = function (pattern, replacement, checker) {\r\n            var result = new Signature();\r\n            if(this.hasVariableArgList) {\r\n                result.hasVariableArgList = true;\r\n            }\r\n            result.returnType = new TypeScript.TypeLink();\r\n            if(this.returnType.type) {\r\n                result.returnType.type = this.returnType.type.specializeType(pattern, replacement, checker, false);\r\n            } else {\r\n                result.returnType.type = checker.anyType;\r\n            }\r\n            if(this.parameters) {\r\n                result.parameters = [];\r\n                for(var i = 0, len = this.parameters.length; i < len; i++) {\r\n                    var oldSym = this.parameters[i];\r\n                    var paramDef = new TypeScript.ValueLocation();\r\n                    var paramSym = new TypeScript.ParameterSymbol(oldSym.name, oldSym.location, checker.locationInfo.unitIndex, paramDef);\r\n                    paramSym.declAST = this.declAST;\r\n                    paramDef.symbol = paramSym;\r\n                    paramDef.typeLink = new TypeScript.TypeLink();\r\n                    result.parameters[i] = paramSym;\r\n                    var oldType = oldSym.getType();\r\n                    if(oldType) {\r\n                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);\r\n                        paramSym.declAST.type = paramDef.typeLink.type;\r\n                    } else {\r\n                        paramDef.typeLink.type = checker.anyType;\r\n                    }\r\n                }\r\n            }\r\n            result.nonOptionalParameterCount = this.nonOptionalParameterCount;\r\n            result.declAST = this.declAST;\r\n            return result;\r\n        };\r\n        Signature.prototype.toString = function () {\r\n            return this.toStringHelper(false, false, null);\r\n        };\r\n        Signature.prototype.toStringHelper = function (shortform, brackets, scope) {\r\n            var builder;\r\n            if(brackets) {\r\n                builder = \"[\";\r\n            } else {\r\n                builder = \"(\";\r\n            }\r\n            var len = this.parameters.length;\r\n            for(var i = 0; i < len; i++) {\r\n                builder += this.parameters[i].name + (this.parameters[i].isOptional() ? \"?\" : \"\") + \": \";\r\n                builder += this.parameters[i].getType().getScopedTypeName(scope);\r\n                if(i < len - 1) {\r\n                    builder += \",\";\r\n                }\r\n            }\r\n            if(shortform) {\r\n                if(brackets) {\r\n                    builder += \"] => \";\r\n                } else {\r\n                    builder += \") => \";\r\n                }\r\n            } else {\r\n                if(brackets) {\r\n                    builder += \"]: \";\r\n                } else {\r\n                    builder += \"): \";\r\n                }\r\n            }\r\n            if(this.returnType.type) {\r\n                builder += this.returnType.type.getScopedTypeName(scope);\r\n            } else {\r\n                builder += \"any\";\r\n            }\r\n            return builder;\r\n        };\r\n        return Signature;\r\n    })();\r\n    TypeScript.Signature = Signature;    \r\n    var SignatureGroup = (function () {\r\n        function SignatureGroup() {\r\n            this.signatures = [];\r\n            this.hasImplementation = true;\r\n            this.definitionSignature = null;\r\n            this.hasBeenTypechecked = false;\r\n            this.flags = TypeScript.SignatureFlags.None;\r\n        }\r\n        SignatureGroup.prototype.addSignature = function (signature) {\r\n            if(this.signatures == null) {\r\n                this.signatures = new Array();\r\n            }\r\n            this.signatures[this.signatures.length] = signature;\r\n            if(signature.declAST && !signature.declAST.isOverload && !signature.declAST.isSignature() && !TypeScript.hasFlag(signature.declAST.fncFlags, TypeScript.FncFlags.Ambient) && TypeScript.hasFlag(signature.declAST.fncFlags, TypeScript.FncFlags.Definition)) {\r\n                this.definitionSignature = signature;\r\n            }\r\n        };\r\n        SignatureGroup.prototype.toString = function () {\r\n            return this.signatures.toString();\r\n        };\r\n        SignatureGroup.prototype.toStrings = function (prefix, shortform, scope) {\r\n            var result = [];\r\n            var len = this.signatures.length;\r\n            if(len > 1) {\r\n                shortform = false;\r\n            }\r\n            for(var i = 0; i < len; i++) {\r\n                if(len > 1 && this.signatures[i] == this.definitionSignature) {\r\n                    continue;\r\n                }\r\n                if(this.flags & TypeScript.SignatureFlags.IsIndexer) {\r\n                    result[i] = this.signatures[i].toStringHelper(shortform, true, scope);\r\n                } else {\r\n                    result[i] = prefix + this.signatures[i].toStringHelper(shortform, false, scope);\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        SignatureGroup.prototype.specializeType = function (pattern, replacement, checker) {\r\n            var result = new SignatureGroup();\r\n            if(this.signatures) {\r\n                for(var i = 0, len = this.signatures.length; i < len; i++) {\r\n                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        SignatureGroup.prototype.verifySignatures = function (checker) {\r\n            var len = 0;\r\n            if(this.signatures && ((len = this.signatures.length) > 0)) {\r\n                for(var i = 0; i < len; i++) {\r\n                    for(var j = i + 1; j < len; j++) {\r\n                        if(this.signatures[i].declAST && this.signatures[j].declAST && (!TypeScript.hasFlag(this.signatures[i].declAST.fncFlags, TypeScript.FncFlags.Definition) && !TypeScript.hasFlag(this.signatures[j].declAST.fncFlags, TypeScript.FncFlags.Definition)) && checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {\r\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? \"Signature for '\" + this.signatures[i].declAST.name.text + \"' is duplicated\" : \"Signature is duplicated\");\r\n                        }\r\n                    }\r\n                    if(this.definitionSignature) {\r\n                        if(!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {\r\n                            checker.errorReporter.simpleError(this.signatures[i].declAST, \"Overload signature is not compatible with function definition\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        SignatureGroup.prototype.typeCheck = function (checker, ast, hasConstruct) {\r\n            if(this.hasBeenTypechecked) {\r\n                return;\r\n            }\r\n            this.hasBeenTypechecked = true;\r\n            var len = 0;\r\n            if(this.signatures && ((len = this.signatures.length) > 0)) {\r\n                for(var i = 0; i < len; i++) {\r\n                    if(!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !TypeScript.hasFlag(this.signatures[i].declAST.fncFlags, TypeScript.FncFlags.Ambient)) {\r\n                        checker.errorReporter.simpleError(this.signatures[i].declAST, \"Overload declaration lacks definition\");\r\n                    }\r\n                    if(this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeScript.TypeCheckStatus.NotStarted) {\r\n                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);\r\n                    }\r\n                    checker.typeFlow.typeCheck(this.signatures[i].declAST);\r\n                }\r\n                this.verifySignatures(checker);\r\n            }\r\n        };\r\n        return SignatureGroup;\r\n    })();\r\n    TypeScript.SignatureGroup = SignatureGroup;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (TypeCheckStatus) {\r\n        TypeCheckStatus._map = [];\r\n        TypeCheckStatus._map[0] = \"NotStarted\";\r\n        TypeCheckStatus.NotStarted = 0;\r\n        TypeCheckStatus._map[1] = \"Started\";\r\n        TypeCheckStatus.Started = 1;\r\n        TypeCheckStatus._map[2] = \"Finished\";\r\n        TypeCheckStatus.Finished = 2;\r\n    })(TypeScript.TypeCheckStatus || (TypeScript.TypeCheckStatus = {}));\r\n    var TypeCheckStatus = TypeScript.TypeCheckStatus;\r\n\r\n    function aLexicallyEnclosesB(a, b) {\r\n        if(a.declAST && b && b.declAST && a.declAST.nodeType == TypeScript.NodeType.FuncDecl) {\r\n            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    TypeScript.aLexicallyEnclosesB = aLexicallyEnclosesB;\r\n    function aEnclosesB(a, b) {\r\n        while(a.container) {\r\n            if(a == b || aLexicallyEnclosesB(a.container, b)) {\r\n                return true;\r\n            }\r\n            a = a.container;\r\n        }\r\n        return false;\r\n    }\r\n    TypeScript.aEnclosesB = aEnclosesB;\r\n    var Symbol = (function () {\r\n        function Symbol(name, location, unitIndex) {\r\n            this.name = name;\r\n            this.location = location;\r\n            this.unitIndex = unitIndex;\r\n            this.bound = false;\r\n            this.flags = TypeScript.SymbolFlags.None;\r\n            this.isObjectLitField = false;\r\n            this.declAST = null;\r\n            this.declModule = null;\r\n            this.passSymbolCreated = TypeScript.CompilerDiagnostics.analysisPass;\r\n        }\r\n        Symbol.prototype.instanceScope = function () {\r\n            return null;\r\n        };\r\n        Symbol.prototype.isVariable = function () {\r\n            return false;\r\n        };\r\n        Symbol.prototype.isMember = function () {\r\n            return false;\r\n        };\r\n        Symbol.prototype.isInferenceSymbol = function () {\r\n            return false;\r\n        };\r\n        Symbol.prototype.isWith = function () {\r\n            return false;\r\n        };\r\n        Symbol.prototype.writeable = function () {\r\n            return false;\r\n        };\r\n        Symbol.prototype.isType = function () {\r\n            return false;\r\n        };\r\n        Symbol.prototype.getType = function () {\r\n            return null;\r\n        };\r\n        Symbol.prototype.isAccessor = function () {\r\n            return false;\r\n        };\r\n        Symbol.prototype.isInstanceProperty = function () {\r\n            return TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Property) && (!TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.ModuleMember));\r\n        };\r\n        Symbol.prototype.getTypeName = function (scope) {\r\n            return this.toString();\r\n        };\r\n        Symbol.prototype.getOptionalNameString = function () {\r\n            return TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Optional) ? \"?\" : \"\";\r\n        };\r\n        Symbol.prototype.pathToRoot = function () {\r\n            var path = new Array();\r\n            var node = this;\r\n            while(node && (node.name != TypeScript.globalId)) {\r\n                path[path.length] = node;\r\n                node = node.container;\r\n            }\r\n            return path;\r\n        };\r\n        Symbol.prototype.findCommonAncestorPath = function (b) {\r\n            if(this.container == null) {\r\n                return new Array();\r\n            }\r\n            var aPath = this.container.pathToRoot();\r\n            var bPath;\r\n            if(b) {\r\n                bPath = b.pathToRoot();\r\n            } else {\r\n                bPath = new Array();\r\n            }\r\n            var commonNodeIndex = -1;\r\n            for(var i = 0, aLen = aPath.length; i < aLen; i++) {\r\n                var aNode = aPath[i];\r\n                for(var j = 0, bLen = bPath.length; j < bLen; j++) {\r\n                    var bNode = bPath[j];\r\n                    if(aNode == bNode) {\r\n                        commonNodeIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if(commonNodeIndex >= 0) {\r\n                    break;\r\n                }\r\n            }\r\n            if(commonNodeIndex >= 0) {\r\n                return aPath.slice(0, commonNodeIndex);\r\n            } else {\r\n                return aPath;\r\n            }\r\n        };\r\n        Symbol.prototype.scopeRelativeName = function (scope) {\r\n            if(scope == null) {\r\n                return this.name;\r\n            }\r\n            var lca = this.findCommonAncestorPath(scope.container);\r\n            var builder = \"\";\r\n            for(var i = 0, len = lca.length; i < len; i++) {\r\n                builder = lca[i].name + \".\" + builder;\r\n            }\r\n            builder += this.name;\r\n            return builder;\r\n        };\r\n        Symbol.prototype.fullName = function () {\r\n            var builder = this.name;\r\n            var ancestor = this.container;\r\n            while(ancestor && (ancestor.name != TypeScript.globalId)) {\r\n                builder = ancestor.name + \".\" + builder;\r\n                ancestor = ancestor.container;\r\n            }\r\n            return builder;\r\n        };\r\n        Symbol.prototype.visible = function (scope, checker) {\r\n            if(checker == null || this.container == checker.gloMod) {\r\n                return true;\r\n            }\r\n            if(TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.ModuleMember)) {\r\n                if(TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Exported)) {\r\n                    if(!TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Private)) {\r\n                        return true;\r\n                    } else {\r\n                        return aEnclosesB(this, scope.container);\r\n                    }\r\n                } else {\r\n                    return checker && (checker.currentModDecl == this.declModule) || (checker.currentModDecl && checker.currentModDecl.mod && checker.currentModDecl.mod.symbol && this.declModule && this.declModule.mod && this.declModule.mod.symbol && aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));\r\n                }\r\n            } else {\r\n                var isFunction = this.declAST && this.declAST.nodeType == TypeScript.NodeType.FuncDecl;\r\n                var isMethod = isFunction && (this.declAST).isMethod();\r\n                var isStaticFunction = isFunction && TypeScript.hasFlag((this.declAST).fncFlags, TypeScript.FncFlags.Static);\r\n                var isPrivateMethod = isMethod && TypeScript.hasFlag((this.declAST).fncFlags, TypeScript.FncFlags.Private);\r\n                var isAlias = this.isType() && (this).aliasLink;\r\n                if(this.isMember() || isMethod || isStaticFunction || isAlias) {\r\n                    if(TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Private) || isPrivateMethod) {\r\n                        if(scope.container == null && this.container != scope.container) {\r\n                            return false;\r\n                        } else {\r\n                            return this.container == null ? true : aEnclosesB(scope.container, this.container);\r\n                        }\r\n                    } else {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if(this.container) {\r\n                        return aEnclosesB(this, scope.container);\r\n                    } else {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Symbol.prototype.addRef = function (identifier) {\r\n            if(!this.refs) {\r\n                this.refs = [];\r\n            }\r\n            this.refs[this.refs.length] = identifier;\r\n        };\r\n        Symbol.prototype.toString = function () {\r\n            if(this.name) {\r\n                return this.name;\r\n            } else {\r\n                return \"_anonymous\";\r\n            }\r\n        };\r\n        Symbol.prototype.print = function (outfile) {\r\n            outfile.Write(this.toString());\r\n        };\r\n        Symbol.prototype.specializeType = function (pattern, replacement, checker) {\r\n            throw new Error(\"please implement in derived class\");\r\n        };\r\n        Symbol.prototype.setType = function (type) {\r\n            throw new Error(\"please implement in derived class\");\r\n        };\r\n        Symbol.prototype.kind = function () {\r\n            throw new Error(\"please implement in derived class\");\r\n        };\r\n        return Symbol;\r\n    })();\r\n    TypeScript.Symbol = Symbol;    \r\n    var ValueLocation = (function () {\r\n        function ValueLocation() { }\r\n        return ValueLocation;\r\n    })();\r\n    TypeScript.ValueLocation = ValueLocation;    \r\n    var InferenceSymbol = (function (_super) {\r\n        __extends(InferenceSymbol, _super);\r\n        function InferenceSymbol(name, location, unitIndex) {\r\n                _super.call(this, name, location, unitIndex);\r\n            this.typeCheckStatus = TypeCheckStatus.NotStarted;\r\n        }\r\n        InferenceSymbol.prototype.isInferenceSymbol = function () {\r\n            return true;\r\n        };\r\n        InferenceSymbol.prototype.transferVarFlags = function (varFlags) {\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Ambient)) {\r\n                this.flags |= TypeScript.SymbolFlags.Ambient;\r\n            }\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Constant)) {\r\n                this.flags |= TypeScript.SymbolFlags.Constant;\r\n            }\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Static)) {\r\n                this.flags |= TypeScript.SymbolFlags.Static;\r\n            }\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Property)) {\r\n                this.flags |= TypeScript.SymbolFlags.Property;\r\n            }\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Private)) {\r\n                this.flags |= TypeScript.SymbolFlags.Private;\r\n            }\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Public)) {\r\n                this.flags |= TypeScript.SymbolFlags.Public;\r\n            }\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Readonly)) {\r\n                this.flags |= TypeScript.SymbolFlags.Readonly;\r\n            }\r\n            if(TypeScript.hasFlag(varFlags, TypeScript.VarFlags.Exported)) {\r\n                this.flags |= TypeScript.SymbolFlags.Exported;\r\n            }\r\n        };\r\n        return InferenceSymbol;\r\n    })(Symbol);\r\n    TypeScript.InferenceSymbol = InferenceSymbol;    \r\n    var TypeSymbol = (function (_super) {\r\n        __extends(TypeSymbol, _super);\r\n        function TypeSymbol(locName, location, unitIndex, type) {\r\n                _super.call(this, locName, location, unitIndex);\r\n            this.type = type;\r\n            this.expansions = [];\r\n            this.isMethod = false;\r\n            this.aliasLink = null;\r\n            this.onlyReferencedAsTypeRef = TypeScript.optimizeModuleCodeGen;\r\n            this.prettyName = this.name;\r\n        }\r\n        TypeSymbol.prototype.addLocation = function (loc) {\r\n            if(this.additionalLocations == null) {\r\n                this.additionalLocations = [];\r\n            }\r\n            this.additionalLocations[this.additionalLocations.length] = loc;\r\n        };\r\n        TypeSymbol.prototype.kind = function () {\r\n            return TypeScript.SymbolKind.Type;\r\n        };\r\n        TypeSymbol.prototype.isType = function () {\r\n            return true;\r\n        };\r\n        TypeSymbol.prototype.getType = function () {\r\n            return this.type;\r\n        };\r\n        TypeSymbol.prototype.getTypeName = function (scope) {\r\n            return this.type.getMemberTypeName(this.name ? this.name + this.getOptionalNameString() : \"\", false, false, scope);\r\n        };\r\n        TypeSymbol.prototype.instanceScope = function () {\r\n            if(!(this.type.typeFlags & TypeScript.TypeFlags.IsClass) && this.type.isClass()) {\r\n                return this.type.instanceType.constructorScope;\r\n            } else {\r\n                return this.type.containedScope;\r\n            }\r\n        };\r\n        TypeSymbol.prototype.toString = function () {\r\n            var result = this.type.getTypeName();\r\n            if(this.name) {\r\n                result = this.name + \":\" + result;\r\n            }\r\n            return result;\r\n        };\r\n        TypeSymbol.prototype.isClass = function () {\r\n            return this.instanceType != null;\r\n        };\r\n        TypeSymbol.prototype.isFunction = function () {\r\n            return this.declAST != null && this.declAST.nodeType == TypeScript.NodeType.FuncDecl;\r\n        };\r\n        TypeSymbol.prototype.specializeType = function (pattern, replacement, checker) {\r\n            if(this.type == pattern) {\r\n                return replacement.symbol;\r\n            } else {\r\n                var replType = this.type.specializeType(pattern, replacement, checker, false);\r\n                if(replType != this.type) {\r\n                    var result = new TypeSymbol(this.name, 0, -1, replType);\r\n                    return result;\r\n                } else {\r\n                    return this;\r\n                }\r\n            }\r\n        };\r\n        TypeSymbol.prototype.scopeRelativeName = function (scope) {\r\n            if(scope == null) {\r\n                return this.prettyName + this.getOptionalNameString();\r\n            }\r\n            var lca = this.findCommonAncestorPath(scope.container);\r\n            var builder = \"\";\r\n            for(var i = 0, len = lca.length; i < len; i++) {\r\n                var prettyName = (lca[i].kind() == TypeScript.SymbolKind.Type ? (lca[i]).prettyName : lca[i].name);\r\n                builder = prettyName + \".\" + builder;\r\n            }\r\n            builder += this.prettyName + this.getOptionalNameString();\r\n            return builder;\r\n        };\r\n        return TypeSymbol;\r\n    })(InferenceSymbol);\r\n    TypeScript.TypeSymbol = TypeSymbol;    \r\n    var WithSymbol = (function (_super) {\r\n        __extends(WithSymbol, _super);\r\n        function WithSymbol(location, unitIndex, withType) {\r\n                _super.call(this, \"with\", location, unitIndex, withType);\r\n        }\r\n        WithSymbol.prototype.isWith = function () {\r\n            return true;\r\n        };\r\n        return WithSymbol;\r\n    })(TypeSymbol);\r\n    TypeScript.WithSymbol = WithSymbol;    \r\n    var FieldSymbol = (function (_super) {\r\n        __extends(FieldSymbol, _super);\r\n        function FieldSymbol(name, location, unitIndex, canWrite, field) {\r\n                _super.call(this, name, location, unitIndex);\r\n            this.canWrite = canWrite;\r\n            this.field = field;\r\n            this.getter = null;\r\n            this.setter = null;\r\n            this.hasBeenEmitted = false;\r\n            this.name = name;\r\n            this.location = location;\r\n        }\r\n        FieldSymbol.prototype.kind = function () {\r\n            return TypeScript.SymbolKind.Field;\r\n        };\r\n        FieldSymbol.prototype.writeable = function () {\r\n            return this.isAccessor() ? this.setter != null : this.canWrite;\r\n        };\r\n        FieldSymbol.prototype.getType = function () {\r\n            return this.field.typeLink.type;\r\n        };\r\n        FieldSymbol.prototype.getTypeName = function (scope) {\r\n            return this.name + this.getOptionalNameString() + \": \" + this.field.typeLink.type.getMemberTypeName(\"\", true, false, scope);\r\n        };\r\n        FieldSymbol.prototype.isMember = function () {\r\n            return true;\r\n        };\r\n        FieldSymbol.prototype.setType = function (type) {\r\n            this.field.typeLink.type = type;\r\n        };\r\n        FieldSymbol.prototype.isAccessor = function () {\r\n            return this.getter != null || this.setter != null;\r\n        };\r\n        FieldSymbol.prototype.isVariable = function () {\r\n            return true;\r\n        };\r\n        FieldSymbol.prototype.toString = function () {\r\n            return this.name + this.getOptionalNameString() + \":\" + this.field.typeLink.type.getTypeName();\r\n        };\r\n        FieldSymbol.prototype.specializeType = function (pattern, replacement, checker) {\r\n            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);\r\n            if(rType != this.field.typeLink.type) {\r\n                var fieldDef = new ValueLocation();\r\n                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex, this.canWrite, fieldDef);\r\n                result.flags = this.flags;\r\n                fieldDef.symbol = result;\r\n                fieldDef.typeLink = new TypeScript.TypeLink();\r\n                result.setType(rType);\r\n                result.typeCheckStatus = TypeCheckStatus.Finished;\r\n                return result;\r\n            } else {\r\n                return this;\r\n            }\r\n        };\r\n        return FieldSymbol;\r\n    })(InferenceSymbol);\r\n    TypeScript.FieldSymbol = FieldSymbol;    \r\n    var ParameterSymbol = (function (_super) {\r\n        __extends(ParameterSymbol, _super);\r\n        function ParameterSymbol(name, location, unitIndex, parameter) {\r\n                _super.call(this, name, location, unitIndex);\r\n            this.parameter = parameter;\r\n            this.argsOffset = (-1);\r\n            this.name = name;\r\n            this.location = location;\r\n        }\r\n        ParameterSymbol.prototype.kind = function () {\r\n            return TypeScript.SymbolKind.Parameter;\r\n        };\r\n        ParameterSymbol.prototype.writeable = function () {\r\n            return true;\r\n        };\r\n        ParameterSymbol.prototype.getType = function () {\r\n            return this.parameter.typeLink.type;\r\n        };\r\n        ParameterSymbol.prototype.setType = function (type) {\r\n            this.parameter.typeLink.type = type;\r\n        };\r\n        ParameterSymbol.prototype.isVariable = function () {\r\n            return true;\r\n        };\r\n        ParameterSymbol.prototype.isOptional = function () {\r\n            if(this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {\r\n                return (this.parameter.symbol.declAST).isOptional;\r\n            } else {\r\n                return false;\r\n            }\r\n        };\r\n        ParameterSymbol.prototype.getTypeName = function (scope) {\r\n            return this.name + (this.isOptional() ? \"?\" : \"\") + \":\" + this.getType().getMemberTypeName(\"\", false, false, scope);\r\n        };\r\n        ParameterSymbol.prototype.toString = function () {\r\n            return this.name + (this.isOptional() ? \"?\" : \"\") + \":\" + this.getType().getTypeName();\r\n        };\r\n        ParameterSymbol.prototype.specializeType = function (pattern, replacement, checker) {\r\n            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);\r\n            if(this.parameter.typeLink.type != rType) {\r\n                var paramDef = new ValueLocation();\r\n                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex, paramDef);\r\n                paramDef.symbol = result;\r\n                result.setType(rType);\r\n                return result;\r\n            } else {\r\n                return this;\r\n            }\r\n        };\r\n        return ParameterSymbol;\r\n    })(InferenceSymbol);\r\n    TypeScript.ParameterSymbol = ParameterSymbol;    \r\n    var VariableSymbol = (function (_super) {\r\n        __extends(VariableSymbol, _super);\r\n        function VariableSymbol(name, location, unitIndex, variable) {\r\n                _super.call(this, name, location, unitIndex);\r\n            this.variable = variable;\r\n        }\r\n        VariableSymbol.prototype.kind = function () {\r\n            return TypeScript.SymbolKind.Variable;\r\n        };\r\n        VariableSymbol.prototype.writeable = function () {\r\n            return true;\r\n        };\r\n        VariableSymbol.prototype.getType = function () {\r\n            return this.variable.typeLink.type;\r\n        };\r\n        VariableSymbol.prototype.getTypeName = function (scope) {\r\n            return this.name + \":\" + this.getType().getMemberTypeName(\"\", false, false, scope);\r\n        };\r\n        VariableSymbol.prototype.setType = function (type) {\r\n            this.variable.typeLink.type = type;\r\n        };\r\n        VariableSymbol.prototype.isVariable = function () {\r\n            return true;\r\n        };\r\n        return VariableSymbol;\r\n    })(InferenceSymbol);\r\n    TypeScript.VariableSymbol = VariableSymbol;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var ScopedMembers = (function () {\r\n        function ScopedMembers(dualMembers) {\r\n            this.dualMembers = dualMembers;\r\n            this.allMembers = this.dualMembers;\r\n            this.publicMembers = this.dualMembers.primaryTable;\r\n            this.privateMembers = this.dualMembers.secondaryTable;\r\n        }\r\n        ScopedMembers.prototype.addPublicMember = function (key, data) {\r\n            return this.dualMembers.primaryTable.add(key, data);\r\n        };\r\n        ScopedMembers.prototype.addPrivateMember = function (key, data) {\r\n            return this.dualMembers.secondaryTable.add(key, data);\r\n        };\r\n        return ScopedMembers;\r\n    })();\r\n    TypeScript.ScopedMembers = ScopedMembers;    \r\n    (function (SymbolKind) {\r\n        SymbolKind._map = [];\r\n        SymbolKind._map[0] = \"None\";\r\n        SymbolKind.None = 0;\r\n        SymbolKind._map[1] = \"Type\";\r\n        SymbolKind.Type = 1;\r\n        SymbolKind._map[2] = \"Field\";\r\n        SymbolKind.Field = 2;\r\n        SymbolKind._map[3] = \"Parameter\";\r\n        SymbolKind.Parameter = 3;\r\n        SymbolKind._map[4] = \"Variable\";\r\n        SymbolKind.Variable = 4;\r\n    })(TypeScript.SymbolKind || (TypeScript.SymbolKind = {}));\r\n    var SymbolKind = TypeScript.SymbolKind;\r\n\r\n    var SymbolScope = (function () {\r\n        function SymbolScope(container) {\r\n            this.container = container;\r\n        }\r\n        SymbolScope.prototype.printLabel = function () {\r\n            return \"base\";\r\n        };\r\n        SymbolScope.prototype.getAllSymbolNames = function (members) {\r\n            return [\r\n                \"please\", \r\n                \"implement\", \r\n                \"in\", \r\n                \"derived\", \r\n                \"classes\"\r\n            ];\r\n        };\r\n        SymbolScope.prototype.getAllTypeSymbolNames = function (members) {\r\n            return [\r\n                \"please\", \r\n                \"implement\", \r\n                \"in\", \r\n                \"derived\", \r\n                \"classes\"\r\n            ];\r\n        };\r\n        SymbolScope.prototype.getAllValueSymbolNames = function (members) {\r\n            return [\r\n                \"please\", \r\n                \"implement\", \r\n                \"in\", \r\n                \"derived\", \r\n                \"classes\"\r\n            ];\r\n        };\r\n        SymbolScope.prototype.search = function (filter, name, publicOnly, typespace) {\r\n            return null;\r\n        };\r\n        SymbolScope.prototype.findLocal = function (name, publicOnly, typespace) {\r\n            return null;\r\n        };\r\n        SymbolScope.prototype.find = function (name, publicOnly, typespace) {\r\n            return null;\r\n        };\r\n        SymbolScope.prototype.findImplementation = function (name, publicOnly, typespace) {\r\n            return null;\r\n        };\r\n        SymbolScope.prototype.findAmbient = function (name, publicOnly, typespace) {\r\n            return null;\r\n        };\r\n        SymbolScope.prototype.print = function (outfile) {\r\n            if(this.container) {\r\n                outfile.WriteLine(this.printLabel() + \" scope with container: \" + this.container.name + \"...\");\r\n            } else {\r\n                outfile.WriteLine(this.printLabel() + \" scope...\");\r\n            }\r\n        };\r\n        SymbolScope.prototype.enter = function (container, ast, symbol, errorReporter, publicOnly, typespace, ambient) {\r\n            throw new Error(\"please implement in derived class\");\r\n        };\r\n        SymbolScope.prototype.getTable = function () {\r\n            throw new Error(\"please implement in derived class\");\r\n        };\r\n        return SymbolScope;\r\n    })();\r\n    TypeScript.SymbolScope = SymbolScope;    \r\n    function symbolCanBeUsed(sym, publicOnly) {\r\n        return publicOnly ? !(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Private) || (sym.declAST && sym.declAST.nodeType == TypeScript.NodeType.FuncDecl && TypeScript.hasFlag((sym.declAST).fncFlags, TypeScript.FncFlags.Private))) : true;\r\n    }\r\n    var SymbolAggregateScope = (function (_super) {\r\n        __extends(SymbolAggregateScope, _super);\r\n        function SymbolAggregateScope(container) {\r\n                _super.call(this, container);\r\n            this.valueCache = null;\r\n            this.valueImplCache = null;\r\n            this.valueAmbientCache = null;\r\n            this.typeCache = null;\r\n            this.typeImplCache = null;\r\n            this.typeAmbientCache = null;\r\n            this.parents = null;\r\n            this.container = container;\r\n        }\r\n        SymbolAggregateScope.prototype.printLabel = function () {\r\n            return \"agg\";\r\n        };\r\n        SymbolAggregateScope.prototype.search = function (filter, name, publicOnly, typespace) {\r\n            if(this.parents) {\r\n                for(var i = 0; i < this.parents.length; i++) {\r\n                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);\r\n                    if(sym) {\r\n                        if(filter.update(sym)) {\r\n                            return sym;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return filter.result;\r\n        };\r\n        SymbolAggregateScope.prototype.getAllSymbolNames = function (members) {\r\n            var result = [];\r\n            if(this.parents) {\r\n                for(var i = 0; i < this.parents.length; i++) {\r\n                    var parentResult = this.parents[i].getAllSymbolNames(members);\r\n                    if(parentResult) {\r\n                        result = result.concat(parentResult);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        SymbolAggregateScope.prototype.getAllTypeSymbolNames = function (members) {\r\n            var result = [];\r\n            if(this.parents) {\r\n                for(var i = 0; i < this.parents.length; i++) {\r\n                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);\r\n                    if(parentResult) {\r\n                        result = result.concat(parentResult);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        SymbolAggregateScope.prototype.getAllValueSymbolNames = function (members) {\r\n            var result = [];\r\n            if(this.parents) {\r\n                for(var i = 0; i < this.parents.length; i++) {\r\n                    var parentResult = this.parents[i].getAllValueSymbolNames(members);\r\n                    if(parentResult) {\r\n                        result = result.concat(parentResult);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        SymbolAggregateScope.prototype.print = function (outfile) {\r\n            _super.prototype.print.call(this, outfile);\r\n            if(this.parents) {\r\n                for(var i = 0; i < this.parents.length; i++) {\r\n                    this.parents[i].print(outfile);\r\n                }\r\n            }\r\n        };\r\n        SymbolAggregateScope.prototype.findImplementation = function (name, publicOnly, typespace) {\r\n            var sym = null;\r\n            var i = 0;\r\n            var implCache = this.valueImplCache;\r\n            if(typespace) {\r\n                implCache = this.typeImplCache;\r\n            }\r\n            if(implCache && ((sym = implCache.lookup(name)) != null) && (publicOnly ? !(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Private) || (sym.declAST && sym.declAST.nodeType == TypeScript.NodeType.FuncDecl && TypeScript.hasFlag((sym.declAST).fncFlags, TypeScript.FncFlags.Private))) : true)) {\r\n                return sym;\r\n            }\r\n            if(this.parents) {\r\n                for(i = 0; i < this.parents.length; i++) {\r\n                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);\r\n                    if(sym) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(implCache) {\r\n                if(typespace) {\r\n                    this.typeImplCache = new TypeScript.StringHashTable();\r\n                    implCache = this.typeImplCache;\r\n                } else {\r\n                    this.valueImplCache = new TypeScript.StringHashTable();\r\n                    implCache = this.valueImplCache;\r\n                }\r\n            }\r\n            implCache.add(name, sym);\r\n            return sym;\r\n        };\r\n        SymbolAggregateScope.prototype.find = function (name, publicOnly, typespace) {\r\n            var sym = null;\r\n            var i = 0;\r\n            var cache = this.valueCache;\r\n            if(typespace) {\r\n                cache = this.typeCache;\r\n            }\r\n            if(cache && ((sym = cache.lookup(name)) != null) && (publicOnly ? !(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Private) || (sym.declAST && sym.declAST.nodeType == TypeScript.NodeType.FuncDecl && TypeScript.hasFlag((sym.declAST).fncFlags, TypeScript.FncFlags.Private))) : true)) {\r\n                return sym;\r\n            }\r\n            if(this.parents) {\r\n                for(i = 0; i < this.parents.length; i++) {\r\n                    sym = this.parents[i].find(name, publicOnly, typespace);\r\n                    if(sym) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(cache == null) {\r\n                if(typespace) {\r\n                    this.typeCache = new TypeScript.StringHashTable();\r\n                    cache = this.typeCache;\r\n                } else {\r\n                    this.valueCache = new TypeScript.StringHashTable();\r\n                    cache = this.valueCache;\r\n                }\r\n            }\r\n            cache.add(name, sym);\r\n            return sym;\r\n        };\r\n        SymbolAggregateScope.prototype.findAmbient = function (name, publicOnly, typespace) {\r\n            var sym = null;\r\n            var i = 0;\r\n            var cache = this.valueAmbientCache;\r\n            if(typespace) {\r\n                cache = this.typeAmbientCache;\r\n            }\r\n            if(cache && ((sym = cache.lookup(name)) != null)) {\r\n                return sym;\r\n            }\r\n            if(this.parents) {\r\n                for(i = 0; i < this.parents.length; i++) {\r\n                    sym = this.parents[i].findAmbient(name, publicOnly, typespace);\r\n                    if(sym) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(cache == null) {\r\n                if(typespace) {\r\n                    this.typeAmbientCache = new TypeScript.StringHashTable();\r\n                    cache = this.typeAmbientCache;\r\n                } else {\r\n                    this.valueAmbientCache = new TypeScript.StringHashTable();\r\n                    cache = this.valueAmbientCache;\r\n                }\r\n            }\r\n            cache.add(name, sym);\r\n            return sym;\r\n        };\r\n        SymbolAggregateScope.prototype.addParentScope = function (parent) {\r\n            if(this.parents == null) {\r\n                this.parents = new Array();\r\n            }\r\n            this.parents[this.parents.length] = parent;\r\n        };\r\n        return SymbolAggregateScope;\r\n    })(SymbolScope);\r\n    TypeScript.SymbolAggregateScope = SymbolAggregateScope;    \r\n    var SymbolTableScope = (function (_super) {\r\n        __extends(SymbolTableScope, _super);\r\n        function SymbolTableScope(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, container) {\r\n                _super.call(this, container);\r\n            this.valueMembers = valueMembers;\r\n            this.ambientValueMembers = ambientValueMembers;\r\n            this.enclosedTypes = enclosedTypes;\r\n            this.ambientEnclosedTypes = ambientEnclosedTypes;\r\n            this.container = container;\r\n        }\r\n        SymbolTableScope.prototype.printLabel = function () {\r\n            return \"table\";\r\n        };\r\n        SymbolTableScope.prototype.getAllSymbolNames = function (members) {\r\n            var result = this.getAllTypeSymbolNames(members);\r\n            return result.concat(this.getAllValueSymbolNames(members));\r\n        };\r\n        SymbolTableScope.prototype.getAllTypeSymbolNames = function (members) {\r\n            var result = [];\r\n            if(this.ambientEnclosedTypes) {\r\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\r\n            }\r\n            if(this.enclosedTypes) {\r\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\r\n            }\r\n            return result;\r\n        };\r\n        SymbolTableScope.prototype.getAllValueSymbolNames = function (members) {\r\n            var result = [];\r\n            if(this.ambientValueMembers) {\r\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\r\n            }\r\n            if(this.valueMembers) {\r\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\r\n            }\r\n            return result;\r\n        };\r\n        SymbolTableScope.prototype.search = function (filter, name, publicOnly, typespace) {\r\n            var sym = this.find(name, publicOnly, typespace);\r\n            filter.update(sym);\r\n            return filter.result;\r\n        };\r\n        SymbolTableScope.prototype.find = function (name, publicOnly, typespace) {\r\n            var table = null;\r\n            var ambientTable = null;\r\n            if(typespace) {\r\n                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\r\n                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\r\n            } else {\r\n                table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\r\n                ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\r\n            }\r\n            if(ambientTable) {\r\n                var s = ambientTable.lookup(name);\r\n                if(s) {\r\n                    return s;\r\n                }\r\n            }\r\n            if(table) {\r\n                var s = table.lookup(name);\r\n                if(s) {\r\n                    return s;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        SymbolTableScope.prototype.findAmbient = function (name, publicOnly, typespace) {\r\n            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\r\n            if(typespace) {\r\n                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\r\n            }\r\n            if(ambientTable) {\r\n                var s = ambientTable.lookup(name);\r\n                if(s) {\r\n                    return s;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        SymbolTableScope.prototype.print = function (outfile) {\r\n            _super.prototype.print.call(this, outfile);\r\n            if(this.ambientValueMembers) {\r\n                this.ambientValueMembers.allMembers.map(function (key, sym, context) {\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n            if(this.valueMembers) {\r\n                this.valueMembers.allMembers.map(function (key, sym, context) {\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n            if(this.ambientEnclosedTypes) {\r\n                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n            if(this.enclosedTypes) {\r\n                this.enclosedTypes.allMembers.map(function (key, sym, context) {\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n        };\r\n        SymbolTableScope.prototype.findImplementation = function (name, publicOnly, typespace) {\r\n            var sym = this.find(name, publicOnly, typespace);\r\n            if(sym) {\r\n                if(sym.kind() == SymbolKind.Type) {\r\n                    var typeSym = sym;\r\n                    if(!typeSym.type.hasImplementation()) {\r\n                        sym = null;\r\n                    }\r\n                } else {\r\n                    if(sym.container) {\r\n                        if(sym.container.kind() == SymbolKind.Type) {\r\n                            var ctypeSym = sym.container;\r\n                            if(!ctypeSym.type.hasImplementation()) {\r\n                                sym = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return sym;\r\n        };\r\n        SymbolTableScope.prototype.getTable = function () {\r\n            return this.valueMembers.publicMembers;\r\n        };\r\n        return SymbolTableScope;\r\n    })(SymbolScope);\r\n    TypeScript.SymbolTableScope = SymbolTableScope;    \r\n    var SymbolScopeBuilder = (function (_super) {\r\n        __extends(SymbolScopeBuilder, _super);\r\n        function SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, parent, container) {\r\n                _super.call(this, container);\r\n            this.valueMembers = valueMembers;\r\n            this.ambientValueMembers = ambientValueMembers;\r\n            this.enclosedTypes = enclosedTypes;\r\n            this.ambientEnclosedTypes = ambientEnclosedTypes;\r\n            this.parent = parent;\r\n            this.container = container;\r\n        }\r\n        SymbolScopeBuilder.prototype.printLabel = function () {\r\n            return \"builder\";\r\n        };\r\n        SymbolScopeBuilder.prototype.getAllSymbolNames = function (members) {\r\n            var result = this.getAllTypeSymbolNames(members);\r\n            return result.concat(this.getAllValueSymbolNames(members));\r\n        };\r\n        SymbolScopeBuilder.prototype.getAllTypeSymbolNames = function (members) {\r\n            var result = [];\r\n            if(this.ambientEnclosedTypes) {\r\n                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());\r\n            }\r\n            if(this.enclosedTypes) {\r\n                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());\r\n            }\r\n            if(!members && this.parent) {\r\n                var parentResult = this.parent.getAllTypeSymbolNames(members);\r\n                if(parentResult) {\r\n                    result = result.concat(parentResult);\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        SymbolScopeBuilder.prototype.getAllValueSymbolNames = function (members) {\r\n            var result = [];\r\n            if(this.ambientValueMembers) {\r\n                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());\r\n            }\r\n            if(this.valueMembers) {\r\n                result = result.concat(this.valueMembers.allMembers.getAllKeys());\r\n            }\r\n            if(!members && this.parent) {\r\n                var parentResult = this.parent.getAllValueSymbolNames(members);\r\n                if(parentResult) {\r\n                    result = result.concat(parentResult);\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        SymbolScopeBuilder.prototype.search = function (filter, name, publicOnly, typespace) {\r\n            var sym = null;\r\n            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\r\n            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\r\n            if(typespace) {\r\n                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\r\n                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\r\n            }\r\n            if(ambientTable) {\r\n                if((sym = ambientTable.lookup(name)) != null) {\r\n                    if(filter.update(sym)) {\r\n                        return sym;\r\n                    }\r\n                }\r\n            }\r\n            if(table) {\r\n                if((sym = table.lookup(name)) != null) {\r\n                    if(filter.update(sym)) {\r\n                        return sym;\r\n                    }\r\n                }\r\n            }\r\n            if(this.parent) {\r\n                sym = this.parent.search(filter, name, publicOnly, typespace);\r\n                if(sym) {\r\n                    if(filter.update(sym)) {\r\n                        return sym;\r\n                    }\r\n                }\r\n            }\r\n            return filter.result;\r\n        };\r\n        SymbolScopeBuilder.prototype.print = function (outfile) {\r\n            _super.prototype.print.call(this, outfile);\r\n            if(this.ambientValueMembers) {\r\n                this.ambientValueMembers.allMembers.map(function (key, s, context) {\r\n                    var sym = s;\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n            if(this.valueMembers) {\r\n                this.valueMembers.allMembers.map(function (key, s, context) {\r\n                    var sym = s;\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n            if(this.ambientEnclosedTypes) {\r\n                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {\r\n                    var sym = s;\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n            if(this.enclosedTypes) {\r\n                this.enclosedTypes.allMembers.map(function (key, s, context) {\r\n                    var sym = s;\r\n                    outfile.WriteLine(\"  \" + key);\r\n                }, null);\r\n            }\r\n            if(this.parent) {\r\n                this.parent.print(outfile);\r\n            }\r\n        };\r\n        SymbolScopeBuilder.prototype.find = function (name, publicOnly, typespace) {\r\n            var sym = null;\r\n            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\r\n            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\r\n            if(typespace) {\r\n                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\r\n                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\r\n            }\r\n            if(ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\r\n                return sym;\r\n            }\r\n            if(table && ((sym = table.lookup(name)) != null)) {\r\n                return sym;\r\n            }\r\n            if(this.parent) {\r\n                return this.parent.find(name, publicOnly, typespace);\r\n            }\r\n            return null;\r\n        };\r\n        SymbolScopeBuilder.prototype.findAmbient = function (name, publicOnly, typespace) {\r\n            var sym = null;\r\n            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\r\n            if(typespace) {\r\n                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\r\n            }\r\n            if(ambientTable && ((sym = ambientTable.lookup(name)) != null)) {\r\n                return sym;\r\n            }\r\n            if(this.parent) {\r\n                return this.parent.findAmbient(name, publicOnly, typespace);\r\n            }\r\n            return null;\r\n        };\r\n        SymbolScopeBuilder.prototype.findLocal = function (name, publicOnly, typespace) {\r\n            var sym = null;\r\n            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;\r\n            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;\r\n            if(typespace) {\r\n                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;\r\n                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;\r\n            }\r\n            if(table) {\r\n                if((sym = table.lookup(name)) != null) {\r\n                    if(sym) {\r\n                        return sym;\r\n                    }\r\n                }\r\n            }\r\n            if(ambientTable) {\r\n                if((sym = ambientTable.lookup(name)) != null) {\r\n                    if(sym) {\r\n                        return sym;\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        SymbolScopeBuilder.prototype.enter = function (container, ast, symbol, errorReporter, insertAsPublic, typespace, ambient) {\r\n            var table = null;\r\n            if(ambient) {\r\n                if(typespace) {\r\n                    table = (this.ambientEnclosedTypes == null) ? null : insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;\r\n                } else {\r\n                    table = (this.ambientValueMembers == null) ? null : insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;\r\n                }\r\n            } else {\r\n                if(typespace) {\r\n                    table = (this.enclosedTypes == null) ? null : insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;\r\n                } else {\r\n                    table = (this.valueMembers == null) ? null : insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;\r\n                }\r\n            }\r\n            if(table) {\r\n                if(!table.add(symbol.name, symbol)) {\r\n                    errorReporter.duplicateIdentifier(ast, symbol.name);\r\n                }\r\n            } else {\r\n                TypeScript.CompilerDiagnostics.Alert(\"YYYYY\");\r\n            }\r\n            symbol.container = container;\r\n        };\r\n        SymbolScopeBuilder.prototype.getTable = function () {\r\n            return this.valueMembers.allMembers;\r\n        };\r\n        return SymbolScopeBuilder;\r\n    })(SymbolScope);\r\n    TypeScript.SymbolScopeBuilder = SymbolScopeBuilder;    \r\n    var FilteredSymbolScope = (function (_super) {\r\n        __extends(FilteredSymbolScope, _super);\r\n        function FilteredSymbolScope(scope, container, filter) {\r\n                _super.call(this, container);\r\n            this.scope = scope;\r\n            this.filter = filter;\r\n        }\r\n        FilteredSymbolScope.prototype.print = function (outfile) {\r\n            this.scope.print(outfile);\r\n        };\r\n        FilteredSymbolScope.prototype.find = function (name, publicOnly, typespace) {\r\n            this.filter.reset();\r\n            return this.scope.search(this.filter, name, publicOnly, typespace);\r\n        };\r\n        FilteredSymbolScope.prototype.findLocal = function (name, publicOnly, typespace) {\r\n            return this.scope.findLocal(name, publicOnly, typespace);\r\n        };\r\n        return FilteredSymbolScope;\r\n    })(SymbolScope);\r\n    TypeScript.FilteredSymbolScope = FilteredSymbolScope;    \r\n    var FilteredSymbolScopeBuilder = (function (_super) {\r\n        __extends(FilteredSymbolScopeBuilder, _super);\r\n        function FilteredSymbolScopeBuilder(valueMembers, parent, container, filter) {\r\n                _super.call(this, valueMembers, null, null, null, parent, container);\r\n            this.filter = filter;\r\n        }\r\n        FilteredSymbolScopeBuilder.prototype.findLocal = function (name, publicOnly, typespace) {\r\n            var sym = _super.prototype.findLocal.call(this, name, publicOnly, typespace);\r\n            if(sym) {\r\n                if(!this.filter(sym)) {\r\n                    return null;\r\n                }\r\n            }\r\n            return sym;\r\n        };\r\n        FilteredSymbolScopeBuilder.prototype.search = function (filter, name, publicOnly, typespace) {\r\n            throw new Error(\"please implement\");\r\n        };\r\n        FilteredSymbolScopeBuilder.prototype.find = function (name, publicOnly, typespace) {\r\n            var sym = _super.prototype.findLocal.call(this, name, publicOnly, typespace);\r\n            if(sym) {\r\n                if(!this.filter(sym)) {\r\n                    return null;\r\n                }\r\n            }\r\n            return _super.prototype.find.call(this, name, publicOnly, typespace);\r\n        };\r\n        return FilteredSymbolScopeBuilder;\r\n    })(SymbolScopeBuilder);\r\n    TypeScript.FilteredSymbolScopeBuilder = FilteredSymbolScopeBuilder;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (TokenID) {\r\n        TokenID._map = [];\r\n        TokenID._map[0] = \"ANY\";\r\n        TokenID.ANY = 0;\r\n        TokenID._map[1] = \"BOOL\";\r\n        TokenID.BOOL = 1;\r\n        TokenID._map[2] = \"BREAK\";\r\n        TokenID.BREAK = 2;\r\n        TokenID._map[3] = \"CASE\";\r\n        TokenID.CASE = 3;\r\n        TokenID._map[4] = \"CATCH\";\r\n        TokenID.CATCH = 4;\r\n        TokenID._map[5] = \"CLASS\";\r\n        TokenID.CLASS = 5;\r\n        TokenID._map[6] = \"CONST\";\r\n        TokenID.CONST = 6;\r\n        TokenID._map[7] = \"CONTINUE\";\r\n        TokenID.CONTINUE = 7;\r\n        TokenID._map[8] = \"DEBUGGER\";\r\n        TokenID.DEBUGGER = 8;\r\n        TokenID._map[9] = \"DEFAULT\";\r\n        TokenID.DEFAULT = 9;\r\n        TokenID._map[10] = \"DELETE\";\r\n        TokenID.DELETE = 10;\r\n        TokenID._map[11] = \"DO\";\r\n        TokenID.DO = 11;\r\n        TokenID._map[12] = \"ELSE\";\r\n        TokenID.ELSE = 12;\r\n        TokenID._map[13] = \"ENUM\";\r\n        TokenID.ENUM = 13;\r\n        TokenID._map[14] = \"EXPORT\";\r\n        TokenID.EXPORT = 14;\r\n        TokenID._map[15] = \"EXTENDS\";\r\n        TokenID.EXTENDS = 15;\r\n        TokenID._map[16] = \"DECLARE\";\r\n        TokenID.DECLARE = 16;\r\n        TokenID._map[17] = \"FALSE\";\r\n        TokenID.FALSE = 17;\r\n        TokenID._map[18] = \"FINALLY\";\r\n        TokenID.FINALLY = 18;\r\n        TokenID._map[19] = \"FOR\";\r\n        TokenID.FOR = 19;\r\n        TokenID._map[20] = \"FUNCTION\";\r\n        TokenID.FUNCTION = 20;\r\n        TokenID._map[21] = \"CONSTRUCTOR\";\r\n        TokenID.CONSTRUCTOR = 21;\r\n        TokenID._map[22] = \"GET\";\r\n        TokenID.GET = 22;\r\n        TokenID._map[23] = \"IF\";\r\n        TokenID.IF = 23;\r\n        TokenID._map[24] = \"IMPLEMENTS\";\r\n        TokenID.IMPLEMENTS = 24;\r\n        TokenID._map[25] = \"IMPORT\";\r\n        TokenID.IMPORT = 25;\r\n        TokenID._map[26] = \"IN\";\r\n        TokenID.IN = 26;\r\n        TokenID._map[27] = \"INSTANCEOF\";\r\n        TokenID.INSTANCEOF = 27;\r\n        TokenID._map[28] = \"INTERFACE\";\r\n        TokenID.INTERFACE = 28;\r\n        TokenID._map[29] = \"LET\";\r\n        TokenID.LET = 29;\r\n        TokenID._map[30] = \"MODULE\";\r\n        TokenID.MODULE = 30;\r\n        TokenID._map[31] = \"NEW\";\r\n        TokenID.NEW = 31;\r\n        TokenID._map[32] = \"NUMBER\";\r\n        TokenID.NUMBER = 32;\r\n        TokenID._map[33] = \"NULL\";\r\n        TokenID.NULL = 33;\r\n        TokenID._map[34] = \"PACKAGE\";\r\n        TokenID.PACKAGE = 34;\r\n        TokenID._map[35] = \"PRIVATE\";\r\n        TokenID.PRIVATE = 35;\r\n        TokenID._map[36] = \"PROTECTED\";\r\n        TokenID.PROTECTED = 36;\r\n        TokenID._map[37] = \"PUBLIC\";\r\n        TokenID.PUBLIC = 37;\r\n        TokenID._map[38] = \"RETURN\";\r\n        TokenID.RETURN = 38;\r\n        TokenID._map[39] = \"SET\";\r\n        TokenID.SET = 39;\r\n        TokenID._map[40] = \"STATIC\";\r\n        TokenID.STATIC = 40;\r\n        TokenID._map[41] = \"STRING\";\r\n        TokenID.STRING = 41;\r\n        TokenID._map[42] = \"SUPER\";\r\n        TokenID.SUPER = 42;\r\n        TokenID._map[43] = \"SWITCH\";\r\n        TokenID.SWITCH = 43;\r\n        TokenID._map[44] = \"THIS\";\r\n        TokenID.THIS = 44;\r\n        TokenID._map[45] = \"THROW\";\r\n        TokenID.THROW = 45;\r\n        TokenID._map[46] = \"TRUE\";\r\n        TokenID.TRUE = 46;\r\n        TokenID._map[47] = \"TRY\";\r\n        TokenID.TRY = 47;\r\n        TokenID._map[48] = \"TYPEOF\";\r\n        TokenID.TYPEOF = 48;\r\n        TokenID._map[49] = \"VAR\";\r\n        TokenID.VAR = 49;\r\n        TokenID._map[50] = \"VOID\";\r\n        TokenID.VOID = 50;\r\n        TokenID._map[51] = \"WITH\";\r\n        TokenID.WITH = 51;\r\n        TokenID._map[52] = \"WHILE\";\r\n        TokenID.WHILE = 52;\r\n        TokenID._map[53] = \"YIELD\";\r\n        TokenID.YIELD = 53;\r\n        TokenID._map[54] = \"SColon\";\r\n        TokenID.SColon = 54;\r\n        TokenID._map[55] = \"LParen\";\r\n        TokenID.LParen = 55;\r\n        TokenID._map[56] = \"RParen\";\r\n        TokenID.RParen = 56;\r\n        TokenID._map[57] = \"LBrack\";\r\n        TokenID.LBrack = 57;\r\n        TokenID._map[58] = \"RBrack\";\r\n        TokenID.RBrack = 58;\r\n        TokenID._map[59] = \"LCurly\";\r\n        TokenID.LCurly = 59;\r\n        TokenID._map[60] = \"RCurly\";\r\n        TokenID.RCurly = 60;\r\n        TokenID._map[61] = \"Comma\";\r\n        TokenID.Comma = 61;\r\n        TokenID._map[62] = \"Asg\";\r\n        TokenID.Asg = 62;\r\n        TokenID._map[63] = \"AsgAdd\";\r\n        TokenID.AsgAdd = 63;\r\n        TokenID._map[64] = \"AsgSub\";\r\n        TokenID.AsgSub = 64;\r\n        TokenID._map[65] = \"AsgMul\";\r\n        TokenID.AsgMul = 65;\r\n        TokenID._map[66] = \"AsgDiv\";\r\n        TokenID.AsgDiv = 66;\r\n        TokenID._map[67] = \"AsgMod\";\r\n        TokenID.AsgMod = 67;\r\n        TokenID._map[68] = \"AsgAnd\";\r\n        TokenID.AsgAnd = 68;\r\n        TokenID._map[69] = \"AsgXor\";\r\n        TokenID.AsgXor = 69;\r\n        TokenID._map[70] = \"AsgOr\";\r\n        TokenID.AsgOr = 70;\r\n        TokenID._map[71] = \"AsgLsh\";\r\n        TokenID.AsgLsh = 71;\r\n        TokenID._map[72] = \"AsgRsh\";\r\n        TokenID.AsgRsh = 72;\r\n        TokenID._map[73] = \"AsgRs2\";\r\n        TokenID.AsgRs2 = 73;\r\n        TokenID._map[74] = \"QMark\";\r\n        TokenID.QMark = 74;\r\n        TokenID._map[75] = \"Colon\";\r\n        TokenID.Colon = 75;\r\n        TokenID._map[76] = \"LogOr\";\r\n        TokenID.LogOr = 76;\r\n        TokenID._map[77] = \"LogAnd\";\r\n        TokenID.LogAnd = 77;\r\n        TokenID._map[78] = \"Or\";\r\n        TokenID.Or = 78;\r\n        TokenID._map[79] = \"Xor\";\r\n        TokenID.Xor = 79;\r\n        TokenID._map[80] = \"And\";\r\n        TokenID.And = 80;\r\n        TokenID._map[81] = \"EQ\";\r\n        TokenID.EQ = 81;\r\n        TokenID._map[82] = \"NE\";\r\n        TokenID.NE = 82;\r\n        TokenID._map[83] = \"Eqv\";\r\n        TokenID.Eqv = 83;\r\n        TokenID._map[84] = \"NEqv\";\r\n        TokenID.NEqv = 84;\r\n        TokenID._map[85] = \"LT\";\r\n        TokenID.LT = 85;\r\n        TokenID._map[86] = \"LE\";\r\n        TokenID.LE = 86;\r\n        TokenID._map[87] = \"GT\";\r\n        TokenID.GT = 87;\r\n        TokenID._map[88] = \"GE\";\r\n        TokenID.GE = 88;\r\n        TokenID._map[89] = \"Lsh\";\r\n        TokenID.Lsh = 89;\r\n        TokenID._map[90] = \"Rsh\";\r\n        TokenID.Rsh = 90;\r\n        TokenID._map[91] = \"Rs2\";\r\n        TokenID.Rs2 = 91;\r\n        TokenID._map[92] = \"Add\";\r\n        TokenID.Add = 92;\r\n        TokenID._map[93] = \"Sub\";\r\n        TokenID.Sub = 93;\r\n        TokenID._map[94] = \"Mult\";\r\n        TokenID.Mult = 94;\r\n        TokenID._map[95] = \"Div\";\r\n        TokenID.Div = 95;\r\n        TokenID._map[96] = \"Pct\";\r\n        TokenID.Pct = 96;\r\n        TokenID._map[97] = \"Tilde\";\r\n        TokenID.Tilde = 97;\r\n        TokenID._map[98] = \"Bang\";\r\n        TokenID.Bang = 98;\r\n        TokenID._map[99] = \"Inc\";\r\n        TokenID.Inc = 99;\r\n        TokenID._map[100] = \"Dec\";\r\n        TokenID.Dec = 100;\r\n        TokenID._map[101] = \"Dot\";\r\n        TokenID.Dot = 101;\r\n        TokenID._map[102] = \"Ellipsis\";\r\n        TokenID.Ellipsis = 102;\r\n        TokenID._map[103] = \"Error\";\r\n        TokenID.Error = 103;\r\n        TokenID._map[104] = \"EOF\";\r\n        TokenID.EOF = 104;\r\n        TokenID._map[105] = \"Arrow\";\r\n        TokenID.Arrow = 105;\r\n        TokenID._map[106] = \"ID\";\r\n        TokenID.ID = 106;\r\n        TokenID._map[107] = \"QString\";\r\n        TokenID.QString = 107;\r\n        TokenID._map[108] = \"Regex\";\r\n        TokenID.Regex = 108;\r\n        TokenID._map[109] = \"NumberLit\";\r\n        TokenID.NumberLit = 109;\r\n        TokenID._map[110] = \"Whitespace\";\r\n        TokenID.Whitespace = 110;\r\n        TokenID._map[111] = \"Comment\";\r\n        TokenID.Comment = 111;\r\n        TokenID._map[112] = \"Lim\";\r\n        TokenID.Lim = 112;\r\n        TokenID.LimFixed = TokenID.Arrow;\r\n        TokenID.LimKeyword = TokenID.YIELD;\r\n    })(TypeScript.TokenID || (TypeScript.TokenID = {}));\r\n    var TokenID = TypeScript.TokenID;\r\n\r\n    TypeScript.tokenTable = new Array();\r\n    TypeScript.nodeTypeTable = new Array();\r\n    TypeScript.nodeTypeToTokTable = new Array();\r\n    TypeScript.noRegexTable = new Array();\r\n    TypeScript.noRegexTable[TokenID.ID] = true;\r\n    TypeScript.noRegexTable[TokenID.QString] = true;\r\n    TypeScript.noRegexTable[TokenID.NumberLit] = true;\r\n    TypeScript.noRegexTable[TokenID.Regex] = true;\r\n    TypeScript.noRegexTable[TokenID.THIS] = true;\r\n    TypeScript.noRegexTable[TokenID.Inc] = true;\r\n    TypeScript.noRegexTable[TokenID.Dec] = true;\r\n    TypeScript.noRegexTable[TokenID.RParen] = true;\r\n    TypeScript.noRegexTable[TokenID.RBrack] = true;\r\n    TypeScript.noRegexTable[TokenID.RCurly] = true;\r\n    TypeScript.noRegexTable[TokenID.TRUE] = true;\r\n    TypeScript.noRegexTable[TokenID.FALSE] = true;\r\n    (function (OperatorPrecedence) {\r\n        OperatorPrecedence._map = [];\r\n        OperatorPrecedence._map[0] = \"No\";\r\n        OperatorPrecedence.No = 0;\r\n        OperatorPrecedence._map[1] = \"Cma\";\r\n        OperatorPrecedence.Cma = 1;\r\n        OperatorPrecedence._map[2] = \"Asg\";\r\n        OperatorPrecedence.Asg = 2;\r\n        OperatorPrecedence._map[3] = \"Que\";\r\n        OperatorPrecedence.Que = 3;\r\n        OperatorPrecedence._map[4] = \"Lor\";\r\n        OperatorPrecedence.Lor = 4;\r\n        OperatorPrecedence._map[5] = \"Lan\";\r\n        OperatorPrecedence.Lan = 5;\r\n        OperatorPrecedence._map[6] = \"Bor\";\r\n        OperatorPrecedence.Bor = 6;\r\n        OperatorPrecedence._map[7] = \"Xor\";\r\n        OperatorPrecedence.Xor = 7;\r\n        OperatorPrecedence._map[8] = \"Ban\";\r\n        OperatorPrecedence.Ban = 8;\r\n        OperatorPrecedence._map[9] = \"Equ\";\r\n        OperatorPrecedence.Equ = 9;\r\n        OperatorPrecedence._map[10] = \"Cmp\";\r\n        OperatorPrecedence.Cmp = 10;\r\n        OperatorPrecedence._map[11] = \"Shf\";\r\n        OperatorPrecedence.Shf = 11;\r\n        OperatorPrecedence._map[12] = \"Add\";\r\n        OperatorPrecedence.Add = 12;\r\n        OperatorPrecedence._map[13] = \"Mul\";\r\n        OperatorPrecedence.Mul = 13;\r\n        OperatorPrecedence._map[14] = \"Uni\";\r\n        OperatorPrecedence.Uni = 14;\r\n        OperatorPrecedence._map[15] = \"Lim\";\r\n        OperatorPrecedence.Lim = 15;\r\n    })(TypeScript.OperatorPrecedence || (TypeScript.OperatorPrecedence = {}));\r\n    var OperatorPrecedence = TypeScript.OperatorPrecedence;\r\n\r\n    (function (Reservation) {\r\n        Reservation._map = [];\r\n        Reservation.None = 0;\r\n        Reservation.Javascript = 1;\r\n        Reservation.JavascriptFuture = 2;\r\n        Reservation.TypeScript = 4;\r\n        Reservation.JavascriptFutureStrict = 8;\r\n        Reservation.TypeScriptAndJS = Reservation.Javascript | Reservation.TypeScript;\r\n        Reservation.TypeScriptAndJSFuture = Reservation.JavascriptFuture | Reservation.TypeScript;\r\n        Reservation.TypeScriptAndJSFutureStrict = Reservation.JavascriptFutureStrict | Reservation.TypeScript;\r\n    })(TypeScript.Reservation || (TypeScript.Reservation = {}));\r\n    var Reservation = TypeScript.Reservation;\r\n\r\n    var TokenInfo = (function () {\r\n        function TokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers) {\r\n            this.tokenId = tokenId;\r\n            this.reservation = reservation;\r\n            this.binopPrecedence = binopPrecedence;\r\n            this.binopNodeType = binopNodeType;\r\n            this.unopPrecedence = unopPrecedence;\r\n            this.unopNodeType = unopNodeType;\r\n            this.text = text;\r\n            this.ers = ers;\r\n        }\r\n        return TokenInfo;\r\n    })();\r\n    TypeScript.TokenInfo = TokenInfo;    \r\n    function setTokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers) {\r\n        if(tokenId !== undefined) {\r\n            TypeScript.tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers);\r\n            if(binopNodeType != TypeScript.NodeType.None) {\r\n                TypeScript.nodeTypeTable[binopNodeType] = text;\r\n                TypeScript.nodeTypeToTokTable[binopNodeType] = tokenId;\r\n            }\r\n            if(unopNodeType != TypeScript.NodeType.None) {\r\n                TypeScript.nodeTypeTable[unopNodeType] = text;\r\n            }\r\n        }\r\n    }\r\n    setTokenInfo(TokenID.ANY, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"any\", TypeScript.ErrorRecoverySet.PrimType);\r\n    setTokenInfo(TokenID.BOOL, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"bool\", TypeScript.ErrorRecoverySet.PrimType);\r\n    setTokenInfo(TokenID.BREAK, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"break\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.CASE, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"case\", TypeScript.ErrorRecoverySet.SCase);\r\n    setTokenInfo(TokenID.CATCH, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"catch\", TypeScript.ErrorRecoverySet.Catch);\r\n    setTokenInfo(TokenID.CLASS, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"class\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.CONST, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"const\", TypeScript.ErrorRecoverySet.Var);\r\n    setTokenInfo(TokenID.CONTINUE, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"continue\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.DEBUGGER, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.Debugger, \"debugger\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.DEFAULT, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"default\", TypeScript.ErrorRecoverySet.SCase);\r\n    setTokenInfo(TokenID.DELETE, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.Uni, TypeScript.NodeType.Delete, \"delete\", TypeScript.ErrorRecoverySet.Prefix);\r\n    setTokenInfo(TokenID.DO, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"do\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.ELSE, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"else\", TypeScript.ErrorRecoverySet.Else);\r\n    setTokenInfo(TokenID.ENUM, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"enum\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.EXPORT, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"export\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.EXTENDS, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"extends\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.DECLARE, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"declare\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.FALSE, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"false\", TypeScript.ErrorRecoverySet.RLit);\r\n    setTokenInfo(TokenID.FINALLY, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"finally\", TypeScript.ErrorRecoverySet.Catch);\r\n    setTokenInfo(TokenID.FOR, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"for\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.FUNCTION, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"function\", TypeScript.ErrorRecoverySet.Func);\r\n    setTokenInfo(TokenID.CONSTRUCTOR, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"constructor\", TypeScript.ErrorRecoverySet.Func);\r\n    setTokenInfo(TokenID.GET, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"get\", TypeScript.ErrorRecoverySet.Func);\r\n    setTokenInfo(TokenID.SET, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"set\", TypeScript.ErrorRecoverySet.Func);\r\n    setTokenInfo(TokenID.IF, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"if\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.IMPLEMENTS, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"implements\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.IMPORT, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"import\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.IN, Reservation.TypeScriptAndJS, OperatorPrecedence.Cmp, TypeScript.NodeType.In, OperatorPrecedence.No, TypeScript.NodeType.None, \"in\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.INSTANCEOF, Reservation.TypeScriptAndJS, OperatorPrecedence.Cmp, TypeScript.NodeType.InstOf, OperatorPrecedence.No, TypeScript.NodeType.None, \"instanceof\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.INTERFACE, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"interface\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.LET, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"let\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.MODULE, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"module\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.NEW, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"new\", TypeScript.ErrorRecoverySet.PreOp);\r\n    setTokenInfo(TokenID.NUMBER, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"number\", TypeScript.ErrorRecoverySet.PrimType);\r\n    setTokenInfo(TokenID.NULL, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"null\", TypeScript.ErrorRecoverySet.RLit);\r\n    setTokenInfo(TokenID.PACKAGE, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"package\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.PRIVATE, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"private\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.PROTECTED, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"protected\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.PUBLIC, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"public\", TypeScript.ErrorRecoverySet.TypeScriptS);\r\n    setTokenInfo(TokenID.RETURN, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"return\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.STATIC, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"static\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.STRING, Reservation.TypeScript, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"string\", TypeScript.ErrorRecoverySet.PrimType);\r\n    setTokenInfo(TokenID.SUPER, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"super\", TypeScript.ErrorRecoverySet.RLit);\r\n    setTokenInfo(TokenID.SWITCH, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"switch\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.THIS, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"this\", TypeScript.ErrorRecoverySet.RLit);\r\n    setTokenInfo(TokenID.THROW, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"throw\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.TRUE, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"true\", TypeScript.ErrorRecoverySet.RLit);\r\n    setTokenInfo(TokenID.TRY, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"try\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.TYPEOF, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.Uni, TypeScript.NodeType.Typeof, \"typeof\", TypeScript.ErrorRecoverySet.Prefix);\r\n    setTokenInfo(TokenID.VAR, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"var\", TypeScript.ErrorRecoverySet.Var);\r\n    setTokenInfo(TokenID.VOID, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.Uni, TypeScript.NodeType.Void, \"void\", TypeScript.ErrorRecoverySet.Prefix);\r\n    setTokenInfo(TokenID.WITH, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.With, \"with\", TypeScript.ErrorRecoverySet.Stmt);\r\n    setTokenInfo(TokenID.WHILE, Reservation.TypeScriptAndJS, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"while\", TypeScript.ErrorRecoverySet.While);\r\n    setTokenInfo(TokenID.YIELD, Reservation.JavascriptFutureStrict, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"yield\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.ID, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"identifier\", TypeScript.ErrorRecoverySet.ID);\r\n    setTokenInfo(TokenID.NumberLit, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"numberLiteral\", TypeScript.ErrorRecoverySet.Literal);\r\n    setTokenInfo(TokenID.Regex, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"regex\", TypeScript.ErrorRecoverySet.RegExp);\r\n    setTokenInfo(TokenID.QString, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"qstring\", TypeScript.ErrorRecoverySet.Literal);\r\n    setTokenInfo(TokenID.SColon, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \";\", TypeScript.ErrorRecoverySet.SColon);\r\n    setTokenInfo(TokenID.RParen, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \")\", TypeScript.ErrorRecoverySet.RParen);\r\n    setTokenInfo(TokenID.RBrack, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"]\", TypeScript.ErrorRecoverySet.RBrack);\r\n    setTokenInfo(TokenID.LCurly, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"{\", TypeScript.ErrorRecoverySet.LCurly);\r\n    setTokenInfo(TokenID.RCurly, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"}\", TypeScript.ErrorRecoverySet.RCurly);\r\n    setTokenInfo(TokenID.Ellipsis, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"...\", TypeScript.ErrorRecoverySet.None);\r\n    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Cma, TypeScript.NodeType.Comma, OperatorPrecedence.No, TypeScript.NodeType.None, \",\", TypeScript.ErrorRecoverySet.Comma);\r\n    setTokenInfo(TokenID.Asg, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.Asg, OperatorPrecedence.No, TypeScript.NodeType.None, \"=\", TypeScript.ErrorRecoverySet.Asg);\r\n    setTokenInfo(TokenID.AsgAdd, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgAdd, OperatorPrecedence.No, TypeScript.NodeType.None, \"+=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgSub, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgSub, OperatorPrecedence.No, TypeScript.NodeType.None, \"-=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgMul, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgMul, OperatorPrecedence.No, TypeScript.NodeType.None, \"*=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgDiv, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgDiv, OperatorPrecedence.No, TypeScript.NodeType.None, \"/=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgMod, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgMod, OperatorPrecedence.No, TypeScript.NodeType.None, \"%=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgAnd, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgAnd, OperatorPrecedence.No, TypeScript.NodeType.None, \"&=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgXor, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgXor, OperatorPrecedence.No, TypeScript.NodeType.None, \"^=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgOr, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgOr, OperatorPrecedence.No, TypeScript.NodeType.None, \"|=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgLsh, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgLsh, OperatorPrecedence.No, TypeScript.NodeType.None, \"<<=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgRsh, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgRsh, OperatorPrecedence.No, TypeScript.NodeType.None, \">>=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.AsgRs2, Reservation.None, OperatorPrecedence.Asg, TypeScript.NodeType.AsgRs2, OperatorPrecedence.No, TypeScript.NodeType.None, \">>>=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.QMark, Reservation.None, OperatorPrecedence.Que, TypeScript.NodeType.QMark, OperatorPrecedence.No, TypeScript.NodeType.None, \"?\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \":\", TypeScript.ErrorRecoverySet.Colon);\r\n    setTokenInfo(TokenID.LogOr, Reservation.None, OperatorPrecedence.Lor, TypeScript.NodeType.LogOr, OperatorPrecedence.No, TypeScript.NodeType.None, \"||\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.LogAnd, Reservation.None, OperatorPrecedence.Lan, TypeScript.NodeType.LogAnd, OperatorPrecedence.No, TypeScript.NodeType.None, \"&&\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Or, Reservation.None, OperatorPrecedence.Bor, TypeScript.NodeType.Or, OperatorPrecedence.No, TypeScript.NodeType.None, \"|\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Xor, Reservation.None, OperatorPrecedence.Xor, TypeScript.NodeType.Xor, OperatorPrecedence.No, TypeScript.NodeType.None, \"^\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.Ban, TypeScript.NodeType.And, OperatorPrecedence.No, TypeScript.NodeType.None, \"&\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.EQ, Reservation.None, OperatorPrecedence.Equ, TypeScript.NodeType.Eq, OperatorPrecedence.No, TypeScript.NodeType.None, \"==\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.NE, Reservation.None, OperatorPrecedence.Equ, TypeScript.NodeType.Ne, OperatorPrecedence.No, TypeScript.NodeType.None, \"!=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Eqv, Reservation.None, OperatorPrecedence.Equ, TypeScript.NodeType.Eqv, OperatorPrecedence.No, TypeScript.NodeType.None, \"===\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.NEqv, Reservation.None, OperatorPrecedence.Equ, TypeScript.NodeType.NEqv, OperatorPrecedence.No, TypeScript.NodeType.None, \"!==\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.LT, Reservation.None, OperatorPrecedence.Cmp, TypeScript.NodeType.Lt, OperatorPrecedence.No, TypeScript.NodeType.None, \"<\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.LE, Reservation.None, OperatorPrecedence.Cmp, TypeScript.NodeType.Le, OperatorPrecedence.No, TypeScript.NodeType.None, \"<=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.GT, Reservation.None, OperatorPrecedence.Cmp, TypeScript.NodeType.Gt, OperatorPrecedence.No, TypeScript.NodeType.None, \">\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.GE, Reservation.None, OperatorPrecedence.Cmp, TypeScript.NodeType.Ge, OperatorPrecedence.No, TypeScript.NodeType.None, \">=\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Lsh, Reservation.None, OperatorPrecedence.Shf, TypeScript.NodeType.Lsh, OperatorPrecedence.No, TypeScript.NodeType.None, \"<<\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Rsh, Reservation.None, OperatorPrecedence.Shf, TypeScript.NodeType.Rsh, OperatorPrecedence.No, TypeScript.NodeType.None, \">>\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Rs2, Reservation.None, OperatorPrecedence.Shf, TypeScript.NodeType.Rs2, OperatorPrecedence.No, TypeScript.NodeType.None, \">>>\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Add, Reservation.None, OperatorPrecedence.Add, TypeScript.NodeType.Add, OperatorPrecedence.Uni, TypeScript.NodeType.Pos, \"+\", TypeScript.ErrorRecoverySet.AddOp);\r\n    setTokenInfo(TokenID.Sub, Reservation.None, OperatorPrecedence.Add, TypeScript.NodeType.Sub, OperatorPrecedence.Uni, TypeScript.NodeType.Neg, \"-\", TypeScript.ErrorRecoverySet.AddOp);\r\n    setTokenInfo(TokenID.Mult, Reservation.None, OperatorPrecedence.Mul, TypeScript.NodeType.Mul, OperatorPrecedence.No, TypeScript.NodeType.None, \"*\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Div, Reservation.None, OperatorPrecedence.Mul, TypeScript.NodeType.Div, OperatorPrecedence.No, TypeScript.NodeType.None, \"/\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Pct, Reservation.None, OperatorPrecedence.Mul, TypeScript.NodeType.Mod, OperatorPrecedence.No, TypeScript.NodeType.None, \"%\", TypeScript.ErrorRecoverySet.BinOp);\r\n    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.Uni, TypeScript.NodeType.Not, \"~\", TypeScript.ErrorRecoverySet.PreOp);\r\n    setTokenInfo(TokenID.Bang, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.Uni, TypeScript.NodeType.LogNot, \"!\", TypeScript.ErrorRecoverySet.PreOp);\r\n    setTokenInfo(TokenID.Inc, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.Uni, TypeScript.NodeType.IncPre, \"++\", TypeScript.ErrorRecoverySet.PreOp);\r\n    setTokenInfo(TokenID.Dec, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.Uni, TypeScript.NodeType.DecPre, \"--\", TypeScript.ErrorRecoverySet.PreOp);\r\n    setTokenInfo(TokenID.LParen, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"(\", TypeScript.ErrorRecoverySet.LParen);\r\n    setTokenInfo(TokenID.LBrack, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"[\", TypeScript.ErrorRecoverySet.LBrack);\r\n    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Uni, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \".\", TypeScript.ErrorRecoverySet.Dot);\r\n    setTokenInfo(TokenID.EOF, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"<EOF>\", TypeScript.ErrorRecoverySet.EOF);\r\n    setTokenInfo(TokenID.Arrow, Reservation.None, OperatorPrecedence.No, TypeScript.NodeType.None, OperatorPrecedence.No, TypeScript.NodeType.None, \"=>\", TypeScript.ErrorRecoverySet.None);\r\n    function lookupToken(tokenId) {\r\n        return TypeScript.tokenTable[tokenId];\r\n    }\r\n    TypeScript.lookupToken = lookupToken;\r\n    (function (TokenClass) {\r\n        TokenClass._map = [];\r\n        TokenClass._map[0] = \"Punctuation\";\r\n        TokenClass.Punctuation = 0;\r\n        TokenClass._map[1] = \"Keyword\";\r\n        TokenClass.Keyword = 1;\r\n        TokenClass._map[2] = \"Operator\";\r\n        TokenClass.Operator = 2;\r\n        TokenClass._map[3] = \"Comment\";\r\n        TokenClass.Comment = 3;\r\n        TokenClass._map[4] = \"Whitespace\";\r\n        TokenClass.Whitespace = 4;\r\n        TokenClass._map[5] = \"Identifier\";\r\n        TokenClass.Identifier = 5;\r\n        TokenClass._map[6] = \"Literal\";\r\n        TokenClass.Literal = 6;\r\n    })(TypeScript.TokenClass || (TypeScript.TokenClass = {}));\r\n    var TokenClass = TypeScript.TokenClass;\r\n\r\n    var SavedToken = (function () {\r\n        function SavedToken(tok, minChar, limChar) {\r\n            this.tok = tok;\r\n            this.minChar = minChar;\r\n            this.limChar = limChar;\r\n        }\r\n        return SavedToken;\r\n    })();\r\n    TypeScript.SavedToken = SavedToken;    \r\n    var Token = (function () {\r\n        function Token(tokenId) {\r\n            this.tokenId = tokenId;\r\n        }\r\n        Token.prototype.toString = function () {\r\n            return \"token: \" + this.tokenId + \" \" + this.getText() + \" (\" + (TokenID)._map[this.tokenId] + \")\";\r\n        };\r\n        Token.prototype.print = function (line, outfile) {\r\n            outfile.WriteLine(this.toString() + \",on line\" + line);\r\n        };\r\n        Token.prototype.getText = function () {\r\n            return TypeScript.tokenTable[this.tokenId].text;\r\n        };\r\n        Token.prototype.classification = function () {\r\n            if(this.tokenId <= TokenID.LimKeyword) {\r\n                return TokenClass.Keyword;\r\n            } else {\r\n                var tokenInfo = lookupToken(this.tokenId);\r\n                if(tokenInfo != undefined) {\r\n                    if((tokenInfo.unopNodeType != TypeScript.NodeType.None) || (tokenInfo.binopNodeType != TypeScript.NodeType.None)) {\r\n                        return TokenClass.Operator;\r\n                    }\r\n                }\r\n            }\r\n            return TokenClass.Punctuation;\r\n        };\r\n        return Token;\r\n    })();\r\n    TypeScript.Token = Token;    \r\n    var NumberToken = (function (_super) {\r\n        __extends(NumberToken, _super);\r\n        function NumberToken(value) {\r\n                _super.call(this, TokenID.NumberLit);\r\n            this.value = value;\r\n        }\r\n        NumberToken.prototype.getText = function () {\r\n            return this.value.toString();\r\n        };\r\n        NumberToken.prototype.classification = function () {\r\n            return TokenClass.Literal;\r\n        };\r\n        return NumberToken;\r\n    })(Token);\r\n    TypeScript.NumberToken = NumberToken;    \r\n    var StringToken = (function (_super) {\r\n        __extends(StringToken, _super);\r\n        function StringToken(tokenId, value) {\r\n                _super.call(this, tokenId);\r\n            this.value = value;\r\n            this.tokenId = tokenId;\r\n        }\r\n        StringToken.prototype.getText = function () {\r\n            return this.value;\r\n        };\r\n        StringToken.prototype.classification = function () {\r\n            if(this.tokenId == TokenID.ID) {\r\n                return TokenClass.Identifier;\r\n            } else {\r\n                return TokenClass.Literal;\r\n            }\r\n        };\r\n        return StringToken;\r\n    })(Token);\r\n    TypeScript.StringToken = StringToken;    \r\n    var WhitespaceToken = (function (_super) {\r\n        __extends(WhitespaceToken, _super);\r\n        function WhitespaceToken(tokenId, value) {\r\n                _super.call(this, tokenId);\r\n            this.value = value;\r\n            this.tokenId = tokenId;\r\n        }\r\n        WhitespaceToken.prototype.getText = function () {\r\n            return this.value;\r\n        };\r\n        WhitespaceToken.prototype.classification = function () {\r\n            return TokenClass.Whitespace;\r\n        };\r\n        return WhitespaceToken;\r\n    })(Token);\r\n    TypeScript.WhitespaceToken = WhitespaceToken;    \r\n    var CommentToken = (function (_super) {\r\n        __extends(CommentToken, _super);\r\n        function CommentToken(tokenID, value, isBlock, startPos, line, endsLine) {\r\n                _super.call(this, tokenID);\r\n            this.value = value;\r\n            this.isBlock = isBlock;\r\n            this.startPos = startPos;\r\n            this.line = line;\r\n            this.endsLine = endsLine;\r\n            this.tokenID = tokenID;\r\n        }\r\n        CommentToken.prototype.getText = function () {\r\n            return this.value;\r\n        };\r\n        CommentToken.prototype.classification = function () {\r\n            return TokenClass.Comment;\r\n        };\r\n        return CommentToken;\r\n    })(Token);\r\n    TypeScript.CommentToken = CommentToken;    \r\n    var RegexToken = (function (_super) {\r\n        __extends(RegexToken, _super);\r\n        function RegexToken(regex) {\r\n                _super.call(this, TokenID.Regex);\r\n            this.regex = regex;\r\n        }\r\n        RegexToken.prototype.getText = function () {\r\n            return this.regex.toString();\r\n        };\r\n        RegexToken.prototype.classification = function () {\r\n            return TokenClass.Literal;\r\n        };\r\n        return RegexToken;\r\n    })(Token);\r\n    TypeScript.RegexToken = RegexToken;    \r\n    TypeScript.staticTokens = new Array();\r\n    function initializeStaticTokens() {\r\n        for(var i = 0; i <= TokenID.LimFixed; i++) {\r\n            TypeScript.staticTokens[i] = new Token(i);\r\n        }\r\n    }\r\n    TypeScript.initializeStaticTokens = initializeStaticTokens;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var ArrayCache = (function () {\r\n        function ArrayCache() {\r\n            this.arrayBase = null;\r\n        }\r\n        ArrayCache.prototype.specialize = function (arrInstType, checker) {\r\n            if(this.arrayBase == null) {\r\n                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType, checker, true);\r\n            }\r\n            return this.arrayBase;\r\n        };\r\n        return ArrayCache;\r\n    })();\r\n    TypeScript.ArrayCache = ArrayCache;    \r\n    var TypeComparisonInfo = (function () {\r\n        function TypeComparisonInfo() {\r\n            this.onlyCaptureFirstError = false;\r\n            this.flags = TypeScript.TypeRelationshipFlags.SuccessfulComparison;\r\n            this.message = \"\";\r\n        }\r\n        TypeComparisonInfo.prototype.addMessageToFront = function (message) {\r\n            if(!this.onlyCaptureFirstError) {\r\n                this.message = this.message ? message + \":\\n\\t\" + this.message : message;\r\n            } else {\r\n                this.setMessage(message);\r\n            }\r\n        };\r\n        TypeComparisonInfo.prototype.setMessage = function (message) {\r\n            this.message = message;\r\n        };\r\n        return TypeComparisonInfo;\r\n    })();\r\n    TypeScript.TypeComparisonInfo = TypeComparisonInfo;    \r\n    (function (TypeCheckCollectionMode) {\r\n        TypeCheckCollectionMode._map = [];\r\n        TypeCheckCollectionMode._map[0] = \"Resident\";\r\n        TypeCheckCollectionMode.Resident = 0;\r\n        TypeCheckCollectionMode._map[1] = \"Transient\";\r\n        TypeCheckCollectionMode.Transient = 1;\r\n    })(TypeScript.TypeCheckCollectionMode || (TypeScript.TypeCheckCollectionMode = {}));\r\n    var TypeCheckCollectionMode = TypeScript.TypeCheckCollectionMode;\r\n\r\n    var PersistentGlobalTypeState = (function () {\r\n        function PersistentGlobalTypeState(errorReporter) {\r\n            this.errorReporter = errorReporter;\r\n            this.importedGlobalsTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            this.importedGlobalsTypeTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            this.globals = null;\r\n            this.globalTypes = null;\r\n            this.ambientGlobals = null;\r\n            this.ambientGlobalTypes = null;\r\n            this.residentGlobalValues = new TypeScript.StringHashTable();\r\n            this.residentGlobalTypes = new TypeScript.StringHashTable();\r\n            this.residentGlobalAmbientValues = new TypeScript.StringHashTable();\r\n            this.residentGlobalAmbientTypes = new TypeScript.StringHashTable();\r\n            this.residentTypeCheck = true;\r\n            this.mod = null;\r\n            this.gloMod = null;\r\n            this.wildElm = null;\r\n            this.importedGlobals = new TypeScript.SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);\r\n            this.dualGlobalValues = new TypeScript.DualStringHashTable(this.residentGlobalValues, new TypeScript.StringHashTable());\r\n            this.dualGlobalTypes = new TypeScript.DualStringHashTable(this.residentGlobalTypes, new TypeScript.StringHashTable());\r\n            this.dualAmbientGlobalValues = new TypeScript.DualStringHashTable(this.residentGlobalAmbientValues, new TypeScript.StringHashTable());\r\n            this.dualAmbientGlobalTypes = new TypeScript.DualStringHashTable(this.residentGlobalAmbientTypes, new TypeScript.StringHashTable());\r\n            var dualGlobalScopedMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualGlobalValues, new TypeScript.StringHashTable()));\r\n            var dualGlobalScopedAmbientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualAmbientGlobalValues, new TypeScript.StringHashTable()));\r\n            var dualGlobalScopedEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualGlobalTypes, new TypeScript.StringHashTable()));\r\n            var dualGlobalScopedAmbientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualAmbientGlobalTypes, new TypeScript.StringHashTable()));\r\n            this.globalScope = new TypeScript.SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);\r\n            this.voidType = this.enterPrimitive(TypeScript.Primitive.Void, \"void\");\r\n            this.booleanType = this.enterPrimitive(TypeScript.Primitive.Boolean, \"bool\");\r\n            this.doubleType = this.enterPrimitive(TypeScript.Primitive.Double, \"number\");\r\n            this.importedGlobals.ambientEnclosedTypes.addPublicMember(\"number\", this.doubleType.symbol);\r\n            this.stringType = this.enterPrimitive(TypeScript.Primitive.String, \"string\");\r\n            this.anyType = this.enterPrimitive(TypeScript.Primitive.Any, \"any\");\r\n            this.nullType = this.enterPrimitive(TypeScript.Primitive.Null, \"null\");\r\n            this.undefinedType = this.enterPrimitive(TypeScript.Primitive.Undefined, \"undefined\");\r\n            this.setCollectionMode(TypeCheckCollectionMode.Resident);\r\n            this.wildElm = new TypeScript.TypeSymbol(\"_element\", 0, -1, new TypeScript.Type());\r\n            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);\r\n            this.mod = new TypeScript.ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);\r\n            this.mod.members = dualGlobalScopedMembers;\r\n            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;\r\n            this.mod.containedScope = this.globalScope;\r\n            this.gloMod = new TypeScript.TypeSymbol(TypeScript.globalId, 0, -1, this.mod);\r\n            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);\r\n            this.defineGlobalValue(\"undefined\", this.undefinedType);\r\n        }\r\n        PersistentGlobalTypeState.prototype.enterPrimitive = function (flags, name) {\r\n            var primitive = new TypeScript.Type();\r\n            primitive.primitiveTypeClass = flags;\r\n            var symbol = new TypeScript.TypeSymbol(name, 0, -1, primitive);\r\n            symbol.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;\r\n            primitive.symbol = symbol;\r\n            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);\r\n            return primitive;\r\n        };\r\n        PersistentGlobalTypeState.prototype.setCollectionMode = function (mode) {\r\n            this.residentTypeCheck = this.dualGlobalValues.insertPrimary = this.dualGlobalTypes.insertPrimary = this.dualAmbientGlobalValues.insertPrimary = this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident;\r\n        };\r\n        PersistentGlobalTypeState.prototype.refreshPersistentState = function () {\r\n            this.globals = new TypeScript.StringHashTable();\r\n            this.globalTypes = new TypeScript.StringHashTable();\r\n            this.ambientGlobals = new TypeScript.StringHashTable();\r\n            this.ambientGlobalTypes = new TypeScript.StringHashTable();\r\n            this.dualGlobalValues.secondaryTable = this.globals;\r\n            this.dualGlobalTypes.secondaryTable = this.globalTypes;\r\n            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;\r\n            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;\r\n        };\r\n        PersistentGlobalTypeState.prototype.defineGlobalValue = function (name, type) {\r\n            var valueLocation = new TypeScript.ValueLocation();\r\n            valueLocation.typeLink = new TypeScript.TypeLink();\r\n            var sym = new TypeScript.VariableSymbol(name, 0, -1, valueLocation);\r\n            sym.setType(type);\r\n            sym.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;\r\n            sym.container = this.gloMod;\r\n            this.importedGlobalsTable.addPublicMember(name, sym);\r\n        };\r\n        return PersistentGlobalTypeState;\r\n    })();\r\n    TypeScript.PersistentGlobalTypeState = PersistentGlobalTypeState;    \r\n    var ContextualTypeContext = (function () {\r\n        function ContextualTypeContext(contextualType, provisional, contextID) {\r\n            this.contextualType = contextualType;\r\n            this.provisional = provisional;\r\n            this.contextID = contextID;\r\n            this.targetSig = null;\r\n            this.targetThis = null;\r\n            this.targetAccessorType = null;\r\n        }\r\n        return ContextualTypeContext;\r\n    })();\r\n    TypeScript.ContextualTypeContext = ContextualTypeContext;    \r\n    var ContextualTypingContextStack = (function () {\r\n        function ContextualTypingContextStack(checker) {\r\n            this.checker = checker;\r\n            this.contextStack = [];\r\n            this.hadProvisionalErrors = false;\r\n        }\r\n        ContextualTypingContextStack.contextID = TypeScript.TypeCheckStatus.Finished + 1;\r\n        ContextualTypingContextStack.prototype.pushContextualType = function (type, provisional) {\r\n            this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++));\r\n            this.checker.errorReporter.pushToErrorSink = provisional;\r\n        };\r\n        ContextualTypingContextStack.prototype.popContextualType = function () {\r\n            var tc = this.contextStack.pop();\r\n            this.checker.errorReporter.pushToErrorSink = this.isProvisional();\r\n            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));\r\n            this.checker.errorReporter.freeCapturedErrors();\r\n            return tc;\r\n        };\r\n        ContextualTypingContextStack.prototype.getContextualType = function () {\r\n            return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]);\r\n        };\r\n        ContextualTypingContextStack.prototype.getContextID = function () {\r\n            return (!this.contextStack.length ? TypeScript.TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID);\r\n        };\r\n        ContextualTypingContextStack.prototype.isProvisional = function () {\r\n            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);\r\n        };\r\n        return ContextualTypingContextStack;\r\n    })();\r\n    TypeScript.ContextualTypingContextStack = ContextualTypingContextStack;    \r\n    var TypeChecker = (function () {\r\n        function TypeChecker(persistentState) {\r\n            this.persistentState = persistentState;\r\n            this.errorReporter = null;\r\n            this.checkControlFlow = false;\r\n            this.printControlFlowGraph = false;\r\n            this.checkControlFlowUseDef = false;\r\n            this.styleSettings = null;\r\n            this.units = null;\r\n            this.anon = \"_anonymous\";\r\n            this.locationInfo = null;\r\n            this.typeFlow = null;\r\n            this.currentCompareA = null;\r\n            this.currentCompareB = null;\r\n            this.currentModDecl = null;\r\n            this.inBind = false;\r\n            this.inWith = false;\r\n            this.errorsOnWith = true;\r\n            this.currentContextualTypeContext = null;\r\n            this.resolvingBases = false;\r\n            this.canCallDefinitionSignature = false;\r\n            this.assignableCache = {\r\n            };\r\n            this.subtypeCache = {\r\n            };\r\n            this.identicalCache = {\r\n            };\r\n            this.provisionalStartedTypecheckObjects = [];\r\n            this.voidType = this.persistentState.voidType;\r\n            this.booleanType = this.persistentState.booleanType;\r\n            this.numberType = this.persistentState.doubleType;\r\n            this.stringType = this.persistentState.stringType;\r\n            this.anyType = this.persistentState.anyType;\r\n            this.nullType = this.persistentState.nullType;\r\n            this.undefinedType = this.persistentState.undefinedType;\r\n            this.globals = this.persistentState.dualGlobalValues;\r\n            this.globalTypes = this.persistentState.dualGlobalTypes;\r\n            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;\r\n            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;\r\n            this.gloModType = this.persistentState.mod;\r\n            this.gloMod = this.persistentState.gloMod;\r\n            this.wildElm = this.persistentState.wildElm;\r\n            this.globalScope = this.persistentState.globalScope;\r\n            this.typingContextStack = new ContextualTypingContextStack(this);\r\n        }\r\n        TypeChecker.prototype.setStyleOptions = function (style) {\r\n            this.styleSettings = style;\r\n        };\r\n        TypeChecker.prototype.setContextualType = function (type, provisional) {\r\n            this.typingContextStack.pushContextualType(type, provisional);\r\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\r\n        };\r\n        TypeChecker.prototype.unsetContextualType = function () {\r\n            var lastTC = this.typingContextStack.popContextualType();\r\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\r\n            return lastTC;\r\n        };\r\n        TypeChecker.prototype.hadProvisionalErrors = function () {\r\n            return this.typingContextStack.hadProvisionalErrors;\r\n        };\r\n        TypeChecker.prototype.resetProvisionalErrors = function () {\r\n            if(!this.typingContextStack.getContextualType()) {\r\n                this.typingContextStack.hadProvisionalErrors = false;\r\n            }\r\n        };\r\n        TypeChecker.prototype.typeCheckWithContextualType = function (contextType, provisional, condition, ast) {\r\n            if(condition) {\r\n                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);\r\n            }\r\n            this.typeFlow.typeCheck(ast);\r\n            if(condition) {\r\n                this.unsetContextualType();\r\n            }\r\n        };\r\n        TypeChecker.prototype.resetTargetType = function () {\r\n            this.currentContextualTypeContext = this.typingContextStack.getContextualType();\r\n        };\r\n        TypeChecker.prototype.killTargetType = function () {\r\n            this.currentContextualTypeContext = null;\r\n            this.errorReporter.pushToErrorSink = false;\r\n        };\r\n        TypeChecker.prototype.hasTargetType = function () {\r\n            return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType;\r\n        };\r\n        TypeChecker.prototype.getTargetTypeContext = function () {\r\n            return this.currentContextualTypeContext;\r\n        };\r\n        TypeChecker.prototype.inProvisionalTypecheckMode = function () {\r\n            return this.typingContextStack.isProvisional();\r\n        };\r\n        TypeChecker.prototype.getTypeCheckFinishedStatus = function () {\r\n            if(this.inProvisionalTypecheckMode()) {\r\n                return this.typingContextStack.getContextID();\r\n            }\r\n            return TypeScript.TypeCheckStatus.Finished;\r\n        };\r\n        TypeChecker.prototype.typeStatusIsFinished = function (status) {\r\n            return status == TypeScript.TypeCheckStatus.Finished || (this.inProvisionalTypecheckMode() && status == this.typingContextStack.getContextID());\r\n        };\r\n        TypeChecker.prototype.addStartedPTO = function (pto) {\r\n            if(this.inProvisionalTypecheckMode()) {\r\n                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;\r\n            }\r\n        };\r\n        TypeChecker.prototype.cleanStartedPTO = function () {\r\n            for(var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {\r\n                this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeScript.TypeCheckStatus.NotStarted;\r\n            }\r\n            this.provisionalStartedTypecheckObjects = [];\r\n        };\r\n        TypeChecker.prototype.collectTypes = function (ast) {\r\n            if(ast.nodeType == TypeScript.NodeType.Script) {\r\n                var script = ast;\r\n                this.locationInfo = script.locationInfo;\r\n            }\r\n            var globalChain = new TypeScript.ScopeChain(this.gloMod, null, this.globalScope);\r\n            var context = new TypeScript.TypeCollectionContext(globalChain, this);\r\n            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.preCollectTypes, TypeScript.postCollectTypes, null, context);\r\n        };\r\n        TypeChecker.prototype.makeArrayType = function (type) {\r\n            if(type.arrayCache == null) {\r\n                type.arrayCache = new ArrayCache();\r\n                type.arrayCache.arrayType = new TypeScript.Type();\r\n                type.arrayCache.arrayType.elementType = type;\r\n                type.arrayCache.arrayType.symbol = type.symbol;\r\n            }\r\n            return type.arrayCache.arrayType;\r\n        };\r\n        TypeChecker.prototype.getParameterList = function (args, container) {\r\n            var parameterTable = null;\r\n            var parameterBuilder = null;\r\n            var len = args.members.length;\r\n            var nonOptionalParams = 0;\r\n            var result = [];\r\n            if(len > 0) {\r\n                parameterTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                parameterBuilder = new TypeScript.SymbolScopeBuilder(parameterTable, null, null, null, null, container);\r\n                for(var i = 0; i < len; i++) {\r\n                    var parameter = args.members[i];\r\n                    var paramDef = new TypeScript.ValueLocation();\r\n                    var parameterSymbol = new TypeScript.ParameterSymbol(parameter.id.text, parameter.minChar, this.locationInfo.unitIndex, paramDef);\r\n                    parameterSymbol.declAST = parameter;\r\n                    parameter.id.sym = parameterSymbol;\r\n                    parameter.sym = parameterSymbol;\r\n                    paramDef.symbol = parameterSymbol;\r\n                    paramDef.typeLink = TypeScript.getTypeLink(parameter.typeExpr, this, false);\r\n                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false);\r\n                    result[result.length] = parameterSymbol;\r\n                    if(!parameter.isOptionalArg()) {\r\n                        nonOptionalParams++;\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                parameters: result,\r\n                nonOptionalParameterCount: nonOptionalParams\r\n            };\r\n        };\r\n        TypeChecker.prototype.createFunctionSignature = function (funcDecl, container, scope, overloadGroupSym, addToScope) {\r\n            var isExported = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Exported | TypeScript.FncFlags.ClassPropertyMethodExported) || container == this.gloMod;\r\n            var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Static);\r\n            var isPrivate = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Private);\r\n            var isDefinition = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Definition);\r\n            var isAmbient = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Ambient);\r\n            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\r\n            var isGlobal = container == this.gloMod;\r\n            var signature = new TypeScript.Signature();\r\n            var isLambda = funcDecl.fncFlags & TypeScript.FncFlags.IsFunctionExpression;\r\n            if(funcDecl.returnTypeAnnotation || isDefinition) {\r\n                signature.returnType = TypeScript.getTypeLink(funcDecl.returnTypeAnnotation, this, false);\r\n            } else {\r\n                signature.returnType = new TypeScript.TypeLink();\r\n                signature.returnType.type = this.anyType;\r\n            }\r\n            signature.hasVariableArgList = funcDecl.variableArgList;\r\n            var sigData = this.getParameterList(funcDecl.args, container);\r\n            signature.parameters = sigData.parameters;\r\n            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;\r\n            funcDecl.signature = signature;\r\n            signature.declAST = funcDecl;\r\n            var useOverloadGroupSym = overloadGroupSym && overloadGroupSym.getType() && !overloadGroupSym.isAccessor() && (funcDecl.isSignature() || (isAmbient == TypeScript.hasFlag(overloadGroupSym.flags, TypeScript.SymbolFlags.Ambient)));\r\n            if(useOverloadGroupSym && isPrivate != TypeScript.hasFlag(overloadGroupSym.flags, TypeScript.SymbolFlags.Private)) {\r\n                this.errorReporter.simpleError(funcDecl, \"Public/Private visibility of overloads does not agree\");\r\n            }\r\n            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new TypeScript.Type();\r\n            if(isConstructor) {\r\n                if(groupType.construct == null) {\r\n                    groupType.construct = new TypeScript.SignatureGroup();\r\n                }\r\n                groupType.construct.addSignature(signature);\r\n                groupType.construct.hasImplementation = !(funcDecl.isSignature());\r\n                if(groupType.construct.hasImplementation) {\r\n                    groupType.setHasImplementation();\r\n                }\r\n            } else {\r\n                if(funcDecl.isIndexerMember()) {\r\n                    if(groupType.index == null) {\r\n                        groupType.index = new TypeScript.SignatureGroup();\r\n                        groupType.index.flags |= TypeScript.SignatureFlags.IsIndexer;\r\n                    }\r\n                    groupType.index.addSignature(signature);\r\n                    groupType.index.hasImplementation = !(funcDecl.isSignature());\r\n                    if(groupType.index.hasImplementation) {\r\n                        groupType.setHasImplementation();\r\n                    }\r\n                } else {\r\n                    if(groupType.call == null) {\r\n                        groupType.call = new TypeScript.SignatureGroup();\r\n                    }\r\n                    groupType.call.addSignature(signature);\r\n                    groupType.call.hasImplementation = !(funcDecl.isSignature());\r\n                    if(groupType.call.hasImplementation) {\r\n                        groupType.setHasImplementation();\r\n                    }\r\n                }\r\n            }\r\n            var instanceType = groupType.instanceType;\r\n            if(instanceType && !isStatic) {\r\n                if(instanceType.call == null) {\r\n                    instanceType.call = groupType.call;\r\n                } else {\r\n                    if(groupType.call) {\r\n                        instanceType.call.signatures.concat(groupType.call.signatures);\r\n                    }\r\n                }\r\n            }\r\n            var funcName = null;\r\n            var usedHint = false;\r\n            if(funcDecl.name && !funcDecl.name.isMissing()) {\r\n                funcName = funcDecl.name.text;\r\n            } else {\r\n                if(funcDecl.hint) {\r\n                    funcName = funcDecl.hint;\r\n                    usedHint = true;\r\n                }\r\n            }\r\n            if(groupType.symbol == null) {\r\n                groupType.symbol = new TypeScript.TypeSymbol(funcName ? funcName : this.anon, funcDecl.minChar, this.locationInfo.unitIndex, groupType);\r\n                if(!useOverloadGroupSym) {\r\n                    groupType.symbol.declAST = funcDecl;\r\n                }\r\n            }\r\n            if(isStatic) {\r\n                groupType.symbol.flags |= TypeScript.SymbolFlags.Static;\r\n            }\r\n            if(isAmbient) {\r\n                groupType.symbol.flags |= TypeScript.SymbolFlags.Ambient;\r\n            }\r\n            if(isPrivate) {\r\n                groupType.symbol.flags |= TypeScript.SymbolFlags.Private;\r\n            }\r\n            groupType.symbol.isMethod = funcDecl.isMethod();\r\n            if(groupType.symbol.isMethod) {\r\n                groupType.symbol.flags |= TypeScript.SymbolFlags.Property;\r\n            }\r\n            funcDecl.type = groupType;\r\n            if(!isConstructor) {\r\n                if(funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {\r\n                    if(addToScope) {\r\n                        if(funcDecl.isMethod() && isStatic) {\r\n                            if(!(container).type.members.publicMembers.add(funcName, groupType.symbol)) {\r\n                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);\r\n                            }\r\n                            groupType.symbol.container = container;\r\n                        } else {\r\n                            if(overloadGroupSym == null || (overloadGroupSym.declAST && !(overloadGroupSym.declAST).isOverload && (container.isType()))) {\r\n                                scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if(!funcDecl.isSpecialFn()) {\r\n                            groupType.symbol.container = container;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if(!funcDecl.isSpecialFn()) {\r\n                        groupType.symbol.container = container;\r\n                    }\r\n                }\r\n            }\r\n            if(useOverloadGroupSym) {\r\n                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;\r\n                var classType = groupType;\r\n                if(classType != overloadGroupType) {\r\n                    if(classType.construct == null) {\r\n                        if(overloadGroupType && overloadGroupType.construct) {\r\n                            classType.construct = overloadGroupType.construct;\r\n                        } else {\r\n                            classType.construct = new TypeScript.SignatureGroup();\r\n                        }\r\n                    } else {\r\n                        if(overloadGroupType) {\r\n                            if(overloadGroupType.construct) {\r\n                                classType.construct.signatures.concat(overloadGroupType.construct.signatures);\r\n                            }\r\n                        }\r\n                    }\r\n                    if(overloadGroupType) {\r\n                        if(classType.call == null) {\r\n                            classType.call = overloadGroupType.call;\r\n                        } else {\r\n                            if(overloadGroupType.call) {\r\n                                classType.call.signatures.concat(overloadGroupType.call.signatures);\r\n                            }\r\n                        }\r\n                        if(!isStatic) {\r\n                            if(classType.instanceType == null) {\r\n                                classType.instanceType = overloadGroupType.instanceType;\r\n                            }\r\n                            var instanceType = classType.instanceType;\r\n                            if(instanceType) {\r\n                                if(instanceType.call == null) {\r\n                                    instanceType.call = overloadGroupType.call;\r\n                                } else {\r\n                                    if(overloadGroupType.call) {\r\n                                        instanceType.call.signatures.concat(overloadGroupType.call.signatures);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if(classType.index == null) {\r\n                            classType.index = overloadGroupType.index;\r\n                        } else {\r\n                            if(overloadGroupType.index) {\r\n                                classType.index.signatures.concat(overloadGroupType.index.signatures);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return signature;\r\n        };\r\n        TypeChecker.prototype.createAccessorSymbol = function (funcDecl, fgSym, enclosingClass, addToMembers, isClassProperty, scope, container) {\r\n            var accessorSym = null;\r\n            var sig = funcDecl.signature;\r\n            var nameText = funcDecl.name.text;\r\n            var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Static);\r\n            var isPrivate = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Private);\r\n            if(fgSym == null) {\r\n                var field = new TypeScript.ValueLocation();\r\n                accessorSym = new TypeScript.FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);\r\n                field.symbol = accessorSym;\r\n                accessorSym.declAST = funcDecl;\r\n                if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.GetAccessor)) {\r\n                    if(accessorSym.getter) {\r\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property getter\");\r\n                    }\r\n                    accessorSym.getter = sig.declAST.type.symbol;\r\n                } else {\r\n                    if(accessorSym.setter) {\r\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property setter\");\r\n                    }\r\n                    accessorSym.setter = sig.declAST.type.symbol;\r\n                }\r\n                field.typeLink = TypeScript.getTypeLink(null, this, false);\r\n                if(addToMembers) {\r\n                    if(enclosingClass) {\r\n                        if(!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {\r\n                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);\r\n                        }\r\n                        accessorSym.container = enclosingClass.symbol;\r\n                    } else {\r\n                        this.errorReporter.simpleError(funcDecl, \"Accessor property may not be added in this context\");\r\n                    }\r\n                } else {\r\n                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);\r\n                }\r\n                if(isClassProperty) {\r\n                    accessorSym.flags |= TypeScript.SymbolFlags.Property;\r\n                }\r\n                if(isStatic) {\r\n                    accessorSym.flags |= TypeScript.SymbolFlags.Static;\r\n                }\r\n                if(isPrivate) {\r\n                    accessorSym.flags |= TypeScript.SymbolFlags.Private;\r\n                } else {\r\n                    accessorSym.flags |= TypeScript.SymbolFlags.Public;\r\n                }\r\n            } else {\r\n                accessorSym = (fgSym);\r\n                if(isPrivate != TypeScript.hasFlag(accessorSym.flags, TypeScript.SymbolFlags.Private)) {\r\n                    this.errorReporter.simpleError(funcDecl, \"Getter and setter accessors do not agree in visibility\");\r\n                }\r\n                if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.GetAccessor)) {\r\n                    if(accessorSym.getter) {\r\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property getter\");\r\n                    }\r\n                    accessorSym.getter = funcDecl.type.symbol;\r\n                } else {\r\n                    if(accessorSym.setter) {\r\n                        this.errorReporter.simpleError(funcDecl, \"Redeclaration of property setter\");\r\n                    }\r\n                    accessorSym.setter = funcDecl.type.symbol;\r\n                }\r\n            }\r\n            return accessorSym;\r\n        };\r\n        TypeChecker.prototype.addBases = function (resultScope, type, baseContext) {\r\n            resultScope.addParentScope(new TypeScript.SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));\r\n            var i = 0;\r\n            var parent;\r\n            if(type.extendsList) {\r\n                for(var len = type.extendsList.length; i < len; i++) {\r\n                    parent = type.extendsList[i];\r\n                    if(baseContext.baseId == parent.typeID) {\r\n                        this.errorReporter.reportErrorFromSym(parent.symbol, \"Type '\" + baseContext.base + \"' is recursively referenced as a base class of itself\");\r\n                        parent.symbol.flags |= TypeScript.SymbolFlags.RecursivelyReferenced;\r\n                        break;\r\n                    }\r\n                    this.addBases(resultScope, parent, baseContext);\r\n                }\r\n            }\r\n        };\r\n        TypeChecker.prototype.scopeOf = function (type) {\r\n            var resultScope = new TypeScript.SymbolAggregateScope(type.symbol);\r\n            var baseContext = {\r\n                base: type.symbol && type.symbol.name ? type.symbol.name : \"{}\",\r\n                baseId: type.typeID\r\n            };\r\n            this.addBases(resultScope, type, baseContext);\r\n            return resultScope;\r\n        };\r\n        TypeChecker.prototype.lookupMemberType = function (containingType, name) {\r\n            var symbol = null;\r\n            if(containingType.containedScope) {\r\n                symbol = containingType.containedScope.find(name, false, true);\r\n            } else {\r\n                if(containingType.members) {\r\n                    symbol = containingType.members.allMembers.lookup(name);\r\n                    if(symbol == null && containingType.ambientMembers) {\r\n                        symbol = containingType.ambientMembers.allMembers.lookup(name);\r\n                    }\r\n                }\r\n            }\r\n            if(symbol == null) {\r\n                var typeMembers = containingType.getAllEnclosedTypes();\r\n                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();\r\n                if(typeMembers) {\r\n                    symbol = typeMembers.allMembers.lookup(name);\r\n                    if(symbol == null && ambientTypeMembers) {\r\n                        symbol = ambientTypeMembers.allMembers.lookup(name);\r\n                    }\r\n                }\r\n            }\r\n            if(symbol && symbol.isType()) {\r\n                return symbol.getType();\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n        TypeChecker.prototype.findSymbolForDynamicModule = function (idText, currentFileName, search) {\r\n            var originalIdText = idText;\r\n            var symbol = search(idText);\r\n            if(symbol == null) {\r\n                if(!symbol) {\r\n                    idText = TypeScript.swapQuotes(originalIdText);\r\n                    symbol = search(idText);\r\n                }\r\n                if(!symbol) {\r\n                    idText = TypeScript.stripQuotes(originalIdText) + \".ts\";\r\n                    symbol = search(idText);\r\n                }\r\n                if(!symbol) {\r\n                    idText = TypeScript.stripQuotes(originalIdText) + \".str\";\r\n                    symbol = search(idText);\r\n                }\r\n                if(!symbol) {\r\n                    idText = TypeScript.stripQuotes(originalIdText) + \".d.ts\";\r\n                    symbol = search(idText);\r\n                }\r\n                if(!symbol) {\r\n                    idText = TypeScript.stripQuotes(originalIdText) + \".d.str\";\r\n                    symbol = search(idText);\r\n                }\r\n                if(!symbol && !TypeScript.isRelative(originalIdText)) {\r\n                    idText = originalIdText;\r\n                    var strippedIdText = TypeScript.stripQuotes(idText);\r\n                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));\r\n                    while(symbol == null && path != \"\" && path != \"/\") {\r\n                        idText = TypeScript.normalizePath(path + strippedIdText + \".ts\");\r\n                        symbol = search(idText);\r\n                        if(symbol == null) {\r\n                            idText = TypeScript.changePathToSTR(idText);\r\n                            symbol = search(idText);\r\n                        }\r\n                        if(symbol == null) {\r\n                            idText = TypeScript.changePathToDTS(idText);\r\n                            symbol = search(idText);\r\n                        }\r\n                        if(symbol == null) {\r\n                            idText = TypeScript.changePathToDSTR(idText);\r\n                            symbol = search(idText);\r\n                        }\r\n                        if(symbol == null) {\r\n                            path = TypeScript.normalizePath(path + \"..\");\r\n                            path = path && path != '/' ? path + '/' : path;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return symbol;\r\n        };\r\n        TypeChecker.prototype.resolveTypeMember = function (scope, dotNode) {\r\n            var lhs = dotNode.operand1;\r\n            var rhs = dotNode.operand2;\r\n            var resultType = this.anyType;\r\n            var lhsType = this.anyType;\r\n            if(lhs && rhs && (rhs.nodeType == TypeScript.NodeType.Name)) {\r\n                if(lhs.nodeType == TypeScript.NodeType.Dot) {\r\n                    lhsType = this.resolveTypeMember(scope, lhs);\r\n                } else {\r\n                    if(lhs.nodeType == TypeScript.NodeType.Name) {\r\n                        var identifier = lhs;\r\n                        var symbol = scope.find(identifier.text, false, true);\r\n                        if(symbol == null) {\r\n                            this.errorReporter.unresolvedSymbol(identifier, identifier.text);\r\n                        } else {\r\n                            if(symbol.isType()) {\r\n                                var typeSymbol = symbol;\r\n                                if(typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == TypeScript.NodeType.Name) {\r\n                                    var modPath = (typeSymbol.aliasLink.alias).text;\r\n                                    var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.filename, function (id) {\r\n                                        return scope.find(id, false, true);\r\n                                    });\r\n                                    if(modSym) {\r\n                                        typeSymbol.type = modSym.getType();\r\n                                    }\r\n                                }\r\n                                if(TypeScript.optimizeModuleCodeGen && symbol) {\r\n                                    var symType = symbol.getType();\r\n                                    if(symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {\r\n                                        var modDecl = symType.symbol.declAST;\r\n                                        if(modDecl && TypeScript.hasFlag(modDecl.modFlags, TypeScript.ModuleFlags.IsDynamic)) {\r\n                                            typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if(!symbol.visible(scope, this)) {\r\n                                    this.errorReporter.simpleError(lhs, \"The symbol '\" + identifier.text + \"' is not visible at this point\");\r\n                                }\r\n                                lhsType = symbol.getType();\r\n                                identifier.sym = symbol;\r\n                            } else {\r\n                                this.errorReporter.simpleError(lhs, \"Expected type\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(!lhsType) {\r\n                    lhsType = this.anyType;\r\n                }\r\n                if(lhsType != this.anyType) {\r\n                    var rhsIdentifier = rhs;\r\n                    resultType = this.lookupMemberType(lhsType, rhsIdentifier.text);\r\n                    if(resultType == null) {\r\n                        resultType = this.anyType;\r\n                        this.errorReporter.simpleError(dotNode, \"Expected type\");\r\n                    } else {\r\n                        if(!resultType.symbol.visible(scope, this)) {\r\n                            this.errorReporter.simpleError(lhs, \"The symbol '\" + (rhs).text + \"' is not visible at this point\");\r\n                        }\r\n                    }\r\n                    rhsIdentifier.sym = resultType.symbol;\r\n                }\r\n            }\r\n            if(resultType.isClass()) {\r\n                resultType = resultType.instanceType;\r\n            }\r\n            return resultType;\r\n        };\r\n        TypeChecker.prototype.resolveFuncDecl = function (funcDecl, scope, fgSym) {\r\n            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;\r\n            var signatures;\r\n            if(funcDecl.isConstructMember()) {\r\n                signatures = functionGroupSymbol.type.construct.signatures;\r\n            } else {\r\n                if(funcDecl.isIndexerMember()) {\r\n                    signatures = functionGroupSymbol.type.getInstanceType().index.signatures;\r\n                } else {\r\n                    signatures = functionGroupSymbol.type.call.signatures;\r\n                }\r\n            }\r\n            var signature = signatures[signatures.length - 1];\r\n            var len = signature.parameters.length;\r\n            for(var i = 0; i < len; i++) {\r\n                var paramSym = signature.parameters[i];\r\n                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);\r\n            }\r\n            if(len && funcDecl.variableArgList) {\r\n                if(!signature.parameters[len - 1].parameter.typeLink.type.elementType) {\r\n                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, \"... parameter must have array type\");\r\n                    signature.parameters[len - 1].parameter.typeLink.type.elementType = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);\r\n                }\r\n            }\r\n            this.resolveTypeLink(scope, signature.returnType, funcDecl.isSignature());\r\n            return functionGroupSymbol;\r\n        };\r\n        TypeChecker.prototype.resolveVarDecl = function (varDecl, scope) {\r\n            var field = new TypeScript.ValueLocation();\r\n            var fieldSymbol = new TypeScript.FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex, (varDecl.varFlags & TypeScript.VarFlags.Readonly) == TypeScript.VarFlags.None, field);\r\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\r\n            field.symbol = fieldSymbol;\r\n            fieldSymbol.declAST = varDecl;\r\n            field.typeLink = TypeScript.getTypeLink(varDecl.typeExpr, this, varDecl.init == null);\r\n            this.resolveTypeLink(scope, field.typeLink, true);\r\n            varDecl.sym = fieldSymbol;\r\n            varDecl.type = field.typeLink.type;\r\n            return fieldSymbol;\r\n        };\r\n        TypeChecker.prototype.resolveTypeLink = function (scope, typeLink, supplyVar) {\r\n            var arrayCount = 0;\r\n            if(typeLink.type == null) {\r\n                var ast = typeLink.ast;\r\n                if(ast) {\r\n                    while(typeLink.type == null) {\r\n                        switch(ast.nodeType) {\r\n                            case TypeScript.NodeType.Name: {\r\n                                var identifier = ast;\r\n                                var symbol = scope.find(identifier.text, false, true);\r\n                                if(symbol == null) {\r\n                                    typeLink.type = this.anyType;\r\n                                    this.errorReporter.unresolvedSymbol(identifier, identifier.text);\r\n                                } else {\r\n                                    if(symbol.isType()) {\r\n                                        if(!symbol.visible(scope, this)) {\r\n                                            this.errorReporter.simpleError(ast, \"The symbol '\" + identifier.text + \"' is not visible at this point\");\r\n                                        }\r\n                                        identifier.sym = symbol;\r\n                                        typeLink.type = symbol.getType();\r\n                                        if(typeLink.type) {\r\n                                            if(typeLink.type.isClass()) {\r\n                                                typeLink.type = typeLink.type.instanceType;\r\n                                            }\r\n                                        } else {\r\n                                            typeLink.type = this.anyType;\r\n                                        }\r\n                                    } else {\r\n                                        typeLink.type = this.anyType;\r\n                                        this.errorReporter.simpleError(ast, \"Expected type\");\r\n                                    }\r\n                                }\r\n                                break;\r\n\r\n                            }\r\n                            case TypeScript.NodeType.Dot: {\r\n                                typeLink.type = this.resolveTypeMember(scope, ast);\r\n                                break;\r\n\r\n                            }\r\n                            case TypeScript.NodeType.TypeRef: {\r\n                                var typeRef = ast;\r\n                                arrayCount = typeRef.arrayCount;\r\n                                ast = typeRef.term;\r\n                                if(ast == null) {\r\n                                    typeLink.type = this.anyType;\r\n                                }\r\n                                break;\r\n\r\n                            }\r\n                            case TypeScript.NodeType.Interface: {\r\n                                var interfaceDecl = ast;\r\n                                var interfaceType = new TypeScript.Type();\r\n                                var interfaceSymbol = new TypeScript.TypeSymbol((interfaceDecl.name).text, ast.minChar, this.locationInfo.unitIndex, interfaceType);\r\n                                interfaceType.symbol = interfaceSymbol;\r\n                                interfaceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                                interfaceType.containedScope = new TypeScript.SymbolTableScope(interfaceType.members, null, null, null, interfaceSymbol);\r\n                                interfaceType.containedScope.container = interfaceSymbol;\r\n                                interfaceType.memberScope = interfaceType.containedScope;\r\n                                var memberList = interfaceDecl.members;\r\n                                var props = memberList.members;\r\n                                var propsLen = props.length;\r\n                                for(var j = 0; j < propsLen; j++) {\r\n                                    var propDecl = props[j];\r\n                                    var propSym = null;\r\n                                    var addMember = true;\r\n                                    var id = null;\r\n                                    if(propDecl.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                        var funcDecl = propDecl;\r\n                                        id = funcDecl.name;\r\n                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());\r\n                                        addMember = (propSym == null);\r\n                                        if(funcDecl.isSpecialFn()) {\r\n                                            addMember = false;\r\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);\r\n                                        } else {\r\n                                            propSym = this.resolveFuncDecl(funcDecl, scope, propSym);\r\n                                        }\r\n                                        funcDecl.type = (propSym).type;\r\n                                    } else {\r\n                                        id = (propDecl).id;\r\n                                        propSym = this.resolveVarDecl(propDecl, scope);\r\n                                    }\r\n                                    if(addMember) {\r\n                                        if(id && TypeScript.hasFlag(id.flags, TypeScript.ASTFlags.OptionalName)) {\r\n                                            propSym.flags |= TypeScript.SymbolFlags.Optional;\r\n                                        }\r\n                                        if(!interfaceType.members.allMembers.add(propSym.name, propSym)) {\r\n                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                ast.type = interfaceType;\r\n                                typeLink.type = interfaceType;\r\n                                break;\r\n\r\n                            }\r\n                            case TypeScript.NodeType.FuncDecl: {\r\n                                var tsym = this.resolveFuncDecl(ast, scope, null);\r\n                                typeLink.type = tsym.type;\r\n                                break;\r\n\r\n                            }\r\n                            default: {\r\n                                typeLink.type = this.anyType;\r\n                                this.errorReporter.simpleError(ast, \"Expected type\");\r\n                                break;\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                for(var count = arrayCount; count > 0; count--) {\r\n                    typeLink.type = this.makeArrayType(typeLink.type);\r\n                }\r\n                if(supplyVar && (typeLink.type == null)) {\r\n                    typeLink.type = this.anyType;\r\n                }\r\n                if(typeLink.ast) {\r\n                    typeLink.ast.type = typeLink.type;\r\n                }\r\n            }\r\n        };\r\n        TypeChecker.prototype.findMostApplicableSignature = function (signatures, args) {\r\n            if(signatures.length == 1) {\r\n                return {\r\n                    sig: signatures[0].signature,\r\n                    ambiguous: false\r\n                };\r\n            }\r\n            var best = signatures[0];\r\n            var Q = null;\r\n            var AType = null;\r\n            var PType = null;\r\n            var QType = null;\r\n            var ambiguous = false;\r\n            for(var qSig = 1; qSig < signatures.length; qSig++) {\r\n                Q = signatures[qSig];\r\n                var i = 0;\r\n                for(i = 0; args && i < args.members.length; i++) {\r\n                    AType = args.members[i].type;\r\n                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;\r\n                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;\r\n                    if(this.typesAreIdentical(PType, QType)) {\r\n                        continue;\r\n                    } else {\r\n                        if(this.typesAreIdentical(AType, PType)) {\r\n                            break;\r\n                        } else {\r\n                            if(this.typesAreIdentical(AType, QType)) {\r\n                                best = Q;\r\n                                break;\r\n                            } else {\r\n                                if(this.sourceIsSubtypeOfTarget(PType, QType)) {\r\n                                    break;\r\n                                } else {\r\n                                    if(this.sourceIsSubtypeOfTarget(QType, PType)) {\r\n                                        best = Q;\r\n                                        break;\r\n                                    } else {\r\n                                        if(Q.hadProvisionalErrors) {\r\n                                            break;\r\n                                        } else {\r\n                                            if(best.hadProvisionalErrors) {\r\n                                                best = Q;\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(!args || i == args.members.length) {\r\n                    var collection = {\r\n                        getLength: function () {\r\n                            return 2;\r\n                        },\r\n                        setTypeAtIndex: function (index, type) {\r\n                        },\r\n                        getTypeAtIndex: function (index) {\r\n                            return index ? Q.signature.returnType.type : best.signature.returnType.type;\r\n                        }\r\n                    };\r\n                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection);\r\n                    ambiguous = !bct;\r\n                } else {\r\n                    ambiguous = false;\r\n                }\r\n            }\r\n            return {\r\n                sig: best.signature,\r\n                ambiguous: ambiguous\r\n            };\r\n        };\r\n        TypeChecker.prototype.getApplicableSignatures = function (signatures, args, comparisonInfo) {\r\n            var applicableSigs = [];\r\n            var memberType = null;\r\n            var miss = false;\r\n            var cxt = null;\r\n            var hadProvisionalErrors = false;\r\n            for(var i = 0; i < signatures.length; i++) {\r\n                miss = false;\r\n                for(var j = 0; j < args.members.length; j++) {\r\n                    if(j >= signatures[i].parameters.length) {\r\n                        continue;\r\n                    }\r\n                    memberType = signatures[i].parameters[j].getType();\r\n                    if(signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {\r\n                        memberType = memberType.elementType;\r\n                    }\r\n                    if(memberType == this.anyType) {\r\n                        continue;\r\n                    } else {\r\n                        if(args.members[j].nodeType == TypeScript.NodeType.FuncDecl) {\r\n                            if(this.typeFlow.functionInterfaceType && memberType == this.typeFlow.functionInterfaceType) {\r\n                                continue;\r\n                            }\r\n                            if(!this.canContextuallyTypeFunction(memberType, args.members[j], true)) {\r\n                                if(this.canContextuallyTypeFunction(memberType, args.members[j], false)) {\r\n                                    this.typeFlow.typeCheck(args.members[j]);\r\n                                    if(!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\r\n                                        break;\r\n                                    }\r\n                                } else {\r\n                                    break;\r\n                                }\r\n                            } else {\r\n                                this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\r\n                                this.cleanStartedPTO();\r\n                                hadProvisionalErrors = this.hadProvisionalErrors();\r\n                                if(!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\r\n                                    if(comparisonInfo) {\r\n                                        comparisonInfo.setMessage(\"Could not apply type '\" + memberType.getTypeName() + \"' to argument \" + (j + 1) + \", which is of type '\" + args.members[j].type.getTypeName() + \"'\");\r\n                                    }\r\n                                    miss = true;\r\n                                }\r\n                                if(hadProvisionalErrors) {\r\n                                    cxt = this.currentContextualTypeContext;\r\n                                    this.typeCheckWithContextualType(null, true, true, args.members[j]);\r\n                                    if(!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\r\n                                        miss = true;\r\n                                    }\r\n                                    this.cleanStartedPTO();\r\n                                }\r\n                                this.resetProvisionalErrors();\r\n                                if(miss) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if(args.members[j].nodeType == TypeScript.NodeType.ObjectLit) {\r\n                                if(this.typeFlow.objectInterfaceType && memberType == this.typeFlow.objectInterfaceType) {\r\n                                    continue;\r\n                                }\r\n                                this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\r\n                                this.cleanStartedPTO();\r\n                                hadProvisionalErrors = this.hadProvisionalErrors();\r\n                                if(!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\r\n                                    if(comparisonInfo) {\r\n                                        comparisonInfo.setMessage(\"Could not apply type '\" + memberType.getTypeName() + \"' to argument \" + (j + 1) + \", which is of type '\" + args.members[j].type.getTypeName() + \"'\");\r\n                                    }\r\n                                    miss = true;\r\n                                }\r\n                                if(hadProvisionalErrors) {\r\n                                    this.typeCheckWithContextualType(null, true, true, args.members[j]);\r\n                                    if(!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\r\n                                        miss = true;\r\n                                    }\r\n                                    this.cleanStartedPTO();\r\n                                }\r\n                                this.resetProvisionalErrors();\r\n                                if(miss) {\r\n                                    break;\r\n                                }\r\n                            } else {\r\n                                if(args.members[j].nodeType == TypeScript.NodeType.ArrayLit) {\r\n                                    if(this.typeFlow.arrayInterfaceType && memberType == this.typeFlow.arrayInterfaceType) {\r\n                                        continue;\r\n                                    }\r\n                                    this.typeCheckWithContextualType(memberType, true, true, args.members[j]);\r\n                                    this.cleanStartedPTO();\r\n                                    hadProvisionalErrors = this.hadProvisionalErrors();\r\n                                    if(!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {\r\n                                        if(comparisonInfo) {\r\n                                            comparisonInfo.setMessage(\"Could not apply type '\" + memberType.getTypeName() + \"' to argument \" + (j + 1) + \", which is of type '\" + args.members[j].type.getTypeName() + \"'\");\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(hadProvisionalErrors) {\r\n                                        this.typeCheckWithContextualType(null, true, true, args.members[j]);\r\n                                        if(!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {\r\n                                            miss = true;\r\n                                        }\r\n                                        this.cleanStartedPTO();\r\n                                    }\r\n                                    this.resetProvisionalErrors();\r\n                                    if(miss) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(j == args.members.length) {\r\n                    applicableSigs[applicableSigs.length] = {\r\n                        signature: signatures[i],\r\n                        hadProvisionalErrors: hadProvisionalErrors\r\n                    };\r\n                }\r\n                hadProvisionalErrors = false;\r\n            }\r\n            return applicableSigs;\r\n        };\r\n        TypeChecker.prototype.canContextuallyTypeFunction = function (candidateType, funcDecl, beStringent) {\r\n            if(funcDecl.isParenthesized || funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation || funcDecl.isInlineCallLiteral) {\r\n                return false;\r\n            }\r\n            beStringent = beStringent || (this.typeFlow.functionInterfaceType == candidateType);\r\n            if(!beStringent) {\r\n                return true;\r\n            }\r\n            if(!funcDecl.signature) {\r\n                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);\r\n                this.typeFlow.typeCheck(funcDecl);\r\n            }\r\n            var signature = funcDecl.signature;\r\n            var paramLen = signature.parameters.length;\r\n            for(var i = 0; i < paramLen; i++) {\r\n                var param = signature.parameters[i];\r\n                var symbol = param;\r\n                var argDecl = symbol.declAST;\r\n                if(beStringent && argDecl.typeExpr) {\r\n                    return false;\r\n                }\r\n            }\r\n            if(candidateType.construct && candidateType.call) {\r\n                return false;\r\n            }\r\n            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\r\n            if(!candidateSigs || candidateSigs.signatures.length > 1) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        TypeChecker.prototype.canContextuallyTypeObjectLiteral = function (targetType, objectLit) {\r\n            if(targetType == this.typeFlow.objectInterfaceType) {\r\n                return true;\r\n            }\r\n            var memberDecls = objectLit.operand;\r\n            if(!(memberDecls && targetType.memberScope)) {\r\n                return false;\r\n            }\r\n            var id = null;\r\n            var targetMember = null;\r\n            var text = \"\";\r\n            var foundSyms = {\r\n            };\r\n            for(var i = 0; i < memberDecls.members.length; i++) {\r\n                id = (memberDecls.members[i]).operand1;\r\n                if(id.nodeType == TypeScript.NodeType.Name) {\r\n                    text = (id).text;\r\n                } else {\r\n                    if(id.nodeType == TypeScript.NodeType.QString) {\r\n                        var idText = (id).text;\r\n                        text = idText.substring(1, idText.length - 1);\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n                targetMember = targetType.memberScope.find(text, true, false);\r\n                if(!targetMember) {\r\n                    return false;\r\n                }\r\n                foundSyms[text] = true;\r\n            }\r\n            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);\r\n            for(var i = 0; i < targetMembers.length; i++) {\r\n                var memberName = targetMembers[i];\r\n                var memberSym = targetType.memberScope.find(memberName, true, false);\r\n                if(!foundSyms[targetMembers[i]] && !TypeScript.hasFlag(memberSym.flags, TypeScript.SymbolFlags.Optional)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        TypeChecker.prototype.widenType = function (t) {\r\n            if(t == this.undefinedType || t == this.nullType) {\r\n                return this.anyType;\r\n            }\r\n            return t;\r\n        };\r\n        TypeChecker.prototype.isNullOrUndefinedType = function (t) {\r\n            return t == this.undefinedType || t == this.nullType;\r\n        };\r\n        TypeChecker.prototype.findBestCommonType = function (initialType, targetType, collection, comparisonInfo) {\r\n            var i = 0;\r\n            var len = collection.getLength();\r\n            var nlastChecked = 0;\r\n            var bestCommonType = initialType;\r\n            if(targetType) {\r\n                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this) : targetType;\r\n            }\r\n            var convergenceType = bestCommonType;\r\n            while(nlastChecked < len) {\r\n                for(i = 0; i < len; i++) {\r\n                    if(i == nlastChecked) {\r\n                        continue;\r\n                    }\r\n                    if(convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, comparisonInfo))) {\r\n                        convergenceType = bestCommonType;\r\n                    }\r\n                    if(bestCommonType == this.anyType || bestCommonType == null) {\r\n                        break;\r\n                    } else {\r\n                        if(targetType) {\r\n                            collection.setTypeAtIndex(i, targetType);\r\n                        }\r\n                    }\r\n                }\r\n                if(convergenceType && bestCommonType) {\r\n                    break;\r\n                }\r\n                nlastChecked++;\r\n                if(nlastChecked < len) {\r\n                    convergenceType = collection.getTypeAtIndex(nlastChecked);\r\n                }\r\n            }\r\n            return bestCommonType;\r\n        };\r\n        TypeChecker.prototype.typesAreIdentical = function (t1, t2) {\r\n            if(t1 == t2) {\r\n                return true;\r\n            }\r\n            if(!t1 || !t2) {\r\n                return false;\r\n            }\r\n            var comboId = (t2.typeID << 16) | t1.typeID;\r\n            if(this.identicalCache[comboId]) {\r\n                return true;\r\n            }\r\n            if((t1.typeFlags & TypeScript.TypeFlags.IsEnum) || (t2.typeFlags & TypeScript.TypeFlags.IsEnum)) {\r\n                return false;\r\n            }\r\n            if(t1.isArray() || t2.isArray()) {\r\n                if(!(t1.isArray() && t2.isArray())) {\r\n                    return false;\r\n                }\r\n                this.identicalCache[comboId] = false;\r\n                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);\r\n                if(ret) {\r\n                    this.subtypeCache[comboId] = true;\r\n                } else {\r\n                    this.subtypeCache[comboId] = undefined;\r\n                }\r\n                return ret;\r\n            }\r\n            if(t1.primitiveTypeClass != t2.primitiveTypeClass) {\r\n                return false;\r\n            }\r\n            this.identicalCache[comboId] = false;\r\n            if(t1.memberScope && t2.memberScope) {\r\n                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();\r\n                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();\r\n                if(t1MemberKeys.length != t2MemberKeys.length) {\r\n                    this.identicalCache[comboId] = undefined;\r\n                    return false;\r\n                }\r\n                var t1MemberSymbol = null;\r\n                var t2MemberSymbol = null;\r\n                var t1MemberType = null;\r\n                var t2MemberType = null;\r\n                for(var iMember = 0; iMember < t1MemberKeys.length; iMember++) {\r\n                    if(t1MemberKeys[iMember] != t2MemberKeys[iMember]) {\r\n                        this.identicalCache[comboId] = undefined;\r\n                        return false;\r\n                    }\r\n                    t1MemberSymbol = t1.memberScope.find(t1MemberKeys[iMember], false, false);\r\n                    t2MemberSymbol = t2.memberScope.find(t2MemberKeys[iMember], false, false);\r\n                    if((t1MemberSymbol.flags & TypeScript.SymbolFlags.Optional) != (t2MemberSymbol.flags & TypeScript.SymbolFlags.Optional)) {\r\n                        this.identicalCache[comboId] = undefined;\r\n                        return false;\r\n                    }\r\n                    t1MemberType = t1MemberSymbol.getType();\r\n                    t2MemberType = t2MemberSymbol.getType();\r\n                    if(t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {\r\n                        continue;\r\n                    }\r\n                    if(!this.typesAreIdentical(t1MemberType, t2MemberType)) {\r\n                        this.identicalCache[comboId] = undefined;\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                if(t1.memberScope || t2.memberScope) {\r\n                    this.identicalCache[comboId] = undefined;\r\n                    return false;\r\n                }\r\n            }\r\n            if(!this.signatureGroupsAreIdentical(t1.call, t2.call)) {\r\n                this.identicalCache[comboId] = undefined;\r\n                return false;\r\n            }\r\n            if(!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {\r\n                this.identicalCache[comboId] = undefined;\r\n                return false;\r\n            }\r\n            if(!this.signatureGroupsAreIdentical(t1.index, t2.index)) {\r\n                this.identicalCache[comboId] = undefined;\r\n                return false;\r\n            }\r\n            this.identicalCache[comboId] = true;\r\n            return true;\r\n        };\r\n        TypeChecker.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {\r\n            if(sg1 == sg2) {\r\n                return true;\r\n            }\r\n            if(!sg1 || !sg2) {\r\n                return false;\r\n            }\r\n            if(sg1.signatures.length != sg2.signatures.length) {\r\n                return false;\r\n            }\r\n            var sig1 = null;\r\n            var sig2 = null;\r\n            var sigsMatch = false;\r\n            for(var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {\r\n                sig1 = sg1.signatures[iSig1];\r\n                for(var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {\r\n                    sig2 = sg2.signatures[iSig2];\r\n                    if(this.signaturesAreIdentical(sig1, sig2)) {\r\n                        sigsMatch = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if(sigsMatch) {\r\n                    sigsMatch = false;\r\n                    continue;\r\n                }\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        TypeChecker.prototype.signaturesAreIdentical = function (s1, s2) {\r\n            if(s1.hasVariableArgList != s2.hasVariableArgList) {\r\n                return false;\r\n            }\r\n            if(s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {\r\n                return false;\r\n            }\r\n            if(s1.parameters.length != s2.parameters.length) {\r\n                return false;\r\n            }\r\n            if(!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {\r\n                return false;\r\n            }\r\n            for(var iParam = 0; iParam < s1.parameters.length; iParam++) {\r\n                if(!this.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        TypeChecker.prototype.sourceIsSubtypeOfTarget = function (source, target, comparisonInfo) {\r\n            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo);\r\n        };\r\n        TypeChecker.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, comparisonInfo) {\r\n            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo);\r\n        };\r\n        TypeChecker.prototype.signatureIsSubtypeOfTarget = function (s1, s2, comparisonInfo) {\r\n            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo);\r\n        };\r\n        TypeChecker.prototype.sourceIsAssignableToTarget = function (source, target, comparisonInfo) {\r\n            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo);\r\n        };\r\n        TypeChecker.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, comparisonInfo) {\r\n            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo);\r\n        };\r\n        TypeChecker.prototype.signatureIsAssignableToTarget = function (s1, s2, comparisonInfo) {\r\n            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo);\r\n        };\r\n        TypeChecker.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, comparisonInfo) {\r\n            if(source == target) {\r\n                return true;\r\n            }\r\n            if(!(source && target)) {\r\n                return true;\r\n            }\r\n            var comboId = (source.typeID << 16) | target.typeID;\r\n            if(comparisonCache[comboId]) {\r\n                return true;\r\n            }\r\n            if(assignableTo) {\r\n                if(source == this.anyType || target == this.anyType) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                if(target == this.anyType) {\r\n                    return true;\r\n                }\r\n            }\r\n            if(source == this.undefinedType) {\r\n                return true;\r\n            }\r\n            if((source == this.nullType) && (target != this.undefinedType && target != this.voidType)) {\r\n                return true;\r\n            }\r\n            if(target == this.numberType && (source.typeFlags & TypeScript.TypeFlags.IsEnum)) {\r\n                return true;\r\n            }\r\n            if(source == this.numberType && (target.typeFlags & TypeScript.TypeFlags.IsEnum)) {\r\n                return true;\r\n            }\r\n            if((source.typeFlags & TypeScript.TypeFlags.IsEnum) || (target.typeFlags & TypeScript.TypeFlags.IsEnum)) {\r\n                return false;\r\n            }\r\n            if(source.isArray() || target.isArray()) {\r\n                if(!(source.isArray() && target.isArray())) {\r\n                    return false;\r\n                }\r\n                comparisonCache[comboId] = false;\r\n                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);\r\n                if(ret) {\r\n                    comparisonCache[comboId] = true;\r\n                } else {\r\n                    comparisonCache[comboId] = undefined;\r\n                }\r\n                return ret;\r\n            }\r\n            if(source.primitiveTypeClass != target.primitiveTypeClass) {\r\n                if(target.primitiveTypeClass == TypeScript.Primitive.None) {\r\n                    if(source == this.numberType && this.typeFlow.numberInterfaceType) {\r\n                        source = this.typeFlow.numberInterfaceType;\r\n                    } else {\r\n                        if(source == this.stringType && this.typeFlow.stringInterfaceType) {\r\n                            source = this.typeFlow.stringInterfaceType;\r\n                        } else {\r\n                            if(source == this.booleanType && this.typeFlow.booleanInterfaceType) {\r\n                                source = this.typeFlow.booleanInterfaceType;\r\n                            } else {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n            comparisonCache[comboId] = false;\r\n            if(source.hasBase(target)) {\r\n                comparisonCache[comboId] = true;\r\n                return true;\r\n            }\r\n            if(this.typeFlow.objectInterfaceType && target == this.typeFlow.objectInterfaceType) {\r\n                return true;\r\n            }\r\n            if(this.typeFlow.functionInterfaceType && (source.call || source.construct) && target == this.typeFlow.functionInterfaceType) {\r\n                return true;\r\n            }\r\n            if(target.isClass() || target.isClassInstance()) {\r\n                comparisonCache[comboId] = undefined;\r\n                return false;\r\n            }\r\n            if(target.memberScope && source.memberScope) {\r\n                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);\r\n                var mProp = null;\r\n                var nProp = null;\r\n                var mPropType = null;\r\n                var nPropType = null;\r\n                var inferenceSymbol = null;\r\n                for(var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {\r\n                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);\r\n                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);\r\n                    if(mProp.kind() == TypeScript.SymbolKind.Variable && (mProp).variable.typeLink.ast && (mProp).variable.typeLink.ast.nodeType == TypeScript.NodeType.Name && ((mProp).variable.typeLink.ast).text == \"IArguments\") {\r\n                        continue;\r\n                    }\r\n                    if(mProp.isInferenceSymbol()) {\r\n                        inferenceSymbol = mProp;\r\n                        if(inferenceSymbol.typeCheckStatus == TypeScript.TypeCheckStatus.NotStarted) {\r\n                            this.typeFlow.typeCheck(mProp.declAST);\r\n                        }\r\n                    }\r\n                    mPropType = mProp.getType();\r\n                    if(!nProp) {\r\n                        if(this.typeFlow.objectInterfaceType) {\r\n                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\r\n                        }\r\n                        if(!nProp) {\r\n                            if(this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {\r\n                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);\r\n                            }\r\n                            if(!nProp) {\r\n                                if(!(mProp.flags & TypeScript.SymbolFlags.Optional)) {\r\n                                    comparisonCache[comboId] = undefined;\r\n                                    if(comparisonInfo) {\r\n                                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.RequiredPropertyIsMissing;\r\n                                        comparisonInfo.addMessageToFront(\"Type '\" + source.getTypeName() + \"' is missing property '\" + mPropKeys[iMProp] + \"' from type '\" + target.getTypeName() + \"'\");\r\n                                    }\r\n                                    return false;\r\n                                } else {\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if(nProp.isInferenceSymbol()) {\r\n                        inferenceSymbol = nProp;\r\n                        if(inferenceSymbol.typeCheckStatus == TypeScript.TypeCheckStatus.NotStarted) {\r\n                            this.typeFlow.typeCheck(nProp.declAST);\r\n                        }\r\n                    }\r\n                    nPropType = nProp.getType();\r\n                    if(mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {\r\n                        continue;\r\n                    }\r\n                    if(!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {\r\n                        comparisonCache[comboId] = undefined;\r\n                        if(comparisonInfo) {\r\n                            comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatiblePropertyTypes;\r\n                            comparisonInfo.addMessageToFront(\"Types of property '\" + mProp.name + \"' of types '\" + source.getTypeName() + \"' and '\" + target.getTypeName() + \"' are incompatible\");\r\n                        }\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            if(source.call || target.call) {\r\n                if(!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {\r\n                    if(comparisonInfo) {\r\n                        if(source.call && target.call) {\r\n                            comparisonInfo.addMessageToFront(\"Call signatures of types '\" + source.getTypeName() + \"' and '\" + target.getTypeName() + \"' are incompatible\");\r\n                        } else {\r\n                            var hasSig = target.call ? target.getTypeName() : source.getTypeName();\r\n                            var lacksSig = !target.call ? target.getTypeName() : source.getTypeName();\r\n                            comparisonInfo.setMessage(\"Type '\" + hasSig + \"' requires a call signature, but Type '\" + lacksSig + \"' lacks one\");\r\n                        }\r\n                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;\r\n                    }\r\n                    comparisonCache[comboId] = undefined;\r\n                    return false;\r\n                }\r\n            }\r\n            if(source.construct || target.construct) {\r\n                if(!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {\r\n                    if(comparisonInfo) {\r\n                        if(source.construct && target.construct) {\r\n                            comparisonInfo.addMessageToFront(\"Construct signatures of types '\" + source.getTypeName() + \"' and '\" + target.getTypeName() + \"' are incompatible\");\r\n                        } else {\r\n                            var hasSig = target.construct ? target.getTypeName() : source.getTypeName();\r\n                            var lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();\r\n                            comparisonInfo.setMessage(\"Type '\" + hasSig + \"' requires a construct signature, but Type '\" + lacksSig + \"' lacks one\");\r\n                        }\r\n                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;\r\n                    }\r\n                    comparisonCache[comboId] = undefined;\r\n                    return false;\r\n                }\r\n            }\r\n            if(target.index) {\r\n                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;\r\n                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;\r\n                if(!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {\r\n                    if(comparisonInfo) {\r\n                        comparisonInfo.addMessageToFront(\"Index signatures of types '\" + source.getTypeName() + \"' and '\" + target.getTypeName() + \"' are incompatible\");\r\n                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;\r\n                    }\r\n                    comparisonCache[comboId] = undefined;\r\n                    return false;\r\n                }\r\n            }\r\n            comparisonCache[comboId] = true;\r\n            return true;\r\n        };\r\n        TypeChecker.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, comparisonInfo) {\r\n            if(sourceSG == targetSG) {\r\n                return true;\r\n            }\r\n            if(!(sourceSG && targetSG)) {\r\n                return false;\r\n            }\r\n            var mSig = null;\r\n            var nSig = null;\r\n            var foundMatch = false;\r\n            for(var iMSig = 0; iMSig < targetSG.signatures.length; iMSig++) {\r\n                mSig = targetSG.signatures[iMSig];\r\n                for(var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {\r\n                    nSig = sourceSG.signatures[iNSig];\r\n                    if(this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {\r\n                        foundMatch = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if(foundMatch) {\r\n                    foundMatch = false;\r\n                    continue;\r\n                }\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        TypeChecker.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, comparisonInfo) {\r\n            if(!sourceSig.parameters || !targetSig.parameters) {\r\n                return false;\r\n            }\r\n            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;\r\n            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;\r\n            if(sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {\r\n                if(comparisonInfo) {\r\n                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.SourceSignatureHasTooManyParameters;\r\n                    comparisonInfo.addMessageToFront(\"Call signature expects \" + targetVarArgCount + \" or fewer parameters\");\r\n                }\r\n                return false;\r\n            }\r\n            var sourceReturnType = sourceSig.returnType.type;\r\n            var targetReturnType = targetSig.returnType.type;\r\n            if(targetReturnType != this.voidType) {\r\n                if(!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {\r\n                    if(comparisonInfo) {\r\n                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleReturnTypes;\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;\r\n            var sourceParamType = null;\r\n            var targetParamType = null;\r\n            var sourceParamName = \"\";\r\n            var targetParamName = \"\";\r\n            for(var iSource = 0, iTarget = 0; iSource < len; iSource++ , iTarget++) {\r\n                if(!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {\r\n                    sourceParamType = (sourceSig.parameters[iSource]).parameter.typeLink.type;\r\n                    sourceParamName = (sourceSig.parameters[iSource]).parameter.symbol.name;\r\n                } else {\r\n                    if(iSource == sourceVarArgCount) {\r\n                        sourceParamType = (sourceSig.parameters[iSource]).parameter.typeLink.type;\r\n                        if(sourceParamType.elementType) {\r\n                            sourceParamType = sourceParamType.elementType;\r\n                        }\r\n                        sourceParamName = (sourceSig.parameters[iSource]).parameter.symbol.name;\r\n                    }\r\n                }\r\n                if(iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {\r\n                    targetParamType = (targetSig.parameters[iTarget]).parameter.typeLink.type;\r\n                    targetParamName = (targetSig.parameters[iTarget]).parameter.symbol.name;\r\n                } else {\r\n                    if(targetSig.hasVariableArgList && iTarget == targetVarArgCount) {\r\n                        targetParamType = (targetSig.parameters[iTarget]).parameter.typeLink.type;\r\n                        if(targetParamType.elementType) {\r\n                            targetParamType = targetParamType.elementType;\r\n                        }\r\n                        targetParamName = (targetSig.parameters[iTarget]).parameter.symbol.name;\r\n                    }\r\n                }\r\n                if(!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {\r\n                    if(comparisonInfo) {\r\n                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleParameterTypes;\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        return TypeChecker;\r\n    })();\r\n    TypeScript.TypeChecker = TypeChecker;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var Continuation = (function () {\r\n        function Continuation(normalBlock) {\r\n            this.normalBlock = normalBlock;\r\n            this.exceptionBlock = -1;\r\n        }\r\n        return Continuation;\r\n    })();\r\n    TypeScript.Continuation = Continuation;    \r\n    function getBaseTypeLinks(bases, baseTypeLinks) {\r\n        if(bases) {\r\n            var len = bases.members.length;\r\n            if(baseTypeLinks == null) {\r\n                baseTypeLinks = new Array();\r\n            }\r\n            for(var i = 0; i < len; i++) {\r\n                var baseExpr = bases.members[i];\r\n                var name = baseExpr;\r\n                if(name.nodeType == TypeScript.NodeType.Call) {\r\n                    name = (name).target;\r\n                }\r\n                var typeLink = new TypeScript.TypeLink();\r\n                typeLink.ast = name;\r\n                baseTypeLinks[baseTypeLinks.length] = typeLink;\r\n            }\r\n        }\r\n        return baseTypeLinks;\r\n    }\r\n    function getBases(type, typeDecl) {\r\n        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);\r\n        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);\r\n    }\r\n    function addPrototypeField(classType, ast, context) {\r\n        var field = new TypeScript.ValueLocation();\r\n        field.typeLink = new TypeScript.TypeLink();\r\n        field.typeLink.ast = ast;\r\n        field.typeLink.type = classType.instanceType;\r\n        var fieldSymbol = new TypeScript.FieldSymbol(\"prototype\", ast.minChar, context.checker.locationInfo.unitIndex, true, field);\r\n        fieldSymbol.flags |= (TypeScript.SymbolFlags.Property | TypeScript.SymbolFlags.BuiltIn);\r\n        field.symbol = fieldSymbol;\r\n        fieldSymbol.declAST = ast;\r\n        classType.members.addPublicMember(\"prototype\", fieldSymbol);\r\n    }\r\n    function createNewConstructGroupForType(type) {\r\n        var signature = new TypeScript.Signature();\r\n        signature.returnType = new TypeScript.TypeLink();\r\n        signature.returnType.type = type.instanceType;\r\n        signature.parameters = [];\r\n        type.construct = new TypeScript.SignatureGroup();\r\n        type.construct.addSignature(signature);\r\n    }\r\n    TypeScript.createNewConstructGroupForType = createNewConstructGroupForType;\r\n    function cloneParentConstructGroupForChildType(child, parent) {\r\n        child.construct = new TypeScript.SignatureGroup();\r\n        var sig = null;\r\n        if(!parent.construct) {\r\n            createNewConstructGroupForType(parent);\r\n        }\r\n        for(var i = 0; i < parent.construct.signatures.length; i++) {\r\n            sig = new TypeScript.Signature();\r\n            sig.parameters = parent.construct.signatures[i].parameters;\r\n            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;\r\n            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;\r\n            sig.declAST = parent.construct.signatures[i].declAST;\r\n            sig.returnType = new TypeScript.TypeLink();\r\n            sig.returnType.type = child.instanceType;\r\n            child.construct.addSignature(sig);\r\n        }\r\n    }\r\n    TypeScript.cloneParentConstructGroupForChildType = cloneParentConstructGroupForChildType;\r\n    TypeScript.globalId = \"__GLO\";\r\n    function findTypeSymbolInScopeChain(name, scopeChain) {\r\n        var symbol = scopeChain.scope.find(name, false, true);\r\n        if(symbol == null && scopeChain.previous) {\r\n            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);\r\n        }\r\n        return symbol;\r\n    }\r\n    function findSymbolFromAlias(alias, context) {\r\n        var symbol = null;\r\n        switch(alias.nodeType) {\r\n            case TypeScript.NodeType.Name: {\r\n                var name = (alias).text;\r\n                var isDynamic = TypeScript.isQuoted(name);\r\n                var findSym = function (id) {\r\n                    if(context.members) {\r\n                        return context.members.lookup(name);\r\n                    } else {\r\n                        return findTypeSymbolInScopeChain(name, context.topLevelScope);\r\n                    }\r\n                };\r\n                if(isDynamic) {\r\n                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.filename, findSym);\r\n                } else {\r\n                    symbol = findSym(name);\r\n                }\r\n                break;\r\n\r\n            }\r\n            case TypeScript.NodeType.Dot: {\r\n                var dottedExpr = alias;\r\n                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);\r\n                if(op1Sym && op1Sym.getType()) {\r\n                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);\r\n                }\r\n                break;\r\n\r\n            }\r\n            default: {\r\n                break;\r\n\r\n            }\r\n        }\r\n        if(symbol) {\r\n            var symType = symbol.getType();\r\n            if(symType) {\r\n                var members = symType.members;\r\n                if(members) {\r\n                    context.members = members.publicMembers;\r\n                }\r\n            } else {\r\n                context.tcContext.checker.errorReporter.simpleError(alias, \"Potentially circular alias reference - could not obtain type of alias\");\r\n            }\r\n        }\r\n        return symbol;\r\n    }\r\n    function preCollectImportTypes(ast, parent, context) {\r\n        var scopeChain = context.scopeChain;\r\n        var typeSymbol = null;\r\n        var modType = null;\r\n        var importDecl = ast;\r\n        var isExported = TypeScript.hasFlag(importDecl.varFlags, TypeScript.VarFlags.Exported);\r\n        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, {\r\n            topLevelScope: scopeChain,\r\n            members: null,\r\n            tcContext: context\r\n        });\r\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\r\n        if(aliasedModSymbol) {\r\n            var aliasedModType = aliasedModSymbol.getType();\r\n            if(aliasedModType) {\r\n                modType = aliasedModType;\r\n            }\r\n        }\r\n        typeSymbol = new TypeScript.TypeSymbol(importDecl.id.text, importDecl.minChar, context.checker.locationInfo.unitIndex, modType);\r\n        typeSymbol.aliasLink = importDecl;\r\n        if(context.scopeChain.moduleDecl) {\r\n            typeSymbol.declModule = context.scopeChain.moduleDecl;\r\n        }\r\n        typeSymbol.declAST = importDecl;\r\n        importDecl.id.sym = typeSymbol;\r\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, false);\r\n        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, false);\r\n        return true;\r\n    }\r\n    TypeScript.preCollectImportTypes = preCollectImportTypes;\r\n    function preCollectModuleTypes(ast, parent, context) {\r\n        var scopeChain = context.scopeChain;\r\n        var moduleDecl = ast;\r\n        var isAmbient = TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.Ambient);\r\n        var isEnum = TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.IsEnum);\r\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\r\n        var isExported = TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.Exported);\r\n        var modName = (moduleDecl.name).text;\r\n        var isDynamic = TypeScript.isQuoted(modName);\r\n        var symbol = scopeChain.scope.findLocal(modName, false, false);\r\n        var typeSymbol = null;\r\n        var modType = null;\r\n        if((symbol == null) || (symbol.kind() != TypeScript.SymbolKind.Type)) {\r\n            if(modType == null) {\r\n                var enclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                var ambientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                modType = new TypeScript.ModuleType(enclosedTypes, ambientEnclosedTypes);\r\n                if(isEnum) {\r\n                    modType.typeFlags |= TypeScript.TypeFlags.IsEnum;\r\n                }\r\n                modType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                modType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                modType.setHasImplementation();\r\n            }\r\n            typeSymbol = new TypeScript.TypeSymbol(modName, moduleDecl.minChar, context.checker.locationInfo.unitIndex, modType);\r\n            if(context.scopeChain.moduleDecl) {\r\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\r\n            }\r\n            typeSymbol.declAST = moduleDecl;\r\n            typeSymbol.prettyName = moduleDecl.prettyName;\r\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\r\n            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\r\n            modType.symbol = typeSymbol;\r\n        } else {\r\n            if(symbol && symbol.declAST && symbol.declAST.nodeType != TypeScript.NodeType.Module) {\r\n                context.checker.errorReporter.simpleError(moduleDecl, \"Conflicting symbol name for module '\" + modName + \"'\");\r\n            }\r\n            typeSymbol = symbol;\r\n            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;\r\n            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new TypeScript.StringHashTable() : publicEnclosedTypes;\r\n            var enclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicEnclosedTypesTable, new TypeScript.StringHashTable()));\r\n            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;\r\n            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new TypeScript.StringHashTable() : publicEnclosedAmbientTypes;\r\n            var ambientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicAmbientEnclosedTypesTable, new TypeScript.StringHashTable()));\r\n            var publicMembers = typeSymbol.type.members.publicMembers;\r\n            var publicMembersTable = (publicMembers == null) ? new TypeScript.StringHashTable() : publicMembers;\r\n            var members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicMembersTable, new TypeScript.StringHashTable()));\r\n            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;\r\n            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new TypeScript.StringHashTable() : publicAmbientMembers;\r\n            var ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicAmbientMembersTable, new TypeScript.StringHashTable()));\r\n            modType = new TypeScript.ModuleType(enclosedTypes, ambientEnclosedTypes);\r\n            if(isEnum) {\r\n                modType.typeFlags |= TypeScript.TypeFlags.IsEnum;\r\n            }\r\n            modType.members = members;\r\n            modType.ambientMembers = ambientMembers;\r\n            modType.setHasImplementation();\r\n            modType.symbol = typeSymbol;\r\n            typeSymbol.addLocation(moduleDecl.minChar);\r\n            typeSymbol.expansions.push(modType);\r\n        }\r\n        if(context.scopeChain.moduleDecl) {\r\n            context.scopeChain.moduleDecl.recordNonInterface();\r\n        }\r\n        if(isExported) {\r\n            typeSymbol.flags |= TypeScript.SymbolFlags.Exported;\r\n        }\r\n        if((context.scopeChain.moduleDecl) || (context.scopeChain.container == context.checker.gloMod)) {\r\n            typeSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;\r\n        }\r\n        moduleDecl.mod = modType;\r\n        TypeScript.pushTypeCollectionScope(typeSymbol, modType.members, modType.ambientMembers, modType.enclosedTypes, modType.ambientEnclosedTypes, context, null, null, moduleDecl);\r\n        return true;\r\n    }\r\n    TypeScript.preCollectModuleTypes = preCollectModuleTypes;\r\n    function preCollectClassTypes(ast, parent, context) {\r\n        var scopeChain = context.scopeChain;\r\n        var classDecl = ast;\r\n        var classType;\r\n        var instanceType;\r\n        var typeSymbol = null;\r\n        var className = (classDecl.name).text;\r\n        var alreadyInScope = false;\r\n        var isAmbient = TypeScript.hasFlag(classDecl.varFlags, TypeScript.VarFlags.Ambient);\r\n        var isExported = TypeScript.hasFlag(classDecl.varFlags, TypeScript.VarFlags.Exported);\r\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\r\n        var containerMod = scopeChain.container;\r\n        var foundValSymbol = false;\r\n        typeSymbol = scopeChain.scope.findLocal(className, false, true);\r\n        if(!typeSymbol) {\r\n            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);\r\n            if(valTypeSymbol && valTypeSymbol.isType() && valTypeSymbol.declAST && valTypeSymbol.declAST.nodeType == TypeScript.NodeType.FuncDecl && (valTypeSymbol.declAST).isSignature()) {\r\n                typeSymbol = valTypeSymbol;\r\n                foundValSymbol = true;\r\n                if(isExported) {\r\n                    typeSymbol.flags |= TypeScript.SymbolFlags.Exported;\r\n                }\r\n                if(isAmbient) {\r\n                    typeSymbol.flags |= TypeScript.SymbolFlags.Ambient;\r\n                }\r\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\r\n            }\r\n        }\r\n        if(typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl) && !(typeSymbol.declAST).isOverload) {\r\n            typeSymbol = null;\r\n        }\r\n        if(typeSymbol == null) {\r\n            var valueSymbol = scopeChain.scope.findLocal(className, false, false);\r\n            classType = new TypeScript.Type();\r\n            classType.setHasImplementation();\r\n            instanceType = new TypeScript.Type();\r\n            instanceType.setHasImplementation();\r\n            classType.instanceType = instanceType;\r\n            classType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            classType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            addPrototypeField(classType, classDecl, context);\r\n            instanceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            instanceType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            typeSymbol = new TypeScript.TypeSymbol(className, classDecl.minChar, context.checker.locationInfo.unitIndex, classType);\r\n            typeSymbol.declAST = classDecl;\r\n            typeSymbol.instanceType = instanceType;\r\n            classType.symbol = typeSymbol;\r\n            instanceType.symbol = typeSymbol;\r\n            if(context.scopeChain.moduleDecl) {\r\n                context.scopeChain.moduleDecl.recordNonInterface();\r\n                typeSymbol.declModule = context.scopeChain.moduleDecl;\r\n                typeSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;\r\n            }\r\n            if(isExported) {\r\n                typeSymbol.flags |= TypeScript.SymbolFlags.Exported;\r\n            }\r\n            if(isAmbient) {\r\n                typeSymbol.flags |= TypeScript.SymbolFlags.Ambient;\r\n            }\r\n            ast.type = classType;\r\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);\r\n            if(valueSymbol == null) {\r\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient);\r\n            }\r\n        } else {\r\n            classType = typeSymbol.type;\r\n            if(classType.instanceType == null) {\r\n                classType.instanceType = new TypeScript.Type();\r\n                classType.instanceType.setHasImplementation();\r\n                classType.instanceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                classType.instanceType.symbol = classType.symbol;\r\n                classType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                classType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            }\r\n            instanceType = classType.instanceType;\r\n            ast.type = classType;\r\n        }\r\n        if(!classDecl.constructorDecl) {\r\n            if(typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(typeSymbol.declAST).isOverload) {\r\n                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);\r\n            }\r\n            createNewConstructGroupForType(classDecl.type);\r\n        }\r\n        classType.typeFlags |= TypeScript.TypeFlags.IsClass;\r\n        instanceType.typeFlags |= TypeScript.TypeFlags.IsClass;\r\n        getBases(instanceType, classDecl);\r\n        TypeScript.pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null, context, instanceType, classType, null);\r\n        return true;\r\n    }\r\n    TypeScript.preCollectClassTypes = preCollectClassTypes;\r\n    function preCollectInterfaceTypes(ast, parent, context) {\r\n        var scopeChain = context.scopeChain;\r\n        var interfaceDecl = ast;\r\n        var interfaceSymbol = null;\r\n        var interfaceType = null;\r\n        var isExported = TypeScript.hasFlag(interfaceDecl.varFlags, TypeScript.VarFlags.Exported);\r\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\r\n        var alreadyInScope = true;\r\n        alreadyInScope = false;\r\n        var interfaceName = (interfaceDecl.name).text;\r\n        interfaceSymbol = scopeChain.scope.findLocal(interfaceName, false, true);\r\n        if(interfaceSymbol == null) {\r\n            interfaceType = new TypeScript.Type();\r\n            interfaceSymbol = new TypeScript.TypeSymbol(interfaceName, ast.minChar, context.checker.locationInfo.unitIndex, interfaceType);\r\n            interfaceType.symbol = interfaceSymbol;\r\n            interfaceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            interfaceType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            interfaceSymbol.declAST = interfaceDecl;\r\n            interfaceSymbol.declModule = context.scopeChain.moduleDecl;\r\n        } else {\r\n            alreadyInScope = true;\r\n            interfaceType = interfaceSymbol.type;\r\n        }\r\n        if(!interfaceType) {\r\n            interfaceType = context.checker.anyType;\r\n        }\r\n        ast.type = interfaceType;\r\n        getBases(interfaceType, interfaceDecl);\r\n        if(isExported) {\r\n            interfaceSymbol.flags |= TypeScript.SymbolFlags.Exported;\r\n        }\r\n        if(context.scopeChain.moduleDecl) {\r\n            interfaceSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;\r\n        }\r\n        if(!alreadyInScope) {\r\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false);\r\n        }\r\n        TypeScript.pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null, context, interfaceType, null, null);\r\n        return true;\r\n    }\r\n    TypeScript.preCollectInterfaceTypes = preCollectInterfaceTypes;\r\n    function preCollectArgDeclTypes(ast, parent, context) {\r\n        var scopeChain = context.scopeChain;\r\n        var argDecl = ast;\r\n        if(TypeScript.hasFlag(argDecl.varFlags, TypeScript.VarFlags.Public | TypeScript.VarFlags.Private)) {\r\n            var field = new TypeScript.ValueLocation();\r\n            var isPrivate = TypeScript.hasFlag(argDecl.varFlags, TypeScript.VarFlags.Private);\r\n            var fieldSymbol = new TypeScript.FieldSymbol(argDecl.id.text, argDecl.minChar, context.checker.locationInfo.unitIndex, !TypeScript.hasFlag(argDecl.varFlags, TypeScript.VarFlags.Readonly), field);\r\n            fieldSymbol.transferVarFlags(argDecl.varFlags);\r\n            field.symbol = fieldSymbol;\r\n            fieldSymbol.declAST = ast;\r\n            argDecl.parameterPropertySym = fieldSymbol;\r\n            context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);\r\n            field.typeLink = TypeScript.getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);\r\n            argDecl.sym = fieldSymbol;\r\n        }\r\n        return false;\r\n    }\r\n    TypeScript.preCollectArgDeclTypes = preCollectArgDeclTypes;\r\n    function preCollectVarDeclTypes(ast, parent, context) {\r\n        var scopeChain = context.scopeChain;\r\n        var varDecl = ast;\r\n        var isAmbient = TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Ambient);\r\n        var isExported = TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Exported);\r\n        var isGlobal = context.scopeChain.container == context.checker.gloMod;\r\n        var isProperty = TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Property);\r\n        var isStatic = TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Static);\r\n        var isPrivate = TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Private);\r\n        var isOptional = TypeScript.hasFlag(varDecl.id.flags, TypeScript.ASTFlags.OptionalName);\r\n        if(context.scopeChain.moduleDecl) {\r\n            context.scopeChain.moduleDecl.recordNonInterface();\r\n        }\r\n        if(isProperty || isExported || (context.scopeChain.container == context.checker.gloMod) || context.scopeChain.moduleDecl) {\r\n            if(isAmbient) {\r\n                var existingSym = scopeChain.scope.findLocal(varDecl.id.text, false, false);\r\n                if(existingSym) {\r\n                    varDecl.sym = existingSym;\r\n                    return false;\r\n                }\r\n            }\r\n            if(varDecl.id == null) {\r\n                context.checker.errorReporter.simpleError(varDecl, \"Expected variable identifier at this location\");\r\n                return false;\r\n            }\r\n            var field = new TypeScript.ValueLocation();\r\n            var fieldSymbol = new TypeScript.FieldSymbol(varDecl.id.text, varDecl.minChar, context.checker.locationInfo.unitIndex, (varDecl.varFlags & TypeScript.VarFlags.Readonly) == TypeScript.VarFlags.None, field);\r\n            fieldSymbol.transferVarFlags(varDecl.varFlags);\r\n            if(isOptional) {\r\n                fieldSymbol.flags |= TypeScript.SymbolFlags.Optional;\r\n            }\r\n            field.symbol = fieldSymbol;\r\n            fieldSymbol.declAST = ast;\r\n            if((context.scopeChain.moduleDecl) || (context.scopeChain.container == context.checker.gloMod)) {\r\n                fieldSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;\r\n                fieldSymbol.declModule = context.scopeChain.moduleDecl;\r\n            }\r\n            if(TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Property) && isStatic && context.scopeChain.classType) {\r\n                if(!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {\r\n                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);\r\n                }\r\n                fieldSymbol.container = context.scopeChain.classType.symbol;\r\n            } else {\r\n                context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate && (isProperty || isExported || isGlobal || isStatic), false, isAmbient);\r\n            }\r\n            if(TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Exported)) {\r\n                fieldSymbol.flags |= TypeScript.SymbolFlags.Exported;\r\n            }\r\n            field.typeLink = TypeScript.getTypeLink(varDecl.typeExpr, context.checker, varDecl.init == null);\r\n            varDecl.sym = fieldSymbol;\r\n        }\r\n        return false;\r\n    }\r\n    TypeScript.preCollectVarDeclTypes = preCollectVarDeclTypes;\r\n    function preCollectFuncDeclTypes(ast, parent, context) {\r\n        var scopeChain = context.scopeChain;\r\n        if(context.scopeChain.moduleDecl) {\r\n            context.scopeChain.moduleDecl.recordNonInterface();\r\n        }\r\n        var funcDecl = ast;\r\n        var fgSym = null;\r\n        var nameText = funcDecl.getNameText();\r\n        var isExported = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Exported | TypeScript.FncFlags.ClassPropertyMethodExported);\r\n        var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Static);\r\n        var isPrivate = TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Private);\r\n        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;\r\n        var containerSym = (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);\r\n        var containerScope = context.scopeChain.scope;\r\n        var isGlobal = containerSym == context.checker.gloMod;\r\n        var isOptional = funcDecl.name && TypeScript.hasFlag(funcDecl.name.flags, TypeScript.ASTFlags.OptionalName);\r\n        var go = false;\r\n        var foundSymbol = false;\r\n        if(isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) {\r\n            containerSym = containerSym.container;\r\n            containerScope = scopeChain.previous.scope;\r\n        }\r\n        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;\r\n        if(!funcDecl.isConstructor && containerSym && containerSym.declAST && containerSym.declAST.nodeType == TypeScript.NodeType.FuncDecl && (containerSym.declAST).isConstructor && !funcDecl.isMethod()) {\r\n            return go;\r\n        }\r\n        if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Signature)) {\r\n            var instType = context.scopeChain.thisType;\r\n            if(nameText && nameText != \"__missing\") {\r\n                if(isStatic) {\r\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\r\n                } else {\r\n                    fgSym = containerScope.findLocal(nameText, false, false);\r\n                    if(fgSym == null) {\r\n                        fgSym = containerScope.findLocal(nameText, false, true);\r\n                    }\r\n                }\r\n                if(fgSym) {\r\n                    foundSymbol = true;\r\n                    if(!funcDecl.isSignature() && (TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Ambient) != TypeScript.hasFlag(fgSym.flags, TypeScript.SymbolFlags.Ambient))) {\r\n                        fgSym = null;\r\n                    }\r\n                }\r\n            }\r\n            if(fgSym == null) {\r\n                if(!(funcDecl.isSpecialFn())) {\r\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;\r\n                } else {\r\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;\r\n                }\r\n                if(fgSym.declAST == null || !funcDecl.isSpecialFn()) {\r\n                    fgSym.declAST = ast;\r\n                }\r\n            } else {\r\n                if((fgSym.kind() == TypeScript.SymbolKind.Type)) {\r\n                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;\r\n                } else {\r\n                    context.checker.errorReporter.simpleError(funcDecl, \"Function or method '\" + funcDecl.name.text + \"' already declared as a property\");\r\n                }\r\n            }\r\n            if(funcDecl.isSpecialFn() && !isStatic) {\r\n                funcDecl.type = instType ? instType : fgSym.type;\r\n            } else {\r\n                funcDecl.type = fgSym.type;\r\n            }\r\n        } else {\r\n            if(nameText) {\r\n                if(isStatic) {\r\n                    fgSym = containerSym.type.members.allMembers.lookup(nameText);\r\n                } else {\r\n                    if(funcDecl.isConstructor && context.scopeChain.previous) {\r\n                        fgSym = context.scopeChain.previous.scope.findLocal(nameText, false, false);\r\n                    }\r\n                    if(fgSym == null) {\r\n                        fgSym = containerScope.findLocal(nameText, false, false);\r\n                    }\r\n                }\r\n                if(fgSym) {\r\n                    foundSymbol = true;\r\n                    if(!isConstructor && fgSym.declAST.nodeType == TypeScript.NodeType.FuncDecl && !(fgSym.declAST).isAccessor() && !(fgSym.declAST).isSignature()) {\r\n                        fgSym = null;\r\n                        foundSymbol = false;\r\n                    }\r\n                }\r\n            }\r\n            if(fgSym && !fgSym.isAccessor() && fgSym.type && fgSym.type.construct && fgSym.type.construct.signatures != [] && (fgSym.type.construct.signatures[0].declAST == null || !TypeScript.hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, TypeScript.FncFlags.Ambient)) && !funcDecl.isConstructor) {\r\n                context.checker.errorReporter.simpleError(funcDecl, \"Functions may not have class overloads\");\r\n            }\r\n            if(fgSym && !(fgSym.kind() == TypeScript.SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {\r\n                context.checker.errorReporter.simpleError(funcDecl, \"Function or method '\" + funcDecl.name.text + \"' already declared as a property\");\r\n                fgSym.type = context.checker.anyType;\r\n            }\r\n            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);\r\n            if(((!fgSym || fgSym.declAST.nodeType != TypeScript.NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {\r\n                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);\r\n            }\r\n            funcDecl.type.symbol.declAST = ast;\r\n            if(funcDecl.isConstructor) {\r\n                go = true;\r\n            }\r\n            ; ;\r\n        }\r\n        if(isExported) {\r\n            if(funcDecl.type.call) {\r\n                funcDecl.type.symbol.flags |= TypeScript.SymbolFlags.Exported;\r\n            }\r\n            if(fgSym && !fgSym.isAccessor() && fgSym.type.call) {\r\n                fgSym.flags |= TypeScript.SymbolFlags.Exported;\r\n            }\r\n        }\r\n        if(context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {\r\n            funcDecl.type.symbol.flags |= TypeScript.SymbolFlags.ModuleMember;\r\n            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;\r\n        }\r\n        if(fgSym && isOptional) {\r\n            fgSym.flags |= TypeScript.SymbolFlags.Optional;\r\n        }\r\n        return go;\r\n    }\r\n    TypeScript.preCollectFuncDeclTypes = preCollectFuncDeclTypes;\r\n    function preCollectTypes(ast, parent, walker) {\r\n        var context = walker.state;\r\n        var go = false;\r\n        var scopeChain = context.scopeChain;\r\n        if(ast.nodeType == TypeScript.NodeType.Script) {\r\n            var script = ast;\r\n            context.script = script;\r\n            go = true;\r\n        } else {\r\n            if(ast.nodeType == TypeScript.NodeType.List) {\r\n                go = true;\r\n            } else {\r\n                if(ast.nodeType == TypeScript.NodeType.Import) {\r\n                    go = preCollectImportTypes(ast, parent, context);\r\n                } else {\r\n                    if(ast.nodeType == TypeScript.NodeType.With) {\r\n                        go = false;\r\n                    } else {\r\n                        if(ast.nodeType == TypeScript.NodeType.Module) {\r\n                            go = preCollectModuleTypes(ast, parent, context);\r\n                        } else {\r\n                            if(ast.nodeType == TypeScript.NodeType.Class) {\r\n                                go = preCollectClassTypes(ast, parent, context);\r\n                            } else {\r\n                                if(ast.nodeType == TypeScript.NodeType.Block) {\r\n                                    go = true;\r\n                                } else {\r\n                                    if(ast.nodeType == TypeScript.NodeType.Interface) {\r\n                                        go = preCollectInterfaceTypes(ast, parent, context);\r\n                                    } else {\r\n                                        if(ast.nodeType == TypeScript.NodeType.ArgDecl) {\r\n                                            go = preCollectArgDeclTypes(ast, parent, context);\r\n                                        } else {\r\n                                            if(ast.nodeType == TypeScript.NodeType.VarDecl) {\r\n                                                go = preCollectVarDeclTypes(ast, parent, context);\r\n                                            } else {\r\n                                                if(ast.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                                    go = preCollectFuncDeclTypes(ast, parent, context);\r\n                                                } else {\r\n                                                    if(ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {\r\n                                                        context.scopeChain.moduleDecl.recordNonInterface();\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        walker.options.goChildren = go;\r\n        return ast;\r\n    }\r\n    TypeScript.preCollectTypes = preCollectTypes;\r\n    function postCollectTypes(ast, parent, walker) {\r\n        var context = walker.state;\r\n        if(ast.nodeType == TypeScript.NodeType.Module) {\r\n            TypeScript.popTypeCollectionScope(context);\r\n        } else {\r\n            if(ast.nodeType == TypeScript.NodeType.Class) {\r\n                TypeScript.popTypeCollectionScope(context);\r\n            } else {\r\n                if(ast.nodeType == TypeScript.NodeType.Interface) {\r\n                    TypeScript.popTypeCollectionScope(context);\r\n                }\r\n            }\r\n        }\r\n        return ast;\r\n    }\r\n    TypeScript.postCollectTypes = postCollectTypes;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var ScopeChain = (function () {\r\n        function ScopeChain(container, previous, scope) {\r\n            this.container = container;\r\n            this.previous = previous;\r\n            this.scope = scope;\r\n        }\r\n        return ScopeChain;\r\n    })();\r\n    TypeScript.ScopeChain = ScopeChain;    \r\n    var BBUseDefInfo = (function () {\r\n        function BBUseDefInfo(bb) {\r\n            this.bb = bb;\r\n            this.defsBySymbol = new Array();\r\n            this.useIndexBySymbol = new Array();\r\n        }\r\n        BBUseDefInfo.prototype.updateTop = function () {\r\n            var temp = new BitVector(this.top.bitCount);\r\n            for(var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {\r\n                var succ = this.bb.successors[i];\r\n                if(succ.useDef) {\r\n                    temp.union(succ.useDef.top);\r\n                }\r\n            }\r\n            temp.difference(this.kill);\r\n            temp.union(this.gen);\r\n            var changed = temp.notEq(this.top);\r\n            this.top = temp;\r\n            return changed;\r\n        };\r\n        BBUseDefInfo.prototype.initialize = function (useDefContext) {\r\n            var _this = this;\r\n            var defSym = function (sym, context) {\r\n                if(context.isLocalSym(sym)) {\r\n                    var index = context.getSymbolIndex(sym);\r\n                    _this.useIndexBySymbol[index] = new Array();\r\n                    _this.defsBySymbol[index] = true;\r\n                }\r\n            };\r\n            var useSym = function (sym, context, ast) {\r\n                if(context.isLocalSym(sym)) {\r\n                    var symIndex = context.getSymbolIndex(sym);\r\n                    if(_this.useIndexBySymbol[symIndex] == undefined) {\r\n                        _this.useIndexBySymbol[symIndex] = new Array();\r\n                    }\r\n                    var symUses = _this.useIndexBySymbol[symIndex];\r\n                    var astIndex = context.getUseIndex(ast);\r\n                    context.addUse(symIndex, astIndex);\r\n                    symUses.push(astIndex);\r\n                }\r\n            };\r\n            function initUseDefPre(cur, parent, walker) {\r\n                var context = walker.state;\r\n                if(cur == null) {\r\n                    cur = null;\r\n                }\r\n                if(cur.nodeType == TypeScript.NodeType.VarDecl) {\r\n                    var varDecl = cur;\r\n                    if(varDecl.init || TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.AutoInit)) {\r\n                        defSym(varDecl.sym, context);\r\n                    }\r\n                } else {\r\n                    if(cur.nodeType == TypeScript.NodeType.Name) {\r\n                        if(parent) {\r\n                            if(parent.nodeType == TypeScript.NodeType.Asg) {\r\n                                var asg = parent;\r\n                                if(asg.operand1 == cur) {\r\n                                    return cur;\r\n                                }\r\n                            } else {\r\n                                if(parent.nodeType == TypeScript.NodeType.VarDecl) {\r\n                                    var parentDecl = parent;\r\n                                    if(parentDecl.id == cur) {\r\n                                        return cur;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        var id = cur;\r\n                        useSym(id.sym, context, cur);\r\n                    } else {\r\n                        if((cur.nodeType >= TypeScript.NodeType.Asg) && (cur.nodeType <= TypeScript.NodeType.LastAsg)) {\r\n                            var asg = cur;\r\n                            if(asg.operand1 && (asg.operand1.nodeType == TypeScript.NodeType.Name)) {\r\n                                var id = asg.operand1;\r\n                                defSym(id.sym, context);\r\n                            }\r\n                        } else {\r\n                            if(cur.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                walker.options.goChildren = false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return cur;\r\n            }\r\n            var options = new TypeScript.AstWalkOptions();\r\n            options.reverseSiblings = true;\r\n            TypeScript.getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);\r\n        };\r\n        BBUseDefInfo.prototype.initializeGen = function (useDefContext) {\r\n            var symbolLen = this.useIndexBySymbol.length;\r\n            var bitCount = useDefContext.uses.length;\r\n            this.gen = new BitVector(bitCount);\r\n            for(var s = 0; s < symbolLen; s++) {\r\n                var symUses = this.useIndexBySymbol[s];\r\n                if((symUses != undefined) && (symUses.length > 0)) {\r\n                    for(var u = 0, uLen = symUses.length; u < uLen; u++) {\r\n                        this.gen.set(symUses[u], true);\r\n                    }\r\n                }\r\n            }\r\n            this.top = this.gen;\r\n        };\r\n        BBUseDefInfo.prototype.initializeKill = function (useDefContext) {\r\n            this.kill = new BitVector(this.gen.bitCount);\r\n            for(var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {\r\n                if(this.defsBySymbol[s]) {\r\n                    var globalSymUses = useDefContext.useIndexBySymbol[s];\r\n                    if(globalSymUses) {\r\n                        for(var u = 0, useLen = globalSymUses.length; u < useLen; u++) {\r\n                            this.kill.set(globalSymUses[u], true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return BBUseDefInfo;\r\n    })();\r\n    TypeScript.BBUseDefInfo = BBUseDefInfo;    \r\n    var UseDefContext = (function () {\r\n        function UseDefContext() {\r\n            this.useIndexBySymbol = new Array();\r\n            this.uses = new Array();\r\n            this.symbols = new Array();\r\n            this.symbolMap = new TypeScript.StringHashTable();\r\n            this.symbolCount = 0;\r\n        }\r\n        UseDefContext.prototype.getSymbolIndex = function (sym) {\r\n            var name = sym.name;\r\n            var index = (this.symbolMap.lookup(name));\r\n            if(index == null) {\r\n                index = this.symbolCount++;\r\n                this.symbols[index] = sym;\r\n                this.symbolMap.add(name, index);\r\n            }\r\n            return index;\r\n        };\r\n        UseDefContext.prototype.addUse = function (symIndex, astIndex) {\r\n            var useBySym = this.useIndexBySymbol[symIndex];\r\n            if(useBySym == undefined) {\r\n                useBySym = new Array();\r\n                this.useIndexBySymbol[symIndex] = useBySym;\r\n            }\r\n            useBySym[useBySym.length] = astIndex;\r\n        };\r\n        UseDefContext.prototype.getUseIndex = function (ast) {\r\n            this.uses[this.uses.length] = ast;\r\n            return this.uses.length - 1;\r\n        };\r\n        UseDefContext.prototype.isLocalSym = function (sym) {\r\n            return (sym && (sym.container == this.func) && (sym.kind() == TypeScript.SymbolKind.Variable));\r\n        };\r\n        UseDefContext.prototype.killSymbol = function (sym, bbUses) {\r\n            var index = this.symbolMap.lookup(sym.name);\r\n            var usesOfSym = this.useIndexBySymbol[index];\r\n            for(var k = 0, len = usesOfSym.length; k < len; k++) {\r\n                bbUses.set(usesOfSym[k], true);\r\n            }\r\n        };\r\n        return UseDefContext;\r\n    })();\r\n    TypeScript.UseDefContext = UseDefContext;    \r\n    var BitVector = (function () {\r\n        function BitVector(bitCount) {\r\n            this.bitCount = bitCount;\r\n            this.firstBits = 0;\r\n            this.restOfBits = null;\r\n            if(this.bitCount > BitVector.packBits) {\r\n                this.restOfBits = new Array();\r\n                var len = Math.floor(this.bitCount / BitVector.packBits);\r\n                for(var i = 0; i < len; i++) {\r\n                    this.restOfBits[i] = 0;\r\n                }\r\n            }\r\n        }\r\n        BitVector.packBits = 30;\r\n        BitVector.prototype.set = function (bitIndex, value) {\r\n            if(bitIndex < BitVector.packBits) {\r\n                if(value) {\r\n                    this.firstBits |= (1 << bitIndex);\r\n                } else {\r\n                    this.firstBits &= (~(1 << bitIndex));\r\n                }\r\n            } else {\r\n                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;\r\n                var localIndex = bitIndex % BitVector.packBits;\r\n                if(value) {\r\n                    this.restOfBits[offset] |= (1 << localIndex);\r\n                } else {\r\n                    this.restOfBits[offset] &= (~(1 << localIndex));\r\n                }\r\n            }\r\n        };\r\n        BitVector.prototype.map = function (fn) {\r\n            var k;\r\n            for(k = 0; k < BitVector.packBits; k++) {\r\n                if(k == this.bitCount) {\r\n                    return;\r\n                }\r\n                if(((1 << k) & this.firstBits) != 0) {\r\n                    fn(k);\r\n                }\r\n            }\r\n            if(this.restOfBits) {\r\n                var len;\r\n                var cumu = BitVector.packBits;\r\n                for(k = 0 , len = this.restOfBits.length; k < len; k++) {\r\n                    var myBits = this.restOfBits[k];\r\n                    for(var j = 0; j < BitVector.packBits; j++) {\r\n                        if(((1 << j) & myBits) != 0) {\r\n                            fn(cumu);\r\n                        }\r\n                        cumu++;\r\n                        if(cumu == this.bitCount) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        BitVector.prototype.union = function (b) {\r\n            this.firstBits |= b.firstBits;\r\n            if(this.restOfBits) {\r\n                for(var k = 0, len = this.restOfBits.length; k < len; k++) {\r\n                    var myBits = this.restOfBits[k];\r\n                    var bBits = b.restOfBits[k];\r\n                    this.restOfBits[k] = myBits | bBits;\r\n                }\r\n            }\r\n        };\r\n        BitVector.prototype.intersection = function (b) {\r\n            this.firstBits &= b.firstBits;\r\n            if(this.restOfBits) {\r\n                for(var k = 0, len = this.restOfBits.length; k < len; k++) {\r\n                    var myBits = this.restOfBits[k];\r\n                    var bBits = b.restOfBits[k];\r\n                    this.restOfBits[k] = myBits & bBits;\r\n                }\r\n            }\r\n        };\r\n        BitVector.prototype.notEq = function (b) {\r\n            if(this.firstBits != b.firstBits) {\r\n                return true;\r\n            }\r\n            if(this.restOfBits) {\r\n                for(var k = 0, len = this.restOfBits.length; k < len; k++) {\r\n                    var myBits = this.restOfBits[k];\r\n                    var bBits = b.restOfBits[k];\r\n                    if(myBits != bBits) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        BitVector.prototype.difference = function (b) {\r\n            var oldFirstBits = this.firstBits;\r\n            this.firstBits &= (~b.firstBits);\r\n            if(this.restOfBits) {\r\n                for(var k = 0, len = this.restOfBits.length; k < len; k++) {\r\n                    var myBits = this.restOfBits[k];\r\n                    var bBits = b.restOfBits[k];\r\n                    this.restOfBits[k] &= (~bBits);\r\n                }\r\n            }\r\n        };\r\n        return BitVector;\r\n    })();\r\n    TypeScript.BitVector = BitVector;    \r\n    var BasicBlock = (function () {\r\n        function BasicBlock() {\r\n            this.predecessors = new Array();\r\n            this.index = -1;\r\n            this.markValue = 0;\r\n            this.successors = new Array();\r\n            this.useDef = null;\r\n            this.content = new TypeScript.ASTList();\r\n        }\r\n        BasicBlock.prototype.marked = function (markBase) {\r\n            return this.markValue > markBase;\r\n        };\r\n        BasicBlock.prototype.mark = function () {\r\n            this.markValue++;\r\n        };\r\n        BasicBlock.prototype.addSuccessor = function (successor) {\r\n            this.successors[this.successors.length] = successor;\r\n            successor.predecessors[successor.predecessors.length] = this;\r\n        };\r\n        return BasicBlock;\r\n    })();\r\n    TypeScript.BasicBlock = BasicBlock;    \r\n    var ControlFlowContext = (function () {\r\n        function ControlFlowContext(current, exit) {\r\n            this.current = current;\r\n            this.exit = exit;\r\n            this.entry = null;\r\n            this.unreachable = null;\r\n            this.noContinuation = false;\r\n            this.statementStack = new Array();\r\n            this.currentSwitch = new Array();\r\n            this.markBase = 0;\r\n            this.linearBBs = new Array();\r\n            this.entry = this.current;\r\n        }\r\n        ControlFlowContext.prototype.walk = function (ast, parent) {\r\n            return this.walker.walk(ast, parent);\r\n        };\r\n        ControlFlowContext.prototype.pushSwitch = function (bb) {\r\n            this.currentSwitch.push(bb);\r\n        };\r\n        ControlFlowContext.prototype.popSwitch = function () {\r\n            return this.currentSwitch.pop();\r\n        };\r\n        ControlFlowContext.prototype.reportUnreachable = function (er) {\r\n            if(this.unreachable && (this.unreachable.length > 0)) {\r\n                var len = this.unreachable.length;\r\n                for(var i = 0; i < len; i++) {\r\n                    var unreachableAST = this.unreachable[i];\r\n                    if(unreachableAST.nodeType != TypeScript.NodeType.EndCode) {\r\n                        er.simpleError(unreachableAST, \"unreachable code\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ControlFlowContext.prototype.printAST = function (ast, outfile) {\r\n            var printContext = new TypeScript.PrintContext(outfile, null);\r\n            printContext.increaseIndent();\r\n            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.prePrintAST, TypeScript.postPrintAST, null, printContext);\r\n            printContext.decreaseIndent();\r\n        };\r\n        ControlFlowContext.prototype.printBlockContent = function (bb, outfile) {\r\n            var content = bb.content;\r\n            for(var i = 0, len = content.members.length; i < len; i++) {\r\n                var ast = content.members[i];\r\n                this.printAST(ast, outfile);\r\n            }\r\n        };\r\n        ControlFlowContext.prototype.bfs = function (nodeFunc, edgeFunc, preEdges, postEdges) {\r\n            var markValue = this.markBase++;\r\n            var q = new Array();\r\n            q[q.length] = this.entry;\r\n            while(q.length > 0) {\r\n                var bb = q.pop();\r\n                if(!(bb.marked(markValue))) {\r\n                    bb.mark();\r\n                    if(nodeFunc) {\r\n                        nodeFunc(bb);\r\n                    }\r\n                    var succLen = bb.successors.length;\r\n                    if(succLen > 0) {\r\n                        if(preEdges) {\r\n                            preEdges();\r\n                        }\r\n                        for(var j = succLen - 1; j >= 0; j--) {\r\n                            var successor = bb.successors[j];\r\n                            if(!(successor.marked(this.markBase))) {\r\n                                if(edgeFunc) {\r\n                                    edgeFunc(bb, successor);\r\n                                }\r\n                                q[q.length] = successor;\r\n                            }\r\n                        }\r\n                        if(postEdges) {\r\n                            postEdges();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ControlFlowContext.prototype.useDef = function (er, funcSym) {\r\n            var _this = this;\r\n            var useDefContext = new UseDefContext();\r\n            useDefContext.func = funcSym;\r\n            var useDefInit = function (bb) {\r\n                bb.useDef = new BBUseDefInfo(bb);\r\n                bb.useDef.initialize(useDefContext);\r\n                _this.linearBBs[_this.linearBBs.length] = bb;\r\n            };\r\n            this.bfs(useDefInit, null, null, null);\r\n            var i;\r\n            var bbLen;\r\n\r\n            for(i = 0 , bbLen = this.linearBBs.length; i < bbLen; i++) {\r\n                this.linearBBs[i].useDef.initializeGen(useDefContext);\r\n                this.linearBBs[i].useDef.initializeKill(useDefContext);\r\n            }\r\n            var changed = true;\r\n            while(changed) {\r\n                changed = false;\r\n                for(i = 0; i < bbLen; i++) {\r\n                    changed = this.linearBBs[i].useDef.updateTop() || changed;\r\n                }\r\n            }\r\n            var top = this.entry.useDef.top;\r\n            top.map(function (index) {\r\n                var ast = useDefContext.uses[index];\r\n                er.simpleError(ast, \"use of variable '\" + ast.text + \"' that is not definitely assigned\");\r\n            });\r\n        };\r\n        ControlFlowContext.prototype.print = function (outfile) {\r\n            var _this = this;\r\n            var index = 0;\r\n            var node = function (bb) {\r\n                if(bb.index < 0) {\r\n                    bb.index = index++;\r\n                }\r\n                if(bb == _this.exit) {\r\n                    outfile.WriteLine(\"Exit block with index \" + bb.index);\r\n                } else {\r\n                    outfile.WriteLine(\"Basic block with index \" + bb.index);\r\n                    _this.printBlockContent(bb, outfile);\r\n                }\r\n            };\r\n            function preEdges() {\r\n                outfile.Write(\"  Branches to \");\r\n            }\r\n            function postEdges() {\r\n                outfile.WriteLine(\"\");\r\n            }\r\n            function edge(node1, node2) {\r\n                if(node2.index < 0) {\r\n                    node2.index = index++;\r\n                }\r\n                outfile.Write(node2.index + \" \");\r\n            }\r\n            this.bfs(node, edge, preEdges, postEdges);\r\n            if(this.unreachable != null) {\r\n                for(var i = 0, len = this.unreachable.length; i < len; i++) {\r\n                    outfile.WriteLine(\"Unreachable basic block ...\");\r\n                    this.printAST(this.unreachable[i], outfile);\r\n                }\r\n            }\r\n        };\r\n        ControlFlowContext.prototype.pushStatement = function (stmt, continueBB, breakBB) {\r\n            this.statementStack.push({\r\n                stmt: stmt,\r\n                continueBB: continueBB,\r\n                breakBB: breakBB\r\n            });\r\n        };\r\n        ControlFlowContext.prototype.popStatement = function () {\r\n            return this.statementStack.pop();\r\n        };\r\n        ControlFlowContext.prototype.returnStmt = function () {\r\n            this.current.addSuccessor(this.exit);\r\n            this.setUnreachable();\r\n        };\r\n        ControlFlowContext.prototype.setUnreachable = function () {\r\n            this.current = null;\r\n            this.noContinuation = true;\r\n        };\r\n        ControlFlowContext.prototype.addUnreachable = function (ast) {\r\n            if(this.unreachable === null) {\r\n                this.unreachable = new Array();\r\n            }\r\n            this.unreachable[this.unreachable.length] = ast;\r\n        };\r\n        ControlFlowContext.prototype.unconditionalBranch = function (target, isContinue) {\r\n            var targetBB = null;\r\n            for(var i = 0, len = this.statementStack.length; i < len; i++) {\r\n                var targetInfo = this.statementStack[i];\r\n                if(targetInfo.stmt == target) {\r\n                    if(isContinue) {\r\n                        targetBB = targetInfo.continueBB;\r\n                    } else {\r\n                        targetBB = targetInfo.breakBB;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if(targetBB) {\r\n                this.current.addSuccessor(targetBB);\r\n            }\r\n            this.setUnreachable();\r\n        };\r\n        ControlFlowContext.prototype.addContent = function (ast) {\r\n            if(this.current) {\r\n                this.current.content.append(ast);\r\n            }\r\n        };\r\n        return ControlFlowContext;\r\n    })();\r\n    TypeScript.ControlFlowContext = ControlFlowContext;    \r\n    var ResolutionDataCache = (function () {\r\n        function ResolutionDataCache() {\r\n            this.cacheSize = 16;\r\n            this.rdCache = [];\r\n            this.nextUp = 0;\r\n            for(var i = 0; i < this.cacheSize; i++) {\r\n                this.rdCache[i] = {\r\n                    actuals: new Array(),\r\n                    exactCandidates: new Array(),\r\n                    conversionCandidates: new Array(),\r\n                    id: i\r\n                };\r\n            }\r\n        }\r\n        ResolutionDataCache.prototype.getResolutionData = function () {\r\n            var rd = null;\r\n            if(this.nextUp < this.cacheSize) {\r\n                rd = this.rdCache[this.nextUp];\r\n            }\r\n            if(rd == null) {\r\n                this.cacheSize++;\r\n                rd = {\r\n                    actuals: new Array(),\r\n                    exactCandidates: new Array(),\r\n                    conversionCandidates: new Array(),\r\n                    id: this.cacheSize\r\n                };\r\n                this.rdCache[this.cacheSize] = rd;\r\n            }\r\n            this.nextUp++;\r\n            return rd;\r\n        };\r\n        ResolutionDataCache.prototype.returnResolutionData = function (rd) {\r\n            rd.actuals.length = 0;\r\n            rd.exactCandidates.length = 0;\r\n            rd.conversionCandidates.length = 0;\r\n            this.nextUp = rd.id;\r\n        };\r\n        return ResolutionDataCache;\r\n    })();\r\n    TypeScript.ResolutionDataCache = ResolutionDataCache;    \r\n    var TypeFlow = (function () {\r\n        function TypeFlow(logger, initScope, parser, checker) {\r\n            this.logger = logger;\r\n            this.initScope = initScope;\r\n            this.parser = parser;\r\n            this.checker = checker;\r\n            this.thisFnc = null;\r\n            this.thisClassNode = null;\r\n            this.enclosingFncIsMethod = false;\r\n            this.arrayInterfaceType = null;\r\n            this.stringInterfaceType = null;\r\n            this.objectInterfaceType = null;\r\n            this.functionInterfaceType = null;\r\n            this.numberInterfaceType = null;\r\n            this.booleanInterfaceType = null;\r\n            this.currentScript = null;\r\n            this.inNewTargetTypeCheck = false;\r\n            this.inImportTypeCheck = false;\r\n            this.inTypeRefTypeCheck = false;\r\n            this.inArrayElementTypeCheck = false;\r\n            this.resolutionDataCache = new ResolutionDataCache();\r\n            this.nestingLevel = 0;\r\n            this.inBoundPropTypeCheck = false;\r\n            this.inSuperCall = false;\r\n            this.checker.typeFlow = this;\r\n            this.scope = this.initScope;\r\n            this.globalScope = this.initScope;\r\n            this.doubleType = this.checker.numberType;\r\n            this.booleanType = this.checker.booleanType;\r\n            this.stringType = this.checker.stringType;\r\n            this.anyType = this.checker.anyType;\r\n            this.regexType = this.anyType;\r\n            this.nullType = this.checker.nullType;\r\n            this.voidType = this.checker.voidType;\r\n            this.arrayAnyType = this.checker.makeArrayType(this.anyType);\r\n        }\r\n        TypeFlow.prototype.initLibs = function () {\r\n            var arraySym = this.globalScope.find(\"Array\", false, true);\r\n            if(arraySym && (arraySym.kind() == TypeScript.SymbolKind.Type)) {\r\n                this.arrayInterfaceType = (arraySym).type;\r\n            }\r\n            var stringSym = this.globalScope.find(\"String\", false, true);\r\n            if(stringSym && (stringSym.kind() == TypeScript.SymbolKind.Type)) {\r\n                this.stringInterfaceType = (stringSym).type;\r\n            }\r\n            var objectSym = this.globalScope.find(\"Object\", false, true);\r\n            if(objectSym && (objectSym.kind() == TypeScript.SymbolKind.Type)) {\r\n                this.objectInterfaceType = (objectSym).type;\r\n            }\r\n            var fnSym = this.globalScope.find(\"Function\", false, true);\r\n            if(fnSym && (fnSym.kind() == TypeScript.SymbolKind.Type)) {\r\n                this.functionInterfaceType = (fnSym).type;\r\n            }\r\n            var numberSym = this.globalScope.find(\"Number\", false, true);\r\n            if(numberSym && (numberSym.kind() == TypeScript.SymbolKind.Type)) {\r\n                this.numberInterfaceType = (numberSym).type;\r\n            }\r\n            var booleanSym = this.globalScope.find(\"Boolean\", false, true);\r\n            if(booleanSym && (booleanSym.kind() == TypeScript.SymbolKind.Type)) {\r\n                this.booleanInterfaceType = (booleanSym).type;\r\n            }\r\n            var regexSym = this.globalScope.find(\"RegExp\", false, true);\r\n            if(regexSym && (regexSym.kind() == TypeScript.SymbolKind.Type)) {\r\n                this.regexType = (regexSym).type;\r\n            }\r\n        };\r\n        TypeFlow.prototype.cast = function (ast, type) {\r\n            return this.castWithCoercion(ast, type, true, false);\r\n        };\r\n        TypeFlow.prototype.castWithCoercion = function (ast, type, applyCoercion, typeAssertion) {\r\n            var comparisonInfo = new TypeScript.TypeComparisonInfo();\r\n            if(this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {\r\n                if(applyCoercion) {\r\n                    if(type == null) {\r\n                        ast.type = this.anyType;\r\n                    } else {\r\n                        if(type.isClass()) {\r\n                            ast.type = type.instanceType;\r\n                        } else {\r\n                            ast.type = type;\r\n                        }\r\n                    }\r\n                }\r\n                return ast;\r\n            } else {\r\n                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);\r\n                return ast;\r\n            }\r\n        };\r\n        TypeFlow.prototype.inScopeTypeCheck = function (ast, enclosingScope) {\r\n            var prevScope = this.scope;\r\n            this.scope = enclosingScope;\r\n            var svThisFnc = this.thisFnc;\r\n            var svThisType = this.thisType;\r\n            var svThisClassNode = this.thisClassNode;\r\n            var svCurrentModDecl = this.checker.currentModDecl;\r\n            var prevMethodStatus = this.enclosingFncIsMethod;\r\n            var container = this.scope.container;\r\n            var fnc = null;\r\n            while(container) {\r\n                if(container.kind() == TypeScript.SymbolKind.Type) {\r\n                    var typeSym = container;\r\n                    var type = typeSym.type;\r\n                    if(type.call) {\r\n                        if(fnc == null) {\r\n                            this.enclosingFncIsMethod = typeSym.isMethod;\r\n                            fnc = container.declAST;\r\n                        }\r\n                    }\r\n                    if(type.isClass()) {\r\n                        this.thisType = type.instanceType;\r\n                        if(typeSym.declAST && (typeSym.declAST.nodeType == TypeScript.NodeType.Class)) {\r\n                            this.thisClassNode = typeSym.declAST;\r\n                        }\r\n                        break;\r\n                    }\r\n                    if(type.isModuleType()) {\r\n                        this.checker.currentModDecl = typeSym.declAST;\r\n                        break;\r\n                    }\r\n                }\r\n                container = container.container;\r\n            }\r\n            this.thisFnc = fnc;\r\n            var updated = this.typeCheck(ast);\r\n            this.thisFnc = svThisFnc;\r\n            this.thisType = svThisType;\r\n            this.thisClassNode = svThisClassNode;\r\n            this.checker.currentModDecl = svCurrentModDecl;\r\n            this.enclosingFncIsMethod = prevMethodStatus;\r\n            this.scope = prevScope;\r\n            return updated;\r\n        };\r\n        TypeFlow.prototype.typeCheck = function (ast) {\r\n            if(ast) {\r\n                return ast.typeCheck(this);\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n        TypeFlow.prototype.inScopeTypeCheckDecl = function (ast) {\r\n            if(ast.nodeType == TypeScript.NodeType.VarDecl || ast.nodeType == TypeScript.NodeType.ArgDecl) {\r\n                this.inScopeTypeCheckBoundDecl(ast);\r\n            } else {\r\n                if(ast.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                    var funcDecl = ast;\r\n                    if(funcDecl.isAccessor()) {\r\n                        this.typeCheckFunction(funcDecl);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.inScopeTypeCheckBoundDecl = function (varDecl) {\r\n            var sym = varDecl.sym;\r\n            var svThisFnc = this.thisFnc;\r\n            var svThisType = this.thisType;\r\n            var prevMethodStatus = this.enclosingFncIsMethod;\r\n            var prevLocationInfo = this.checker.locationInfo;\r\n            if(sym && sym.container) {\r\n                var instanceScope = TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();\r\n                if(TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Property) && sym.container.declAST.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                    this.thisFnc = sym.container.declAST;\r\n                }\r\n                if(instanceScope) {\r\n                    var prevScope = this.scope;\r\n                    this.scope = instanceScope;\r\n                    var container = sym.container;\r\n                    if(this.checker.units && (sym.unitIndex >= 0) && (sym.unitIndex < this.checker.units.length)) {\r\n                        this.checker.locationInfo = this.checker.units[sym.unitIndex];\r\n                    } else {\r\n                        this.checker.locationInfo = TypeScript.unknownLocationInfo;\r\n                    }\r\n                    while(container) {\r\n                        if(container.kind() == TypeScript.SymbolKind.Type) {\r\n                            var typeSym = container;\r\n                            var type = typeSym.type;\r\n                            if(type.call) {\r\n                                this.enclosingFncIsMethod = typeSym.isMethod;\r\n                            }\r\n                            if(type.isClass()) {\r\n                                this.thisType = type.instanceType;\r\n                                break;\r\n                            }\r\n                        }\r\n                        container = container.container;\r\n                    }\r\n                    this.typeCheckBoundDecl(varDecl);\r\n                    this.scope = prevScope;\r\n                }\r\n            }\r\n            this.thisFnc = svThisFnc;\r\n            this.thisType = svThisType;\r\n            this.checker.locationInfo = prevLocationInfo;\r\n            this.enclosingFncIsMethod = prevMethodStatus;\r\n        };\r\n        TypeFlow.prototype.resolveBoundDecl = function (varDecl) {\r\n            if(varDecl.typeExpr) {\r\n                if(varDecl.typeExpr.type == null || (varDecl.typeExpr.type && varDecl.typeExpr.type == this.anyType && this.scope) || varDecl.typeExpr.type.symbol == null || !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {\r\n                    this.typeCheck(varDecl.typeExpr);\r\n                }\r\n                varDecl.type = varDecl.typeExpr.type;\r\n                if(varDecl.sym) {\r\n                    varDecl.sym.setType(varDecl.type);\r\n                }\r\n            } else {\r\n                if(varDecl.init == null) {\r\n                    if(this.checker.styleSettings.implicitAny) {\r\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\r\n                    }\r\n                    varDecl.type = this.anyType;\r\n                    if(varDecl.sym) {\r\n                        if(varDecl.sym.isType()) {\r\n                            var tsym = varDecl.sym;\r\n                            if(tsym.isMethod) {\r\n                                this.checker.errorReporter.simpleError(varDecl, \"Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)\");\r\n                                return;\r\n                            } else {\r\n                                this.checker.errorReporter.simpleError(varDecl, \"Cannot bind type to variable\");\r\n                                return;\r\n                            }\r\n                        }\r\n                        varDecl.sym.setType(varDecl.type);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckBoundDecl = function (varDecl) {\r\n            var infSym = varDecl.sym;\r\n            if(infSym == null) {\r\n                if(varDecl.init) {\r\n                    varDecl.init = this.typeCheck(varDecl.init);\r\n                    varDecl.type = this.checker.widenType(varDecl.init.type);\r\n                } else {\r\n                    if(this.checker.styleSettings.implicitAny) {\r\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\r\n                    }\r\n                    varDecl.type = this.anyType;\r\n                }\r\n            } else {\r\n                if(infSym.typeCheckStatus == TypeScript.TypeCheckStatus.Started) {\r\n                    if(this.checker.styleSettings.implicitAny) {\r\n                        this.checker.errorReporter.styleError(varDecl, \"type implicitly set to 'any'\");\r\n                    }\r\n                    varDecl.type = this.anyType;\r\n                    infSym.setType(this.anyType);\r\n                } else {\r\n                    if(infSym.typeCheckStatus == TypeScript.TypeCheckStatus.NotStarted) {\r\n                        infSym.typeCheckStatus = TypeScript.TypeCheckStatus.Started;\r\n                        this.checker.addStartedPTO(infSym);\r\n                        var resolved = false;\r\n                        if(varDecl.type == null) {\r\n                            if(varDecl.typeExpr) {\r\n                                this.resolveBoundDecl(varDecl);\r\n                                resolved = true;\r\n                                varDecl.type = varDecl.typeExpr.type;\r\n                                infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\r\n                            }\r\n                        }\r\n                        if(varDecl.init) {\r\n                            if(TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.Ambient)) {\r\n                                this.checker.errorReporter.simpleError(varDecl, \"Ambient variable can not have an initializer\");\r\n                            }\r\n                            var isLocalStatic = TypeScript.hasFlag(varDecl.varFlags, TypeScript.VarFlags.LocalStatic);\r\n                            var prevScope = this.scope;\r\n                            var applyTargetType = !varDecl.init.isParenthesized;\r\n                            if(isLocalStatic) {\r\n                                this.scope = varDecl.sym.container.getType().memberScope;\r\n                            }\r\n                            if(varDecl.varFlags & TypeScript.VarFlags.Property) {\r\n                                this.inBoundPropTypeCheck = true;\r\n                            }\r\n                            this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);\r\n                            if(this.inBoundPropTypeCheck) {\r\n                                this.inBoundPropTypeCheck = false;\r\n                            }\r\n                            this.scope = prevScope;\r\n                            if(varDecl.type) {\r\n                                var preserveScope = false;\r\n                                var preservedContainedScope = null;\r\n                                if(varDecl.init.type) {\r\n                                    preservedContainedScope = varDecl.init.type.containedScope;\r\n                                    preserveScope = true;\r\n                                    if(varDecl.init.type == this.voidType) {\r\n                                        this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.text + \"'\");\r\n                                    }\r\n                                }\r\n                                varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType, false);\r\n                                if(preserveScope && varDecl.init.type.containedScope == null) {\r\n                                    varDecl.init.type.containedScope = preservedContainedScope;\r\n                                }\r\n                            } else {\r\n                                varDecl.type = this.checker.widenType(varDecl.init.type);\r\n                                if(varDecl.type == this.voidType) {\r\n                                    this.checker.errorReporter.simpleError(varDecl, \"Cannot assign type 'void' to variable '\" + varDecl.id.text + \"'\");\r\n                                    varDecl.type = this.anyType;\r\n                                }\r\n                            }\r\n                            infSym.setType(varDecl.type);\r\n                        } else {\r\n                            if(!resolved) {\r\n                                this.resolveBoundDecl(varDecl);\r\n                            }\r\n                        }\r\n                        infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\r\n                    } else {\r\n                        if(this.checker.typeStatusIsFinished(infSym.typeCheckStatus) && (infSym.declAST != varDecl)) {\r\n                            if(varDecl.init) {\r\n                                varDecl.init = this.typeCheck(varDecl.init);\r\n                                varDecl.type = infSym.getType();\r\n                                varDecl.init = this.cast(varDecl.init, varDecl.type);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(varDecl.id && varDecl.sym) {\r\n                varDecl.id.sym = varDecl.sym;\r\n            }\r\n            return varDecl;\r\n        };\r\n        TypeFlow.prototype.typeCheckSuper = function (ast) {\r\n            if(this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {\r\n                ast.type = this.thisType.baseClass();\r\n            } else {\r\n                ast.type = this.anyType;\r\n                this.checker.errorReporter.invalidSuperReference(ast);\r\n            }\r\n            return ast;\r\n        };\r\n        TypeFlow.prototype.typeCheckThis = function (ast) {\r\n            var illegalThisRef = false;\r\n            if(this.thisFnc == null) {\r\n                if(this.thisType) {\r\n                    if(this.thisClassNode && this.thisClassNode.nty == TypeScript.NodeType.Class) {\r\n                        illegalThisRef = true;\r\n                        ast.type = this.anyType;\r\n                    } else {\r\n                        ast.type = this.thisType;\r\n                    }\r\n                } else {\r\n                    if(this.checker.currentModDecl) {\r\n                        this.checker.errorReporter.simpleError(ast, \"'this' may not be referenced within module bodies\");\r\n                    }\r\n                    ast.type = this.anyType;\r\n                }\r\n            } else {\r\n                if((this.inBoundPropTypeCheck || this.inSuperCall) && this.thisClassNode && this.thisClassNode.nty == TypeScript.NodeType.Class) {\r\n                    illegalThisRef = true;\r\n                }\r\n                if(this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {\r\n                    if(this.thisType && !(this.thisFnc.fncFlags & TypeScript.FncFlags.Static)) {\r\n                        ast.type = this.thisType;\r\n                    } else {\r\n                        ast.type = this.anyType;\r\n                    }\r\n                } else {\r\n                    ast.type = this.anyType;\r\n                }\r\n            }\r\n            if(!this.enclosingFncIsMethod && this.thisFnc && TypeScript.hasFlag(this.thisFnc.fncFlags, TypeScript.FncFlags.IsFatArrowFunction)) {\r\n                if(this.thisFnc.boundToProperty) {\r\n                    var container = this.thisFnc.boundToProperty.sym.container;\r\n                    if(container.declAST.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                        (container.declAST).setHasSelfReference();\r\n                    }\r\n                } else {\r\n                    var encFnc = this.thisFnc.enclosingFnc;\r\n                    var firstEncFnc = encFnc;\r\n                    var foundMeth = false;\r\n                    while(encFnc) {\r\n                        if(encFnc.isMethod() || encFnc.isConstructor || encFnc.hasSelfReference()) {\r\n                            encFnc.setHasSelfReference();\r\n                            foundMeth = true;\r\n                            break;\r\n                        }\r\n                        encFnc = encFnc.enclosingFnc;\r\n                    }\r\n                    if(!foundMeth && firstEncFnc) {\r\n                        firstEncFnc.setHasSelfReference();\r\n                    }\r\n                    if(foundMeth && this.thisType) {\r\n                        ast.type = this.thisType;\r\n                    }\r\n                }\r\n            }\r\n            if(illegalThisRef) {\r\n                this.checker.errorReporter.simpleError(ast, \"Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls\");\r\n            }\r\n            return ast;\r\n        };\r\n        TypeFlow.prototype.setTypeFromSymbol = function (ast, symbol) {\r\n            if(symbol.isVariable()) {\r\n                if(symbol.isInferenceSymbol()) {\r\n                    var infSym = symbol;\r\n                    if(infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\r\n                        this.inScopeTypeCheckDecl(infSym.declAST);\r\n                    }\r\n                    if(!this.checker.styleSettings.innerScopeDeclEscape) {\r\n                        if(infSym.declAST && (infSym.declAST.nodeType == TypeScript.NodeType.VarDecl)) {\r\n                            if(this.nestingLevel < (infSym.declAST).nestingLevel) {\r\n                                this.checker.errorReporter.styleError(ast, \"Illegal reference to a variable defined in more nested scope\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                ast.type = symbol.getType();\r\n                if(!symbol.writeable()) {\r\n                    ast.flags = ast.flags & (~(TypeScript.ASTFlags.Writeable));\r\n                }\r\n            } else {\r\n                if(symbol.isType()) {\r\n                    ast.type = symbol.getType();\r\n                    ast.flags = ast.flags & (~(TypeScript.ASTFlags.Writeable));\r\n                } else {\r\n                    ast.type = this.anyType;\r\n                    this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckName = function (ast) {\r\n            var _this = this;\r\n            var identifier = ast;\r\n            if(this.checker.inWith) {\r\n                identifier.type = this.anyType;\r\n            } else {\r\n                var typespace = false;\r\n                var idText = identifier.text;\r\n                var originalIdText = idText;\r\n                var isDynamicModuleName = TypeScript.isQuoted(identifier.text);\r\n                var symbol = this.scope.find(idText, false, typespace);\r\n                if(symbol == null && isDynamicModuleName) {\r\n                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.filename, function (id) {\r\n                        return _this.scope.find(id, false, typespace);\r\n                    });\r\n                }\r\n                if(!symbol) {\r\n                    if(!identifier.isMissing()) {\r\n                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);\r\n                    }\r\n                    identifier.type = this.anyType;\r\n                } else {\r\n                    if(this.inNewTargetTypeCheck && symbol.isInferenceSymbol() && !this.checker.typeStatusIsFinished((symbol).typeCheckStatus)) {\r\n                        this.checker.errorReporter.simpleError(ast, \"Symbol '\" + identifier.text + \"' is referenced before its declaration\");\r\n                    }\r\n                    if(TypeScript.optimizeModuleCodeGen && symbol && symbol.isType()) {\r\n                        var symType = symbol.getType();\r\n                        if(symType && (symbol).aliasLink && (symbol).onlyReferencedAsTypeRef) {\r\n                            var modDecl = symType.symbol.declAST;\r\n                            if(modDecl && TypeScript.hasFlag(modDecl.modFlags, TypeScript.ModuleFlags.IsDynamic)) {\r\n                                (symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;\r\n                            }\r\n                        }\r\n                    }\r\n                    if(symbol.declAST && symbol.declAST.nodeType == TypeScript.NodeType.FuncDecl && !(symbol.declAST).returnTypeAnnotation && (symbol.declAST).signature.typeCheckStatus == TypeScript.TypeCheckStatus.Started) {\r\n                        (symbol.declAST).type.symbol.flags |= TypeScript.SymbolFlags.RecursivelyReferenced;\r\n                        (symbol.declAST).signature.returnType.type = this.anyType;\r\n                    }\r\n                    this.setTypeFromSymbol(ast, symbol);\r\n                    identifier.sym = symbol;\r\n                    if(this.thisFnc) {\r\n                        if(this.thisFnc.type && symbol.container != this.thisFnc.type.symbol) {\r\n                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return ast;\r\n        };\r\n        TypeFlow.prototype.typeCheckScript = function (script) {\r\n            this.checker.locationInfo = script.locationInfo;\r\n            this.scope = this.checker.globalScope;\r\n            if(!script.topLevelMod) {\r\n                this.addLocalsFromScope(this.scope, this.checker.gloMod, script.vars, this.checker.globals, true);\r\n            }\r\n            this.currentScript = script;\r\n            script.bod = this.typeCheck(script.bod);\r\n            this.currentScript = null;\r\n            return script;\r\n        };\r\n        TypeFlow.prototype.typeCheckBitNot = function (ast) {\r\n            var unex = ast;\r\n            unex.operand = this.typeCheck(unex.operand);\r\n            unex.type = this.doubleType;\r\n            return unex;\r\n        };\r\n        TypeFlow.prototype.typeCheckUnaryNumberOperator = function (ast) {\r\n            var unex = ast;\r\n            unex.operand = this.typeCheck(unex.operand);\r\n            unex.type = this.doubleType;\r\n            return ast;\r\n        };\r\n        TypeFlow.prototype.typeCheckLogNot = function (ast) {\r\n            var unex = ast;\r\n            unex.operand = this.typeCheck(unex.operand);\r\n            unex.type = this.booleanType;\r\n            return unex;\r\n        };\r\n        TypeFlow.prototype.astIsWriteable = function (ast) {\r\n            return TypeScript.hasFlag(ast.flags, TypeScript.ASTFlags.Writeable);\r\n        };\r\n        TypeFlow.prototype.typeCheckIncOrDec = function (ast) {\r\n            var unex = ast;\r\n            var lval = unex.operand;\r\n            if(!this.astIsWriteable(unex)) {\r\n                this.checker.errorReporter.valueCannotBeModified(unex);\r\n                unex.type = this.doubleType;\r\n            } else {\r\n                unex = this.typeCheckUnaryNumberOperator(ast);\r\n                if(unex.operand.type != this.checker.numberType && unex.operand.type != this.checker.anyType && !(unex.operand.type.typeFlags & TypeScript.TypeFlags.IsEnum)) {\r\n                    this.checker.errorReporter.simpleError(ast, \"'++' and '--' may only be applied to operands of type 'number' or 'any'\");\r\n                }\r\n            }\r\n            return unex;\r\n        };\r\n        TypeFlow.prototype.typeCheckBitwiseOperator = function (ast, assignment) {\r\n            var binex = ast;\r\n            var resultType = null;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            var leftType = binex.operand1.type;\r\n            var rightType = binex.operand2.type;\r\n            if(assignment && (!this.astIsWriteable(binex))) {\r\n                this.checker.errorReporter.valueCannotBeModified(binex);\r\n            }\r\n            if(this.checker.styleSettings.bitwise) {\r\n                this.checker.errorReporter.styleError(ast, \"use of \" + TypeScript.nodeTypeTable[binex.nodeType]);\r\n            }\r\n            if(this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {\r\n                resultType = this.doubleType;\r\n            } else {\r\n                if((leftType == this.booleanType) && (rightType == this.booleanType)) {\r\n                    resultType = this.booleanType;\r\n                } else {\r\n                    if(leftType == this.anyType) {\r\n                        if((rightType == this.anyType) || (rightType == this.doubleType) || (rightType == this.booleanType)) {\r\n                            resultType = this.anyType;\r\n                        }\r\n                    } else {\r\n                        if(rightType == this.anyType) {\r\n                            if((leftType == this.anyType) || (leftType == this.doubleType) || (leftType == this.booleanType)) {\r\n                                resultType = this.anyType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(resultType == null) {\r\n                resultType = this.anyType;\r\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\r\n            }\r\n            binex.type = resultType;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckArithmeticOperator = function (ast, assignment) {\r\n            var binex = ast;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            var leftType = binex.operand1.type;\r\n            var rightType = binex.operand2.type;\r\n            if(assignment && (!this.astIsWriteable(binex))) {\r\n                this.checker.errorReporter.valueCannotBeModified(binex);\r\n            }\r\n            if(this.checker.styleSettings.bitwise && ((binex.nodeType == TypeScript.NodeType.And) || (binex.nodeType == TypeScript.NodeType.Or) || (binex.nodeType == TypeScript.NodeType.AsgAnd) || (binex.nodeType == TypeScript.NodeType.AsgOr))) {\r\n                this.checker.errorReporter.styleError(ast, \"use of \" + TypeScript.nodeTypeTable[binex.nodeType]);\r\n            }\r\n            if(leftType == null || rightType == null) {\r\n                this.checker.errorReporter.simpleError(binex, \"Could not typecheck arithmetic operation.  Possible recursive typecheck error?\");\r\n                binex.type = this.anyType;\r\n                return binex;\r\n            }\r\n            var nodeType = binex.nodeType;\r\n            if(this.checker.isNullOrUndefinedType(leftType)) {\r\n                leftType = rightType;\r\n            }\r\n            if(this.checker.isNullOrUndefinedType(rightType)) {\r\n                rightType = leftType;\r\n            }\r\n            leftType = this.checker.widenType(leftType);\r\n            rightType = this.checker.widenType(rightType);\r\n            if(nodeType == TypeScript.NodeType.Add || nodeType == TypeScript.NodeType.AsgAdd) {\r\n                if(leftType == this.checker.stringType || rightType == this.checker.stringType) {\r\n                    binex.type = this.checker.stringType;\r\n                } else {\r\n                    if(leftType == this.checker.numberType && rightType == this.checker.numberType) {\r\n                        binex.type = this.checker.numberType;\r\n                    } else {\r\n                        if(this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\r\n                            binex.type = this.checker.numberType;\r\n                        } else {\r\n                            if(leftType == this.checker.anyType || rightType == this.checker.anyType) {\r\n                                binex.type = this.checker.anyType;\r\n                            } else {\r\n                                binex.type = this.anyType;\r\n                                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if(leftType == this.checker.numberType && rightType == this.checker.numberType) {\r\n                    binex.type = this.checker.numberType;\r\n                } else {\r\n                    if(this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {\r\n                        binex.type = this.checker.numberType;\r\n                    } else {\r\n                        if(leftType == this.checker.anyType || rightType == this.checker.anyType) {\r\n                            binex.type = this.checker.numberType;\r\n                        } else {\r\n                            binex.type = this.anyType;\r\n                            this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckDotOperator = function (ast) {\r\n            var binex = ast;\r\n            var leftIsFnc = false;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            var leftType = binex.operand1.type;\r\n            var leftScope = null;\r\n            if(leftType) {\r\n                if(leftType == this.anyType) {\r\n                    binex.type = this.anyType;\r\n                    return binex;\r\n                } else {\r\n                    if(leftType == this.stringType) {\r\n                        if(this.stringInterfaceType) {\r\n                            leftScope = this.stringInterfaceType.memberScope;\r\n                        } else {\r\n                            binex.type = this.anyType;\r\n                            return binex;\r\n                        }\r\n                    } else {\r\n                        if(leftType == this.doubleType) {\r\n                            if(this.numberInterfaceType) {\r\n                                leftScope = this.numberInterfaceType.memberScope;\r\n                            } else {\r\n                                binex.type = this.anyType;\r\n                                return binex;\r\n                            }\r\n                        } else {\r\n                            if(leftType == this.booleanType) {\r\n                                if(this.booleanInterfaceType) {\r\n                                    leftScope = this.booleanInterfaceType.memberScope;\r\n                                } else {\r\n                                    binex.type = this.anyType;\r\n                                    return binex;\r\n                                }\r\n                            } else {\r\n                                if((leftType.call || leftType.construct) && leftType.members == null) {\r\n                                    if(this.functionInterfaceType) {\r\n                                        leftScope = this.functionInterfaceType.memberScope;\r\n                                    } else {\r\n                                        binex.type = this.anyType;\r\n                                        return binex;\r\n                                    }\r\n                                } else {\r\n                                    if(leftType.elementType) {\r\n                                        if(this.arrayInterfaceType) {\r\n                                            var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);\r\n                                            leftScope = arrInstType.memberScope;\r\n                                        } else {\r\n                                            binex.type = this.anyType;\r\n                                            return binex;\r\n                                        }\r\n                                    } else {\r\n                                        leftScope = leftType.memberScope;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(leftScope == null) {\r\n                this.checker.errorReporter.expectedClassOrInterface(binex);\r\n                binex.type = this.anyType;\r\n            } else {\r\n                var propertyName = binex.operand2;\r\n                var lhsIsEnclosingType = this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType;\r\n                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, false);\r\n                if(!symbol) {\r\n                    if(this.objectInterfaceType && leftType) {\r\n                        if(leftType.isReferenceType()) {\r\n                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, false);\r\n                        }\r\n                        if(!symbol) {\r\n                            if(this.functionInterfaceType && (leftType.call || leftType.construct)) {\r\n                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, false);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(!symbol || (!symbol.visible(leftScope, this.checker))) {\r\n                    binex.type = this.anyType;\r\n                    if(symbol == null) {\r\n                        this.checker.errorReporter.simpleError(propertyName, \"The property '\" + propertyName.text + \"' does not exist on value of type '\" + leftType.getScopedTypeName(this.scope) + \"'\");\r\n                    } else {\r\n                        this.checker.errorReporter.simpleError(binex, \"The property '\" + propertyName.text + \" on type '\" + leftType.getScopedTypeName(this.scope) + \"' is not visible\");\r\n                    }\r\n                } else {\r\n                    if(symbol.isVariable()) {\r\n                        if(symbol.isInferenceSymbol()) {\r\n                            var infSym = symbol;\r\n                            if(infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {\r\n                                this.inScopeTypeCheckDecl(infSym.declAST);\r\n                            }\r\n                        }\r\n                    }\r\n                    propertyName.sym = symbol;\r\n                    binex.type = symbol.getType();\r\n                }\r\n            }\r\n            if(binex.type == null) {\r\n                binex.type = this.anyType;\r\n            }\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckBooleanOperator = function (ast) {\r\n            var binex = ast;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            var leftType = binex.operand1.type;\r\n            var rightType = binex.operand2.type;\r\n            if((!(this.checker.sourceIsAssignableToTarget(leftType, rightType))) && (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {\r\n                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);\r\n            }\r\n            binex.type = this.booleanType;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckAsgOperator = function (ast) {\r\n            var binex = ast;\r\n            var applyTargetType = !binex.operand2.isParenthesized;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);\r\n            var leftType = binex.operand1.type;\r\n            var rightType = binex.operand2.type;\r\n            if(!(this.astIsWriteable(binex.operand1))) {\r\n                this.checker.errorReporter.valueCannotBeModified(binex);\r\n            }\r\n            if(binex.operand1.nodeType == TypeScript.NodeType.Call) {\r\n                var callEx = binex.operand1;\r\n            }\r\n            var preserveScope = false;\r\n            var preservedContainedScope = null;\r\n            if(binex.operand2.type) {\r\n                preservedContainedScope = binex.operand2.type.containedScope;\r\n                preserveScope = true;\r\n            }\r\n            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType, false);\r\n            if(preserveScope && binex.operand2.type.containedScope == null) {\r\n                binex.operand2.type.containedScope = preservedContainedScope;\r\n            }\r\n            binex.type = rightType;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckIndex = function (ast) {\r\n            var binex = ast;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            if(!this.checker.styleSettings.literalSubscript) {\r\n                if(binex.operand2.nodeType == TypeScript.NodeType.QString) {\r\n                    this.checker.errorReporter.styleError(ast, \"use literal subscript ('.') notation instead)\");\r\n                }\r\n            }\r\n            var objExprType = binex.operand1.type;\r\n            var indexExprType = binex.operand2.type;\r\n            if(objExprType.elementType) {\r\n                if(indexExprType == this.checker.anyType || indexExprType == this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, TypeScript.TypeFlags.IsEnum)) {\r\n                    binex.type = objExprType.elementType;\r\n                } else {\r\n                    if(indexExprType == this.checker.stringType) {\r\n                        binex.type = this.checker.anyType;\r\n                    } else {\r\n                        this.checker.errorReporter.simpleError(binex, \"Illegal property access\");\r\n                        binex.type = this.checker.anyType;\r\n                    }\r\n                }\r\n            } else {\r\n                if(objExprType.index) {\r\n                    if(indexExprType == this.checker.anyType || !((objExprType.index.flags & TypeScript.SignatureFlags.IsStringIndexer) || (objExprType.index.flags & TypeScript.SignatureFlags.IsNumberIndexer)) || ((objExprType.index.flags & TypeScript.SignatureFlags.IsStringIndexer) && indexExprType == this.checker.stringType) || ((objExprType.index.flags & TypeScript.SignatureFlags.IsNumberIndexer) && (indexExprType == this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, TypeScript.TypeFlags.IsEnum)))) {\r\n                        var sig = this.resolveOverload(ast, objExprType.index);\r\n                        if(sig) {\r\n                            binex.type = sig.returnType.type;\r\n                        } else {\r\n                            binex.type = this.checker.anyType;\r\n                        }\r\n                    } else {\r\n                        if(indexExprType == this.checker.stringType) {\r\n                            binex.type = this.checker.anyType;\r\n                        } else {\r\n                            this.checker.errorReporter.simpleError(binex, \"Illegal property access\");\r\n                            binex.type = this.checker.anyType;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if((objExprType == this.checker.anyType || objExprType == this.checker.stringType || objExprType == this.checker.numberType || objExprType == this.checker.booleanType || objExprType.isReferenceType()) && (indexExprType == this.checker.anyType || indexExprType == this.checker.stringType || (indexExprType == this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, TypeScript.TypeFlags.IsEnum)))) {\r\n                        binex.type = this.checker.anyType;\r\n                    } else {\r\n                        this.checker.errorReporter.simpleError(binex, \"Illegal property access\");\r\n                        binex.type = this.checker.anyType;\r\n                    }\r\n                }\r\n            }\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckInOperator = function (binex) {\r\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            if(!((binex.operand1.type == this.checker.anyType || binex.operand1.type == this.checker.stringType) && (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {\r\n                this.checker.errorReporter.simpleError(binex, \"The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type\");\r\n            }\r\n            binex.type = this.booleanType;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckShift = function (binex, assignment) {\r\n            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);\r\n            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);\r\n            if(assignment && (!(this.astIsWriteable(binex.operand1)))) {\r\n                this.checker.errorReporter.valueCannotBeModified(binex);\r\n            }\r\n            binex.type = this.doubleType;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckQMark = function (trinex) {\r\n            trinex.operand1 = this.typeCheck(trinex.operand1);\r\n            trinex.operand2 = this.typeCheck(trinex.operand2);\r\n            trinex.operand3 = this.typeCheck(trinex.operand3);\r\n            var leftType = trinex.operand2.type;\r\n            var rightType = trinex.operand3.type;\r\n            if(leftType == rightType) {\r\n                trinex.type = leftType;\r\n            } else {\r\n                if(this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\r\n                    trinex.type = rightType;\r\n                } else {\r\n                    if(this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\r\n                        trinex.type = leftType;\r\n                    } else {\r\n                        trinex.type = this.anyType;\r\n                        this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);\r\n                    }\r\n                }\r\n            }\r\n            return trinex;\r\n        };\r\n        TypeFlow.prototype.addFormals = function (container, signature, table) {\r\n            var len = signature.parameters.length;\r\n            for(var i = 0; i < len; i++) {\r\n                var symbol = signature.parameters[i];\r\n                symbol.container = container;\r\n                table.add(symbol.name, symbol);\r\n            }\r\n        };\r\n        TypeFlow.prototype.addLocalsFromScope = function (scope, container, vars, table, isModContainer) {\r\n            var len = vars.members.length;\r\n            var hasArgsDef = false;\r\n            for(var i = 0; i < len; i++) {\r\n                var local = vars.members[i];\r\n                if(((local.sym == null) || (local.sym.kind() != TypeScript.SymbolKind.Field))) {\r\n                    var result = null;\r\n                    if((result = table.lookup(local.id.text)) == null) {\r\n                        var localVar = new TypeScript.ValueLocation();\r\n                        localVar.typeLink = new TypeScript.TypeLink();\r\n                        var varSym = null;\r\n                        if(TypeScript.hasFlag(local.varFlags, TypeScript.VarFlags.Static)) {\r\n                            local.varFlags |= TypeScript.VarFlags.LocalStatic;\r\n                            varSym = new TypeScript.FieldSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, true, localVar);\r\n                        } else {\r\n                            varSym = new TypeScript.VariableSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, localVar);\r\n                        }\r\n                        varSym.transferVarFlags(local.varFlags);\r\n                        localVar.symbol = varSym;\r\n                        varSym.declAST = local;\r\n                        localVar.typeLink.ast = local.typeExpr;\r\n                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);\r\n                        if((local.type == null) && (local.init == null)) {\r\n                            local.type = this.anyType;\r\n                        }\r\n                        localVar.typeLink.type = local.type;\r\n                        localVar.symbol.container = container;\r\n                        local.sym = localVar.symbol;\r\n                        table.add(local.id.text, varSym);\r\n                        if(local.id.text == \"arguments\") {\r\n                            hasArgsDef = true;\r\n                        }\r\n                    } else {\r\n                        local.type = result.getType();\r\n                        local.sym = result;\r\n                    }\r\n                }\r\n            }\r\n            if(!isModContainer) {\r\n                if(!hasArgsDef) {\r\n                    var argLoc = new TypeScript.ValueLocation();\r\n                    argLoc.typeLink = new TypeScript.TypeLink();\r\n                    var theArgSym = new TypeScript.VariableSymbol(\"arguments\", vars.minChar, this.checker.locationInfo.unitIndex, argLoc);\r\n                    argLoc.typeLink.ast = new TypeScript.Identifier(\"IArguments\");\r\n                    this.checker.resolveTypeLink(scope, argLoc.typeLink, false);\r\n                    table.add(\"arguments\", theArgSym);\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.addConstructorLocalArgs = function (container, args, table, isClass) {\r\n            if(args) {\r\n                var len = args.members.length;\r\n                for(var i = 0; i < len; i++) {\r\n                    var local = args.members[i];\r\n                    if((local.sym == null) || (isClass || (local.sym.kind() != TypeScript.SymbolKind.Field))) {\r\n                        var result = null;\r\n                        if((result = table.lookup(local.id.text)) == null) {\r\n                            this.resolveBoundDecl(local);\r\n                            var localVar = new TypeScript.ValueLocation();\r\n                            localVar.typeLink = new TypeScript.TypeLink();\r\n                            var varSym = new TypeScript.ParameterSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, localVar);\r\n                            varSym.declAST = local;\r\n                            localVar.symbol = varSym;\r\n                            localVar.typeLink.type = local.type;\r\n                            localVar.symbol.container = container;\r\n                            local.sym = localVar.symbol;\r\n                            table.add(local.id.text, varSym);\r\n                        } else {\r\n                            local.type = result.getType();\r\n                            local.sym = result;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.checkInitSelf = function (funcDecl) {\r\n            if(!funcDecl.isMethod()) {\r\n                var freeVars = funcDecl.freeVariables;\r\n                for(var k = 0, len = freeVars.length; k < len; k++) {\r\n                    var sym = freeVars[k];\r\n                    if(sym.isInstanceProperty()) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            var fns = funcDecl.scopes;\r\n            var fnsLen = fns.members.length;\r\n            for(var j = 0; j < fnsLen; j++) {\r\n                var fn = fns.members[j];\r\n                if(this.checkInitSelf(fn)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        TypeFlow.prototype.checkPromoteFreeVars = function (funcDecl, constructorSym) {\r\n            var freeVars = funcDecl.freeVariables;\r\n            for(var k = 0, len = freeVars.length; k < len; k++) {\r\n                var sym = freeVars[k];\r\n                if((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {\r\n                    TypeScript.instanceFilter.reset();\r\n                    if(this.scope.search(TypeScript.instanceFilter, sym.name, false, false)) {\r\n                        this.checker.errorReporter.simpleError(funcDecl, \"Constructor-local variable shadows class property '\" + sym.name + \"'. To access the class property, use 'self.\" + sym.name + \"'\");\r\n                    }\r\n                    this.checker.errorReporter.simpleError(funcDecl, \"Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '\" + sym.name + \"' to a class property\");\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.allReturnsAreVoid = function (funcDecl) {\r\n            var allReturnsAreVoid = true;\r\n            if(funcDecl.signature.returnType.type == null) {\r\n                var preFindReturnExpressionTypes = function (ast, parent, walker) {\r\n                    var go = true;\r\n                    switch(ast.nodeType) {\r\n                        case TypeScript.NodeType.FuncDecl: {\r\n                            go = false;\r\n                            break;\r\n\r\n                        }\r\n                        case TypeScript.NodeType.Return: {\r\n                            var returnStmt = ast;\r\n                            if(returnStmt.returnExpression) {\r\n                                allReturnsAreVoid = false;\r\n                                go = false;\r\n                            }\r\n\r\n                        }\r\n                        default: {\r\n                            break;\r\n\r\n                        }\r\n                    }\r\n                    walker.options.goChildren = go;\r\n                    walker.options.goNextSibling = go;\r\n                    return ast;\r\n                };\r\n                TypeScript.getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);\r\n            }\r\n            return allReturnsAreVoid;\r\n        };\r\n        TypeFlow.prototype.classConstructorHasSuperCall = function (funcDecl) {\r\n            var foundSuper = false;\r\n            var preFindSuperCall = function (ast, parent, walker) {\r\n                var go = true;\r\n                switch(ast.nodeType) {\r\n                    case TypeScript.NodeType.FuncDecl: {\r\n                        go = false;\r\n                        break;\r\n\r\n                    }\r\n                    case TypeScript.NodeType.Call: {\r\n                        var call = ast;\r\n                        if(call.target.nodeType == TypeScript.NodeType.Super) {\r\n                            go = false;\r\n                            foundSuper = true;\r\n                            break;\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    default: {\r\n                        break;\r\n\r\n                    }\r\n                }\r\n                walker.options.goChildren = go;\r\n                return ast;\r\n            };\r\n            TypeScript.getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);\r\n            return foundSuper;\r\n        };\r\n        TypeFlow.prototype.typeCheckFunction = function (funcDecl) {\r\n            this.nestingLevel = 0;\r\n            var fnType = funcDecl.type;\r\n            var fgSym = fnType.symbol;\r\n            var signature = funcDecl.signature;\r\n            if(this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {\r\n                return funcDecl;\r\n            } else {\r\n                if(signature.typeCheckStatus == TypeScript.TypeCheckStatus.Started) {\r\n                    if(!funcDecl.returnTypeAnnotation && funcDecl.bod && !funcDecl.isSignature() && !(funcDecl.isConstructor) && this.allReturnsAreVoid(funcDecl)) {\r\n                        signature.returnType.type = this.voidType;\r\n                        return funcDecl;\r\n                    } else {\r\n                        if(funcDecl.returnTypeAnnotation == null) {\r\n                            if(this.checker.styleSettings.implicitAny) {\r\n                                this.checker.errorReporter.styleError(funcDecl, \"type implicitly set to 'any'\");\r\n                            }\r\n                            signature.returnType.type = this.anyType;\r\n                            fgSym.flags |= TypeScript.SymbolFlags.RecursivelyReferenced;\r\n                        }\r\n                        return funcDecl;\r\n                    }\r\n                }\r\n            }\r\n            signature.typeCheckStatus = TypeScript.TypeCheckStatus.Started;\r\n            this.checker.addStartedPTO(signature);\r\n            var prevScope = this.scope;\r\n            var prevFnc = this.thisFnc;\r\n            var prevMethodStatus = this.enclosingFncIsMethod;\r\n            var prevClassNode = this.thisClassNode;\r\n            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;\r\n            this.thisFnc = funcDecl;\r\n            var container = funcDecl.type.symbol;\r\n            var prevThisType = this.thisType;\r\n            var prevLocationInfo = this.checker.locationInfo;\r\n            var funcTable = null;\r\n            var setNewTargetType = false;\r\n            var targetParams = null;\r\n            var targetReturnType = null;\r\n            var isGetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.GetAccessor);\r\n            var isSetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.SetAccessor);\r\n            var accessorType = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;\r\n            var prevModDecl = this.checker.currentModDecl;\r\n            if(funcDecl.isConstructor && !funcDecl.isOverload) {\r\n                if(fnType.instanceType == null) {\r\n                    this.checker.errorReporter.simpleError(funcDecl, \"Malformed function body (is this a class named the same as an existing interface?)\");\r\n                    return funcDecl;\r\n                }\r\n                this.scope = fnType.instanceType.constructorScope;\r\n                var ssb = this.scope;\r\n                funcTable = ssb.valueMembers.allMembers;\r\n            } else {\r\n                if(funcDecl.isOverload) {\r\n                    funcTable = funcDecl.symbols;\r\n                    if(!TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.Static) && fnType.containedScope) {\r\n                        this.scope = fnType.containedScope;\r\n                    }\r\n                } else {\r\n                    if(funcDecl.bod) {\r\n                        this.scope = fnType.containedScope;\r\n                    }\r\n                    var ssb = this.scope;\r\n                    if(ssb && ssb.valueMembers) {\r\n                        funcTable = ssb.valueMembers.allMembers;\r\n                    }\r\n                }\r\n            }\r\n            if(funcDecl.isConstructor && funcDecl.bod && TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod)) {\r\n                var hasBaseType = TypeScript.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeScript.TypeFlags.HasBaseType);\r\n                var noSuperCallAllowed = !hasBaseType || TypeScript.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeScript.TypeFlags.HasBaseTypeOfObject);\r\n                var superCallMustBeFirst = TypeScript.hasFlag((funcDecl.classDecl).varFlags, TypeScript.VarFlags.ClassSuperMustBeFirstCallInConstructor);\r\n                if(noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {\r\n                    this.checker.errorReporter.simpleError(funcDecl, \"Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class\");\r\n                } else {\r\n                    if(hasBaseType) {\r\n                        if(superCallMustBeFirst) {\r\n                            if(!funcDecl.bod || !funcDecl.bod.members.length || !(funcDecl.bod.members[0].nodeType == TypeScript.NodeType.Call && (funcDecl.bod.members[0]).target.nodeType == TypeScript.NodeType.Super)) {\r\n                                this.checker.errorReporter.simpleError(funcDecl, \"If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor\");\r\n                            }\r\n                        } else {\r\n                            if(!this.classConstructorHasSuperCall(funcDecl)) {\r\n                                this.checker.errorReporter.simpleError(funcDecl, \"Constructors for derived classes must contain a call to the class's 'super' constructor\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(funcDecl.isMethod() && funcDecl.type.enclosingType) {\r\n                var enclosingClassNode = null;\r\n                if(funcDecl.type.enclosingType.symbol.declAST.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                    enclosingClassNode = (funcDecl.type.enclosingType.symbol.declAST).classDecl;\r\n                } else {\r\n                    if(funcDecl.type.enclosingType.symbol.declAST.nodeType == TypeScript.NodeType.Class) {\r\n                        enclosingClassNode = funcDecl.type.enclosingType.symbol.declAST;\r\n                    }\r\n                }\r\n                if(enclosingClassNode) {\r\n                    this.thisClassNode = enclosingClassNode;\r\n                }\r\n            }\r\n            if(fnType.enclosingType) {\r\n                ; ;\r\n                var enclosingSym = fnType.symbol.container;\r\n                if(enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {\r\n                    enclosingSym = enclosingSym.container;\r\n                }\r\n                if(enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType == TypeScript.NodeType.Module) {\r\n                    this.checker.currentModDecl = enclosingSym.declAST;\r\n                }\r\n            }\r\n            if(this.checker.units && (funcDecl.unitIndex >= 0) && (funcDecl.unitIndex < this.checker.units.length)) {\r\n                this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];\r\n            } else {\r\n                this.checker.locationInfo = TypeScript.unknownLocationInfo;\r\n            }\r\n            if(fnType.enclosingType) {\r\n                this.thisType = fnType.enclosingType;\r\n            } else {\r\n                this.thisType = prevThisType;\r\n            }\r\n            var paramLen = signature.parameters.length;\r\n            if(!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {\r\n                var tmpParamScope = this.scope;\r\n                var ssb = this.scope;\r\n                if(!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {\r\n                    if(prevScope && funcDecl.name && !funcDecl.name.isMissing()) {\r\n                        var considerSym = prevScope.findAmbient(funcDecl.name.text, false, false);\r\n                        if(considerSym && considerSym.declAST && considerSym.declAST.type) {\r\n                            this.checker.setContextualType(considerSym.declAST.type, false);\r\n                            setNewTargetType = true;\r\n                        }\r\n                    }\r\n                    if(this.checker.hasTargetType()) {\r\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\r\n                        var candidateType = candidateTypeContext.contextualType;\r\n                        if(this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {\r\n                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;\r\n                            candidateTypeContext.targetSig = candidateSigs.signatures[0];\r\n                            var candidateParams = candidateTypeContext.targetSig.parameters;\r\n                            targetParams = candidateParams;\r\n                            targetReturnType = candidateTypeContext.targetSig.returnType.type;\r\n                            if(candidateTypeContext.targetSig.declAST) {\r\n                                if(candidateTypeContext.targetSig.declAST.isConstructor) {\r\n                                    funcDecl.isTargetTypedAsMethod = true;\r\n                                } else {\r\n                                    if(candidateTypeContext.targetSig.declAST.isMethod()) {\r\n                                        funcDecl.isTargetTypedAsMethod = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            fgSym.type = candidateTypeContext.contextualType;\r\n                        } else {\r\n                            if(candidateType && funcDecl.isAccessor()) {\r\n                                accessorType = candidateType;\r\n                                candidateTypeContext.targetAccessorType = accessorType;\r\n                            } else {\r\n                                this.checker.killTargetType();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var paramTable = ssb.valueMembers;\r\n                this.scope = new TypeScript.SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);\r\n                for(var p = 0; p < paramLen; p++) {\r\n                    var param = signature.parameters[p];\r\n                    var symbol = param;\r\n                    var ast = symbol.declAST;\r\n                    if(this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {\r\n                        var candidateTypeContext = this.checker.getTargetTypeContext();\r\n                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;\r\n                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();\r\n                        ast.sym.setType(ast.type);\r\n                        (ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\r\n                    } else {\r\n                        this.typeCheck(ast);\r\n                    }\r\n                    if(isSetter && accessorType) {\r\n                        ast = this.cast(ast, accessorType);\r\n                    }\r\n                    symbol.container = container;\r\n                    paramTable.publicMembers.add(symbol.name, symbol);\r\n                }\r\n                this.scope = tmpParamScope;\r\n            } else {\r\n                this.typeCheck(funcDecl.args);\r\n                for(var p = 0; p < paramLen; p++) {\r\n                    signature.parameters[p].parameter.typeLink.type = funcDecl.args.members[p].type;\r\n                    if((funcDecl.args.members[p]).parameterPropertySym) {\r\n                        (funcDecl.args.members[p]).parameterPropertySym.setType(funcDecl.args.members[p].type);\r\n                    }\r\n                }\r\n                if((funcDecl.fncFlags & TypeScript.FncFlags.IndexerMember)) {\r\n                    if(!paramLen || paramLen > 1) {\r\n                        this.checker.errorReporter.simpleError(funcDecl, \"Index signatures may take only one parameter\");\r\n                    } else {\r\n                        if(funcDecl.args.members[0].type == this.checker.numberType) {\r\n                            fnType.index.flags |= TypeScript.SignatureFlags.IsNumberIndexer;\r\n                        } else {\r\n                            if(funcDecl.args.members[0].type == this.checker.stringType) {\r\n                                fnType.index.flags |= TypeScript.SignatureFlags.IsStringIndexer;\r\n                            } else {\r\n                                this.checker.errorReporter.simpleError(funcDecl, \"Index signatures may only take 'string' or 'number' as their parameter\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(funcDecl.bod && (!funcDecl.isSignature())) {\r\n                if(!(funcDecl.isConstructor)) {\r\n                    this.addFormals(container, signature, funcTable);\r\n                } else {\r\n                    this.addConstructorLocalArgs(funcDecl.type.symbol, funcDecl.args, funcTable, TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.ClassMethod));\r\n                    if(this.thisClassNode && this.thisClassNode.extendsList) {\r\n                        var tmpScope = this.scope;\r\n                        var funcMembers = new TypeScript.ScopedMembers(funcTable);\r\n                        this.scope = new TypeScript.FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol, function (sym) {\r\n                            return sym.kind() == TypeScript.SymbolKind.Parameter;\r\n                        });\r\n                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);\r\n                        this.scope = tmpScope;\r\n                    }\r\n                }\r\n                var prevMod = this.checker.currentModDecl;\r\n                if(funcDecl.type && funcDecl.type.symbol && !funcDecl.isMethod() && funcDecl.type.symbol.declModule) {\r\n                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;\r\n                }\r\n                this.typeCheck(funcDecl.bod);\r\n                this.checker.currentModDecl = prevMod;\r\n                if(this.checker.checkControlFlow) {\r\n                    var cfg = funcDecl.buildControlFlow();\r\n                    if(this.checker.printControlFlowGraph) {\r\n                        cfg.print(this.checker.errorReporter.outfile);\r\n                    }\r\n                    cfg.reportUnreachable(this.checker.errorReporter);\r\n                    if(this.checker.checkControlFlowUseDef) {\r\n                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);\r\n                    }\r\n                }\r\n                if(funcDecl.isConstructor) {\r\n                    var fns = funcDecl.scopes;\r\n                    var fnsLen = fns.members.length;\r\n                    var freeVars;\r\n                    var sym;\r\n                    var j = 0;\r\n                    for(; j < fnsLen; j++) {\r\n                        var fn = fns.members[j];\r\n                        if(!fn.isSignature()) {\r\n                            if(TypeScript.hasFlag(fn.fncFlags, TypeScript.FncFlags.Method) && (!TypeScript.hasFlag(fn.fncFlags, TypeScript.FncFlags.Static))) {\r\n                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.scope = prevScope;\r\n            this.thisFnc = prevFnc;\r\n            this.thisClassNode = prevClassNode;\r\n            this.enclosingFncIsMethod = prevMethodStatus;\r\n            this.thisType = prevThisType;\r\n            this.checker.locationInfo = prevLocationInfo;\r\n            this.checker.currentModDecl = prevModDecl;\r\n            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\r\n            if(funcDecl.returnTypeAnnotation) {\r\n                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);\r\n                if(signature.returnType.type == null) {\r\n                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);\r\n                }\r\n            } else {\r\n                if(targetReturnType) {\r\n                    signature.returnType.type = targetReturnType;\r\n                }\r\n            }\r\n            if(!(fgSym.flags & TypeScript.SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {\r\n                var collection = {\r\n                    getLength: function () {\r\n                        return funcDecl.returnStatementsWithExpressions.length;\r\n                    },\r\n                    setTypeAtIndex: function (index, type) {\r\n                        funcDecl.returnStatementsWithExpressions[index].type = type;\r\n                    },\r\n                    getTypeAtIndex: function (index) {\r\n                        return funcDecl.returnStatementsWithExpressions[index].type;\r\n                    }\r\n                };\r\n                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;\r\n                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection);\r\n                if(bestCommonReturnType) {\r\n                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);\r\n                } else {\r\n                    for(var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {\r\n                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], \"Incompatible return type\");\r\n                    }\r\n                    signature.returnType.type = this.anyType;\r\n                }\r\n            }\r\n            if(signature.returnType.type == null) {\r\n                if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.HasReturnExpression)) {\r\n                    if(this.checker.styleSettings.implicitAny) {\r\n                        this.checker.errorReporter.styleError(funcDecl, \"type implicitly set to 'any'\");\r\n                    }\r\n                    signature.returnType.type = this.anyType;\r\n                } else {\r\n                    signature.returnType.type = this.voidType;\r\n                }\r\n            } else {\r\n                if(signature.returnType.type == this.nullType || signature.returnType.type == this.checker.undefinedType) {\r\n                    signature.returnType.type = this.anyType;\r\n                } else {\r\n                    if((signature.returnType.type != this.voidType && signature.returnType.type != this.checker.undefinedType && signature.returnType.type != this.anyType) && funcDecl.returnTypeAnnotation) {\r\n                        if(!funcDecl.isSignature() && !funcDecl.isConstructor && !TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.HasReturnExpression) && !TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.IsFatArrowFunction)) {\r\n                            var onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == TypeScript.NodeType.Throw);\r\n                            if(!onlyHasThrow) {\r\n                                this.checker.errorReporter.simpleError(funcDecl, \"Function declared a non-void return type, but has no return expression\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(setNewTargetType) {\r\n                this.checker.unsetContextualType();\r\n            }\r\n            if(funcDecl.accessorSymbol) {\r\n                var accessorType = funcDecl.accessorSymbol.getType();\r\n                if(accessorType) {\r\n                    if((TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.GetAccessor) && accessorType != signature.returnType.type) || (funcDecl.args.members.length > 0 && accessorType != funcDecl.args.members[0].type)) {\r\n                        this.checker.errorReporter.simpleError(funcDecl, \"Getter and setter types do not agree\");\r\n                    }\r\n                } else {\r\n                    if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.GetAccessor)) {\r\n                        funcDecl.accessorSymbol.setType(signature.returnType.type);\r\n                    } else {\r\n                        if(funcDecl.args.members.length != 1) {\r\n                            this.checker.errorReporter.simpleError(funcDecl, \"Setters may have one and only one argument\");\r\n                        } else {\r\n                            funcDecl.accessorSymbol.setType(funcDecl.args.members[0].type);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.typeCheckOverloadSignatures(fnType, funcDecl);\r\n            return funcDecl;\r\n        };\r\n        TypeFlow.prototype.typeCheckBases = function (type) {\r\n            var seenInterface = false;\r\n            var bases = type.extendsList;\r\n            if(bases) {\r\n                var len = bases.length;\r\n                this.inNewTargetTypeCheck = true;\r\n                if(len > 0) {\r\n                    type.typeFlags |= TypeScript.TypeFlags.HasBaseType;\r\n                }\r\n                for(var i = 0; i < len; i++) {\r\n                    var base = bases[i];\r\n                    var baseTypeOfObject = base.symbol && base.symbol.name == \"Object\" && base.symbol.container == this.checker.gloMod;\r\n                    if(baseTypeOfObject) {\r\n                        type.typeFlags |= TypeScript.TypeFlags.HasBaseTypeOfObject;\r\n                    }\r\n                    if(base.isClassInstance()) {\r\n                        if(type.isClassInstance() && !this.checker.typeStatusIsFinished(base.symbol.typeCheckStatus) && base.symbol.declAST) {\r\n                            this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Base type '\" + base.symbol.name + \"' is referenced before its declaration\");\r\n                            this.typeCheck(base.symbol.declAST);\r\n                        }\r\n                        if(this.currentScript) {\r\n                            this.currentScript.requiresInherits = true;\r\n                        }\r\n                        if(!(type.isClassInstance())) {\r\n                            this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Interface base type must be interface\");\r\n                        } else {\r\n                            if(seenInterface) {\r\n                                this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Class may not follow interface as base type\");\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if(base.isModuleType()) {\r\n                            this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Types may not be derived from module types\");\r\n                        } else {\r\n                            if(base.members) {\r\n                                if(!seenInterface) {\r\n                                    seenInterface = true;\r\n                                }\r\n                            } else {\r\n                                if(!(type.isClassInstance())) {\r\n                                    this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Interface base type must be interface\");\r\n                                } else {\r\n                                    this.checker.errorReporter.simpleErrorFromSym(base.symbol, \"Base type must be interface or class\");\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.inNewTargetTypeCheck = false;\r\n            }\r\n        };\r\n        TypeFlow.prototype.checkMembersImplementInterfaces = function (implementingType) {\r\n            var instanceType = implementingType.getInstanceType();\r\n            if(instanceType.implementsList) {\r\n                var len = instanceType.implementsList.length;\r\n                this.inNewTargetTypeCheck = true;\r\n                for(var i = 0; i < len; i++) {\r\n                    var interfaceType = instanceType.implementsList[i];\r\n                    var comparisonInfo = new TypeScript.TypeComparisonInfo();\r\n                    if(!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {\r\n                        var emsg = \"Class '\" + instanceType.getTypeName() + \"' declares interface '\" + interfaceType.getTypeName() + \"' but does not implement it\";\r\n                        if(!comparisonInfo.message) {\r\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);\r\n                        } else {\r\n                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + \": \" + comparisonInfo.message);\r\n                        }\r\n                    }\r\n                }\r\n                this.inNewTargetTypeCheck = false;\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckBaseCalls = function (bases) {\r\n            if(bases == null) {\r\n                return;\r\n            }\r\n            var basesLen = bases.members.length;\r\n            for(var i = 0; i < basesLen; i++) {\r\n                var baseExpr = bases.members[i];\r\n                var baseSymbol = null;\r\n                if(baseExpr.nodeType == TypeScript.NodeType.Call) {\r\n                    this.typeCheckNew(baseExpr);\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.assertUniqueNamesInBaseTypes = function (names, type, classDecl, checkUnique) {\r\n            var _this = this;\r\n            if(type) {\r\n                if(type.members) {\r\n                    type.members.publicMembers.map(function (key, s, c) {\r\n                        var sym = s;\r\n                        var dup = names.lookup(sym.name);\r\n                        if(dup) {\r\n                            if(checkUnique) {\r\n                                _this.checker.errorReporter.simpleError(classDecl, \"duplicate member name in bases for \" + classDecl.name.text + \": \" + type.symbol.name + \" and \" + dup.container.name + \" both contain member with name \" + sym.name);\r\n                            }\r\n                        } else {\r\n                            names.add(sym.name, sym);\r\n                        }\r\n                    }, null);\r\n                }\r\n                if(type.extendsList) {\r\n                    var len = type.extendsList.length;\r\n                    for(var i = 0; i < len; i++) {\r\n                        if(!(type.extendsList[i].symbol.flags & TypeScript.SymbolFlags.RecursivelyReferenced)) {\r\n                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.checkBaseTypeMemberInheritance = function (derivedType, derivedTypeDecl) {\r\n            var _this = this;\r\n            var instanceType = derivedType.getInstanceType();\r\n            if(instanceType.extendsList == null) {\r\n                return;\r\n            }\r\n            var len = instanceType.extendsList.length;\r\n            if(len > 0) {\r\n                var names = new TypeScript.StringHashTable();\r\n                if(instanceType.isClassInstance()) {\r\n                    for(var i = 0; i < len; i++) {\r\n                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], derivedTypeDecl, i > 0);\r\n                    }\r\n                }\r\n                if(instanceType.members) {\r\n                    instanceType.members.publicMembers.map(function (key, s, c) {\r\n                        var sym = s;\r\n                        for(var j = 0; j < len; j++) {\r\n                            var base = instanceType.extendsList[j];\r\n                            if(base.memberScope == null) {\r\n                                _this.checker.errorReporter.simpleError(derivedTypeDecl, \"Base type '\" + base.symbol.name + \"' lacks an implementation.\");\r\n                            } else {\r\n                                var bSym = base.memberScope.find(sym.name, false, false);\r\n                                if(bSym) {\r\n                                    var aType = sym.getType();\r\n                                    var bType = bSym.getType();\r\n                                    if(!(_this.checker.sourceIsSubtypeOfTarget(aType, bType))) {\r\n                                        _this.checker.errorReporter.simpleErrorFromSym(sym, \"Type of overridden member '\" + sym.name + \"' is not subtype of original member defined by type '\" + bSym.container.name + \"'\");\r\n                                    } else {\r\n                                        if((sym.kind() == TypeScript.SymbolKind.Type) && (bSym.kind() == TypeScript.SymbolKind.Field)) {\r\n                                            _this.checker.errorReporter.simpleErrorFromSym(sym, \"Cannot override field '\" + sym.name + \"' with method\");\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }, null);\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckClass = function (classDecl) {\r\n            var typeSymbol = classDecl.type.symbol;\r\n            if(typeSymbol.typeCheckStatus == TypeScript.TypeCheckStatus.Finished) {\r\n                return classDecl;\r\n            } else {\r\n                if(typeSymbol.typeCheckStatus == TypeScript.TypeCheckStatus.Started) {\r\n                    return classDecl;\r\n                } else {\r\n                    typeSymbol.typeCheckStatus = TypeScript.TypeCheckStatus.Started;\r\n                    this.checker.addStartedPTO(typeSymbol);\r\n                }\r\n            }\r\n            var prevScope = this.scope;\r\n            var svClassNode = this.thisClassNode;\r\n            this.thisClassNode = classDecl;\r\n            var classType = classDecl.type;\r\n            this.typeCheckBases(classType.instanceType);\r\n            var prevThisType = this.thisType;\r\n            this.thisType = classType.instanceType;\r\n            this.scope = classType.instanceType.containedScope;\r\n            if(classDecl.constructorDecl) {\r\n                this.scope = classType.instanceType.constructorScope;\r\n                var ssb = this.scope;\r\n                var funcTable = ssb.valueMembers.allMembers;\r\n                this.addConstructorLocalArgs(classDecl.constructorDecl.type.symbol, classDecl.constructorDecl.args, funcTable, true);\r\n            }\r\n            this.typeCheck(classDecl.members);\r\n            typeSymbol.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;\r\n            this.checkBaseTypeMemberInheritance(classType, classDecl);\r\n            this.checkMembersImplementInterfaces(classType);\r\n            this.typeCheckOverloadSignatures(classType, classDecl);\r\n            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);\r\n            if(!classDecl.constructorDecl) {\r\n                if(classDecl.baseClass && classDecl.baseClass.members.length && classDecl.baseClass.members[0].type && classDecl.baseClass.members[0].type.symbol.type.isClass()) {\r\n                    TypeScript.cloneParentConstructGroupForChildType(classDecl.type, classDecl.baseClass.members[0].type.symbol.type);\r\n                }\r\n            }\r\n            this.thisType = prevThisType;\r\n            this.thisClassNode = svClassNode;\r\n            this.scope = prevScope;\r\n            return classDecl;\r\n        };\r\n        TypeFlow.prototype.typeCheckOverloadSignatures = function (type, ast) {\r\n            if(type.call) {\r\n                type.call.typeCheck(this.checker, ast, type.construct != null);\r\n            }\r\n            if(type.construct) {\r\n                type.construct.typeCheck(this.checker, ast, false);\r\n            }\r\n            if(type.index) {\r\n                type.index.typeCheck(this.checker, ast, false);\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckInterface = function (interfaceDecl) {\r\n            this.typeCheckBases(interfaceDecl.type);\r\n            this.typeCheck(interfaceDecl.members);\r\n            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);\r\n            if(interfaceDecl.extendsList) {\r\n                for(var i = 0; i < interfaceDecl.extendsList.members.length; i++) {\r\n                    if(interfaceDecl.extendsList.members[i].type.call) {\r\n                        if(interfaceDecl.type.call) {\r\n                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);\r\n                        } else {\r\n                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;\r\n                        }\r\n                    }\r\n                    if(interfaceDecl.extendsList.members[i].type.construct) {\r\n                        if(interfaceDecl.type.construct) {\r\n                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);\r\n                        } else {\r\n                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;\r\n                        }\r\n                    }\r\n                    if(interfaceDecl.extendsList.members[i].type.index) {\r\n                        if(interfaceDecl.type.index) {\r\n                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);\r\n                        } else {\r\n                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return interfaceDecl;\r\n        };\r\n        TypeFlow.prototype.typeCheckImportDecl = function (importDecl) {\r\n            var mod = importDecl.alias.type;\r\n            var sym = null;\r\n            var prevInImportTC = this.inImportTypeCheck;\r\n            this.inImportTypeCheck = true;\r\n            this.typeCheck(importDecl.alias);\r\n            mod = importDecl.alias.type;\r\n            if(mod == null) {\r\n                this.checker.errorReporter.simpleError(importDecl.alias, \"Could not resolve module alias '\" + importDecl.id.text + \"'\");\r\n                mod = this.checker.anyType;\r\n                (importDecl.id.sym).type = mod;\r\n            }\r\n            importDecl.id.type = mod;\r\n            sym = mod.symbol;\r\n            if(!mod.isModuleType()) {\r\n                this.checker.errorReporter.simpleError(importDecl.alias, \"A module cannot be aliased to a non-module type\");\r\n            } else {\r\n                sym.type = mod;\r\n                if(this.checker.currentModDecl && this.checker.currentModDecl.mod) {\r\n                    this.checker.currentModDecl.mod.importedModules.push(importDecl);\r\n                }\r\n                (importDecl.id.sym).type = mod;\r\n                if(mod.symbol && mod.symbol.declAST) {\r\n                    (mod.symbol.declAST).modFlags &= ~TypeScript.ModuleFlags.ShouldEmitModuleDecl;\r\n                }\r\n            }\r\n            this.inImportTypeCheck = prevInImportTC;\r\n            return importDecl;\r\n        };\r\n        TypeFlow.prototype.typeCheckModule = function (moduleDecl) {\r\n            if(!moduleDecl.mod) {\r\n                return moduleDecl;\r\n            }\r\n            if(this.currentScript) {\r\n                this.currentScript.requiresGlobal = true;\r\n            }\r\n            var mod = moduleDecl.mod;\r\n            var sym = null;\r\n            var prevScope = this.scope;\r\n            var prevThisType = this.thisType;\r\n            var prevCurrentModDecl = this.checker.currentModDecl;\r\n            this.checker.currentModDecl = moduleDecl;\r\n            if(!this.inImportTypeCheck && prevCurrentModDecl && TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.IsDynamic) && !TypeScript.hasFlag(moduleDecl.modFlags, TypeScript.ModuleFlags.Ambient)) {\r\n                this.checker.errorReporter.simpleError(moduleDecl, \"Dynamic modules may not be nested within other modules\");\r\n            }\r\n            this.thisType = null;\r\n            this.scope = mod.containedScope;\r\n            this.typeCheck(moduleDecl.members);\r\n            sym = mod.symbol;\r\n            this.checker.currentModDecl = prevCurrentModDecl;\r\n            this.thisType = prevThisType;\r\n            this.scope = prevScope;\r\n            moduleDecl.type = mod;\r\n            if(sym) {\r\n                sym.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;\r\n            }\r\n            return moduleDecl;\r\n        };\r\n        TypeFlow.prototype.typeCheckFor = function (forStmt) {\r\n            forStmt.init = this.typeCheck(forStmt.init);\r\n            this.nestingLevel++;\r\n            forStmt.cond = this.typeCheck(forStmt.cond);\r\n            this.typeCheckCondExpr(forStmt.cond);\r\n            forStmt.incr = this.typeCheck(forStmt.incr);\r\n            this.nestingLevel--;\r\n            forStmt.body = this.typeCheck(forStmt.body);\r\n            this.typeCheckCompoundStmtBlock(forStmt.body, \"for statement\");\r\n            forStmt.type = this.voidType;\r\n            return forStmt;\r\n        };\r\n        TypeFlow.prototype.typeCheckWith = function (withStmt) {\r\n            if(this.checker.errorsOnWith) {\r\n                this.checker.errorReporter.simpleError(withStmt.expr, \"All symbols within a 'with' block will be typed as 'any'\");\r\n            }\r\n            withStmt.expr = this.typeCheck(withStmt.expr);\r\n            this.checker.inWith = true;\r\n            withStmt.body = this.typeCheck(withStmt.body);\r\n            this.typeCheckCompoundStmtBlock(withStmt.body, \"with statement\");\r\n            this.checker.inWith = false;\r\n            return withStmt;\r\n        };\r\n        TypeFlow.prototype.typeCheckForIn = function (forInStmt) {\r\n            forInStmt.obj = this.typeCheck(forInStmt.obj);\r\n            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);\r\n            if(forInStmt.lval.nodeType == TypeScript.NodeType.VarDecl) {\r\n                var varDecl = forInStmt.lval;\r\n                if(varDecl.typeExpr) {\r\n                    this.checker.errorReporter.simpleError(varDecl, \"Variable declarations for for/in expressions may not contain a type annotation\");\r\n                }\r\n                if(varDecl.sym) {\r\n                    varDecl.sym.setType(this.checker.stringType);\r\n                }\r\n            }\r\n            forInStmt.body = this.typeCheck(forInStmt.body);\r\n            this.typeCheckCompoundStmtBlock(forInStmt.body, \"for in statement\");\r\n            return forInStmt;\r\n        };\r\n        TypeFlow.prototype.typeCheckWhile = function (whileStmt) {\r\n            whileStmt.cond = this.typeCheck(whileStmt.cond);\r\n            this.typeCheckCondExpr(whileStmt.cond);\r\n            whileStmt.body = this.typeCheck(whileStmt.body);\r\n            this.typeCheckCompoundStmtBlock(whileStmt.body, \"while statement\");\r\n            whileStmt.type = this.voidType;\r\n            return whileStmt;\r\n        };\r\n        TypeFlow.prototype.typeCheckDoWhile = function (doWhileStmt) {\r\n            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);\r\n            this.typeCheckCondExpr(doWhileStmt.cond);\r\n            doWhileStmt.body = this.typeCheck(doWhileStmt.body);\r\n            this.typeCheckCompoundStmtBlock(doWhileStmt.body, \"do while statement\");\r\n            doWhileStmt.type = this.voidType;\r\n            return doWhileStmt;\r\n        };\r\n        TypeFlow.prototype.typeCheckCondExpr = function (cond) {\r\n            if(this.checker.styleSettings.assignmentInCond) {\r\n                if((cond !== null) && (cond.nodeType >= TypeScript.NodeType.Asg) && (cond.nodeType <= TypeScript.NodeType.LastAsg)) {\r\n                    this.checker.errorReporter.simpleError(cond, \"top-level assignment statement in conditional expression\");\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckCompoundStmtBlock = function (stmts, stmtType) {\r\n            if(this.checker.styleSettings.blockInCompoundStmt && stmts) {\r\n                if(stmts.nodeType != TypeScript.NodeType.Block) {\r\n                    this.checker.errorReporter.styleError(stmts, stmtType + \" requires a block\");\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckIf = function (ifStmt) {\r\n            ifStmt.cond = this.typeCheck(ifStmt.cond);\r\n            this.typeCheckCondExpr(ifStmt.cond);\r\n            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);\r\n            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);\r\n            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, \"if statement\");\r\n            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, \"if statement\");\r\n            ifStmt.type = this.voidType;\r\n            return ifStmt;\r\n        };\r\n        TypeFlow.prototype.typeFromAccessorFuncDecl = function (funcDecl) {\r\n            if(!funcDecl.isAccessor()) {\r\n                return null;\r\n            }\r\n            if(TypeScript.hasFlag(funcDecl.fncFlags, TypeScript.FncFlags.GetAccessor)) {\r\n                return funcDecl.type.call.signatures[0].returnType.type;\r\n            } else {\r\n                return funcDecl.type.call.signatures[0].parameters[0].getType();\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckObjectLit = function (objectLit) {\r\n            var resultType = new TypeScript.Type();\r\n            resultType.symbol = new TypeScript.TypeSymbol(this.checker.anon, objectLit.minChar, this.checker.locationInfo.unitIndex, resultType);\r\n            resultType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n            resultType.memberScope = new TypeScript.SymbolTableScope(resultType.members, null, null, null, null);\r\n            var aggScope = new TypeScript.SymbolAggregateScope(resultType.symbol);\r\n            aggScope.addParentScope(resultType.memberScope);\r\n            aggScope.addParentScope(this.scope);\r\n            resultType.containedScope = aggScope;\r\n            var memberDecls = objectLit.operand;\r\n            var prevThisType = this.thisType;\r\n            var acceptTargetType = false;\r\n            var targetType = null;\r\n            if(this.checker.hasTargetType()) {\r\n                targetType = this.checker.getTargetTypeContext().contextualType;\r\n                if(targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {\r\n                    if(targetType.symbol.declAST) {\r\n                        this.typeCheck(targetType.symbol.declAST);\r\n                    }\r\n                }\r\n                acceptTargetType = true;\r\n            }\r\n            if(memberDecls) {\r\n                for(var i = 0, len = memberDecls.members.length; i < len; i++) {\r\n                    var binex = memberDecls.members[i];\r\n                    var id = binex.operand1;\r\n                    var text;\r\n                    var targetMember = null;\r\n                    var fieldSymbol = null;\r\n                    if(id.nodeType == TypeScript.NodeType.Name) {\r\n                        text = (id).text;\r\n                    } else {\r\n                        if(id.nodeType == TypeScript.NodeType.QString) {\r\n                            var idText = (id).text;\r\n                            text = idText.substring(1, idText.length - 1);\r\n                        } else {\r\n                            this.checker.errorReporter.simpleError(objectLit, \"malformed object literal\");\r\n                            resultType = this.anyType;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(acceptTargetType && targetType.memberScope) {\r\n                        targetMember = targetType.memberScope.find(text, false, false);\r\n                    }\r\n                    if(binex.operand2.nodeType == TypeScript.NodeType.FuncDecl && (binex.operand2).isAccessor()) {\r\n                        var funcDecl = binex.operand2;\r\n                        var accessorSym = resultType.members.publicMembers.lookup(text);\r\n                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);\r\n                        funcDecl.accessorSymbol = accessorSym;\r\n                        fieldSymbol = accessorSym;\r\n                        if(id.nodeType == TypeScript.NodeType.Name) {\r\n                            (id).sym = accessorSym;\r\n                        }\r\n                    }\r\n                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);\r\n                    if(acceptTargetType && targetMember) {\r\n                        if((binex.operand2.type == this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) || (binex.operand2.nodeType == TypeScript.NodeType.FuncDecl && (binex.operand2).isAccessor() && this.typeFromAccessorFuncDecl(binex.operand2) == targetMember.getType())) {\r\n                            binex.operand1.type = targetMember.getType();\r\n                        }\r\n                    } else {\r\n                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;\r\n                    }\r\n                    if(fieldSymbol == null) {\r\n                        var memberType = binex.operand2.type;\r\n                        var field = new TypeScript.ValueLocation();\r\n                        fieldSymbol = new TypeScript.FieldSymbol(text, id.minChar, this.checker.locationInfo.unitIndex, true, field);\r\n                        fieldSymbol.flags |= TypeScript.SymbolFlags.Property;\r\n                        field.symbol = fieldSymbol;\r\n                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();\r\n                        field.typeLink = new TypeScript.TypeLink();\r\n                        field.typeLink.type = memberType;\r\n                        resultType.members.publicMembers.add(text, fieldSymbol);\r\n                    }\r\n                    fieldSymbol.isObjectLitField = true;\r\n                }\r\n            }\r\n            this.thisType = prevThisType;\r\n            objectLit.type = resultType;\r\n            if(targetType) {\r\n                objectLit.targetType = targetType;\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckArrayLit = function (arrayLit) {\r\n            var elements = arrayLit.operand;\r\n            var elementType = this.anyType;\r\n            var targetElementType = null;\r\n            var comparisonInfo = new TypeScript.TypeComparisonInfo();\r\n            comparisonInfo.onlyCaptureFirstError = true;\r\n            if(this.checker.hasTargetType()) {\r\n                var targetType = this.checker.getTargetTypeContext().contextualType;\r\n                if(targetType.elementType) {\r\n                    targetElementType = targetType.elementType;\r\n                }\r\n            }\r\n            if(elements) {\r\n                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;\r\n                this.inArrayElementTypeCheck = true;\r\n                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements);\r\n                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;\r\n                elementType = elements.members[0].type;\r\n                var collection = {\r\n                    getLength: function () {\r\n                        return elements.members.length;\r\n                    },\r\n                    setTypeAtIndex: function (index, type) {\r\n                        elements.members[index].type = type;\r\n                    },\r\n                    getTypeAtIndex: function (index) {\r\n                        return elements.members[index].type;\r\n                    }\r\n                };\r\n                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, comparisonInfo);\r\n                if(elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {\r\n                    elementType = this.anyType;\r\n                }\r\n            }\r\n            if(!elementType) {\r\n                var emsg = \"Incompatible types in array literal expression\";\r\n                if(!comparisonInfo.message) {\r\n                    this.checker.errorReporter.simpleError(arrayLit, emsg);\r\n                } else {\r\n                    this.checker.errorReporter.simpleError(arrayLit, emsg + \": \" + comparisonInfo.message);\r\n                }\r\n                elementType = this.anyType;\r\n            } else {\r\n                if(targetElementType) {\r\n                    if(this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {\r\n                        elementType = targetElementType;\r\n                    }\r\n                }\r\n            }\r\n            arrayLit.type = this.checker.makeArrayType(elementType);\r\n        };\r\n        TypeFlow.prototype.checkForVoidConstructor = function (type, ast) {\r\n            if(type && type.construct && type.construct.signatures.length > 0) {\r\n                for(var i = 0; i < type.construct.signatures.length; i++) {\r\n                    if(type.construct.signatures[i].returnType.type == this.checker.voidType) {\r\n                        this.checker.errorReporter.simpleError(ast, \"Constructors may not have a return type of 'void'\");\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckReturn = function (returnStmt) {\r\n            if(this.thisFnc) {\r\n                var targetType = null;\r\n                if(this.checker.hasTargetType()) {\r\n                    var tcContext = this.checker.getTargetTypeContext();\r\n                    var accessorType = tcContext.targetAccessorType;\r\n                    if(accessorType) {\r\n                        targetType = accessorType;\r\n                    } else {\r\n                        var targetSig = this.checker.getTargetTypeContext().targetSig;\r\n                        if(targetSig && targetSig.returnType.type != this.voidType) {\r\n                            targetType = targetSig.returnType.type;\r\n                        }\r\n                    }\r\n                }\r\n                if(returnStmt.returnExpression) {\r\n                    this.thisFnc.fncFlags |= TypeScript.FncFlags.HasReturnExpression;\r\n                    if(targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {\r\n                        targetType = this.thisFnc.returnTypeAnnotation.type;\r\n                    }\r\n                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType != null, returnStmt.returnExpression);\r\n                    var expectedReturnType = (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : targetType;\r\n                    if(expectedReturnType) {\r\n                        if(expectedReturnType == this.voidType && returnStmt.returnExpression.type != this.voidType) {\r\n                            this.checker.errorReporter.simpleError(returnStmt, \"Return with value expression in void function\");\r\n                            returnStmt.type = returnStmt.returnExpression.type;\r\n                        } else {\r\n                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);\r\n                            returnStmt.type = expectedReturnType;\r\n                        }\r\n                    } else {\r\n                        if(targetType) {\r\n                            if(returnStmt.returnExpression.type != this.voidType) {\r\n                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);\r\n                            } else {\r\n                                returnStmt.returnExpression.type = targetType;\r\n                            }\r\n                        }\r\n                        returnStmt.type = returnStmt.returnExpression.type;\r\n                    }\r\n                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;\r\n                } else {\r\n                    returnStmt.type = targetType == null ? this.checker.voidType : targetType;\r\n                }\r\n            }\r\n            return returnStmt;\r\n        };\r\n        TypeFlow.prototype.typeCheckInstOf = function (ast) {\r\n            var binex = ast;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            if(!((binex.operand1.type == this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) && (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {\r\n                this.checker.errorReporter.simpleError(ast, \"The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type\");\r\n            }\r\n            binex.type = this.booleanType;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckCommaOperator = function (ast) {\r\n            var binex = ast;\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            binex.type = binex.operand2.type;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckLogOr = function (binex) {\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            var leftType = binex.operand1.type;\r\n            var rightType = binex.operand2.type;\r\n            if(leftType == this.checker.anyType || rightType == this.checker.anyType) {\r\n                binex.type = this.checker.anyType;\r\n            } else {\r\n                if(leftType == this.checker.booleanType) {\r\n                    if(rightType == this.checker.booleanType) {\r\n                        binex.type = this.checker.booleanType;\r\n                    } else {\r\n                        binex.type = this.checker.anyType;\r\n                    }\r\n                } else {\r\n                    if(leftType == this.checker.numberType) {\r\n                        if(rightType == this.checker.numberType) {\r\n                            binex.type = this.checker.numberType;\r\n                        } else {\r\n                            binex.type = this.checker.anyType;\r\n                        }\r\n                    } else {\r\n                        if(leftType == this.checker.stringType) {\r\n                            if(rightType == this.checker.stringType) {\r\n                                binex.type = this.checker.stringType;\r\n                            } else {\r\n                                binex.type = this.checker.anyType;\r\n                            }\r\n                        } else {\r\n                            if(this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {\r\n                                binex.type = rightType;\r\n                            } else {\r\n                                if(this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {\r\n                                    binex.type = leftType;\r\n                                } else {\r\n                                    binex.type = this.checker.anyType;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.typeCheckLogAnd = function (binex) {\r\n            binex.operand1 = this.typeCheck(binex.operand1);\r\n            binex.operand2 = this.typeCheck(binex.operand2);\r\n            binex.type = binex.operand2.type;\r\n            return binex;\r\n        };\r\n        TypeFlow.prototype.tryAddCandidates = function (signature, actuals, exactCandidates, conversionCandidates, comparisonInfo) {\r\n            var lowerBound = signature.nonOptionalParameterCount;\r\n            var upperBound = signature.parameters.length;\r\n            var formalLen = lowerBound;\r\n            var acceptable = false;\r\n            if((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {\r\n                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);\r\n                acceptable = true;\r\n            }\r\n            var repeatType = null;\r\n            if(acceptable || signature.hasVariableArgList) {\r\n                if(signature.hasVariableArgList) {\r\n                    formalLen -= 1;\r\n                    repeatType = (signature.parameters[formalLen]).parameter.typeLink.type;\r\n                    repeatType = repeatType.elementType;\r\n                    acceptable = actuals.length >= formalLen;\r\n                }\r\n                var len = actuals.length;\r\n                var exact = acceptable;\r\n                var convert = acceptable;\r\n                for(var i = 0; i < len; i++) {\r\n                    var typeA;\r\n                    if(i < formalLen) {\r\n                        typeA = (signature.parameters[i]).parameter.typeLink.type;\r\n                    } else {\r\n                        typeA = repeatType;\r\n                    }\r\n                    var typeB = actuals[i];\r\n                    if(!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {\r\n                        exact = false;\r\n                    }\r\n                    if(!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {\r\n                        convert = false;\r\n                    }\r\n                    if(!(exact || convert)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if(exact) {\r\n                    exactCandidates[exactCandidates.length] = signature;\r\n                } else {\r\n                    if(convert && (exactCandidates.length == 0)) {\r\n                        conversionCandidates[conversionCandidates.length] = signature;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.resolveOverload = function (application, group) {\r\n            var rd = this.resolutionDataCache.getResolutionData();\r\n            var actuals = rd.actuals;\r\n            var exactCandidates = rd.exactCandidates;\r\n            var conversionCandidates = rd.conversionCandidates;\r\n            var candidate = null;\r\n            var hasOverloads = group.signatures.length > 1;\r\n            var comparisonInfo = new TypeScript.TypeComparisonInfo();\r\n            var args = null;\r\n            var target = null;\r\n            if(application.nodeType == TypeScript.NodeType.Call || application.nodeType == TypeScript.NodeType.New) {\r\n                var callEx = application;\r\n                args = callEx.args;\r\n                target = callEx.target;\r\n                if(callEx.args) {\r\n                    var len = callEx.args.members.length;\r\n                    for(var i = 0; i < len; i++) {\r\n                        actuals[i] = callEx.args.members[i].type;\r\n                    }\r\n                }\r\n            } else {\r\n                if(application.nodeType == TypeScript.NodeType.Index) {\r\n                    var binExp = application;\r\n                    target = binExp.operand1;\r\n                    args = new TypeScript.ASTList();\r\n                    args.members[0] = binExp.operand2;\r\n                    actuals[0] = binExp.operand2.type;\r\n                }\r\n            }\r\n            for(var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {\r\n                var signature = group.signatures[j];\r\n                if(hasOverloads && signature == group.definitionSignature && !this.checker.canCallDefinitionSignature) {\r\n                    continue;\r\n                }\r\n                if(!signature.returnType.type && signature.declAST && (signature.typeCheckStatus != TypeScript.TypeCheckStatus.Finished)) {\r\n                    this.typeCheckFunction(signature.declAST);\r\n                }\r\n                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);\r\n            }\r\n            if(exactCandidates.length == 0) {\r\n                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);\r\n                if(applicableCandidates.length > 0) {\r\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);\r\n                    if(candidateInfo.ambiguous) {\r\n                        this.checker.errorReporter.simpleError(target, \"Ambiguous call expression - could not choose overload\");\r\n                    }\r\n                    candidate = candidateInfo.sig;\r\n                } else {\r\n                    var emsg = \"Supplied parameters do not match any signature of call target\";\r\n                    if(comparisonInfo.message) {\r\n                        this.checker.errorReporter.simpleError(target, emsg + \":\\n\\t\" + comparisonInfo.message);\r\n                    } else {\r\n                        this.checker.errorReporter.simpleError(target, emsg);\r\n                    }\r\n                }\r\n            } else {\r\n                if(exactCandidates.length > 1) {\r\n                    var applicableSigs = [];\r\n                    for(var i = 0; i < exactCandidates.length; i++) {\r\n                        applicableSigs[i] = {\r\n                            signature: exactCandidates[i],\r\n                            hadProvisionalErrors: false\r\n                        };\r\n                    }\r\n                    var candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);\r\n                    if(candidateInfo.ambiguous) {\r\n                        this.checker.errorReporter.simpleError(target, \"Ambiguous call expression - could not choose overload\");\r\n                    }\r\n                    candidate = candidateInfo.sig;\r\n                } else {\r\n                    candidate = exactCandidates[0];\r\n                }\r\n            }\r\n            this.resolutionDataCache.returnResolutionData(rd);\r\n            return candidate;\r\n        };\r\n        TypeFlow.prototype.typeCheckNew = function (ast) {\r\n            var callEx = ast;\r\n            callEx.target = this.typeCheck(callEx.target);\r\n            var target = callEx.target;\r\n            if(target.type.construct || target.type.call) {\r\n                this.preTypeCheckCallArgs(callEx.args);\r\n            } else {\r\n                callEx.args = this.typeCheck(callEx.args);\r\n            }\r\n            if(target.type == this.anyType) {\r\n                callEx.type = this.anyType;\r\n                callEx.args = this.typeCheck(callEx.args);\r\n            } else {\r\n                if(target.type.construct) {\r\n                    var signature = this.resolveOverload(callEx, target.type.construct);\r\n                    if(signature == null) {\r\n                        callEx.type = this.anyType;\r\n                    } else {\r\n                        if(signature.returnType.type == this.voidType) {\r\n                            callEx.type = this.anyType;\r\n                            callEx.signature = signature;\r\n                        } else {\r\n                            callEx.type = signature.returnType.type;\r\n                            callEx.signature = signature;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if(target.type.call) {\r\n                        var signature = this.resolveOverload(callEx, target.type.call);\r\n                        if(signature == null) {\r\n                            callEx.type = this.anyType;\r\n                        } else {\r\n                            if((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {\r\n                                callEx.type = this.anyType;\r\n                                callEx.signature = signature;\r\n                            } else {\r\n                                this.checker.errorReporter.simpleError(callEx.target, \"new expression only valid on constructors\");\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if(target.type.elementType) {\r\n                            callEx.type = target.type;\r\n                        } else {\r\n                            this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\r\n                            callEx.type = this.anyType;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.postTypeCheckCallArgs(callEx);\r\n            return callEx;\r\n        };\r\n        TypeFlow.prototype.preTypeCheckCallArgs = function (args) {\r\n            if(!args) {\r\n                return;\r\n            }\r\n            for(var i = 0; i < args.members.length; i++) {\r\n                switch(args.members[i].nodeType) {\r\n                    case TypeScript.NodeType.FuncDecl:\r\n                    case TypeScript.NodeType.ObjectLit:\r\n                    case TypeScript.NodeType.ArrayLit: {\r\n                        continue;\r\n\r\n                    }\r\n                    default: {\r\n                        this.typeCheck(args.members[i]);\r\n                        break;\r\n\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.postTypeCheckCallArgs = function (callEx) {\r\n            var acceptedTargetType = false;\r\n            var i = 0;\r\n            if(callEx.target && callEx.target.type && callEx.signature && callEx.args) {\r\n                var sig = callEx.signature;\r\n                if(sig && callEx.args.members.length >= sig.nonOptionalParameterCount) {\r\n                    acceptedTargetType = true;\r\n                    var targetType = null;\r\n                    var len = callEx.args.members.length < sig.parameters.length ? callEx.args.members.length : sig.parameters.length;\r\n                    for(i = 0; i < len; i++) {\r\n                        targetType = sig.parameters[i].getType();\r\n                        if(targetType && sig.hasVariableArgList && i >= sig.nonOptionalParameterCount - 1) {\r\n                            targetType = targetType.elementType;\r\n                        }\r\n                        switch(callEx.args.members[i].nodeType) {\r\n                            case TypeScript.NodeType.FuncDecl:\r\n                            case TypeScript.NodeType.ObjectLit:\r\n                            case TypeScript.NodeType.ArrayLit: {\r\n                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.args.members[i]);\r\n                                break;\r\n\r\n                            }\r\n                            default: {\r\n                                continue;\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(!acceptedTargetType && callEx.args) {\r\n                this.checker.killTargetType();\r\n                for(i = 0; i < callEx.args.members.length; i++) {\r\n                    switch(callEx.args.members[i].nodeType) {\r\n                        case TypeScript.NodeType.FuncDecl:\r\n                        case TypeScript.NodeType.ObjectLit:\r\n                        case TypeScript.NodeType.ArrayLit: {\r\n                            this.typeCheck(callEx.args.members[i]);\r\n                            break;\r\n\r\n                        }\r\n                        default: {\r\n                            continue;\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.typeCheckCall = function (ast) {\r\n            var callEx = ast;\r\n            if(this.checker.styleSettings.newMustBeUsed && (ast.nodeType == TypeScript.NodeType.New)) {\r\n                if(TypeScript.hasFlag(ast.flags, TypeScript.ASTFlags.IsStatement)) {\r\n                    this.checker.errorReporter.styleError(ast, \"use of new expression as a statement\");\r\n                }\r\n            } else {\r\n                if((!this.checker.styleSettings.evalOK) && (ast.nodeType == TypeScript.NodeType.Call)) {\r\n                    if((callEx.target.nodeType == TypeScript.NodeType.Name) && ((callEx.target).text == \"eval\")) {\r\n                        this.checker.errorReporter.styleError(callEx, \"eval not permitted\");\r\n                    }\r\n                }\r\n            }\r\n            if(callEx.target.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                (callEx.target).isInlineCallLiteral = true;\r\n            }\r\n            var prevInSuperCall = this.inSuperCall;\r\n            if(callEx.target.nodeType == TypeScript.NodeType.Super) {\r\n                this.inSuperCall = true;\r\n            }\r\n            callEx.target = this.typeCheck(callEx.target);\r\n            this.preTypeCheckCallArgs(callEx.args);\r\n            var target = callEx.target;\r\n            if((target.type == null) || (target.type == this.anyType) || (this.functionInterfaceType && target.type == this.functionInterfaceType)) {\r\n                callEx.type = this.anyType;\r\n            } else {\r\n                var fnType = target.type;\r\n                if(fnType.call) {\r\n                    var signature = this.resolveOverload(callEx, fnType.call);\r\n                    if(signature == null) {\r\n                        callEx.type = this.anyType;\r\n                    } else {\r\n                        callEx.type = signature.returnType.type;\r\n                        callEx.signature = signature;\r\n                    }\r\n                } else {\r\n                    if(callEx.target.nodeType == TypeScript.NodeType.Super && this.thisFnc && this.thisFnc.isConstructor && TypeScript.hasFlag(this.thisFnc.fncFlags, TypeScript.FncFlags.ClassMethod)) {\r\n                        var signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;\r\n                        if(signature == null) {\r\n                            callEx.type = this.anyType;\r\n                        } else {\r\n                            callEx.flags |= TypeScript.ASTFlags.ClassBaseConstructorCall;\r\n                            callEx.type = signature.returnType.type;\r\n                            callEx.signature = signature;\r\n                        }\r\n                    } else {\r\n                        callEx.type = this.anyType;\r\n                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);\r\n                    }\r\n                }\r\n            }\r\n            this.postTypeCheckCallArgs(callEx);\r\n            this.inSuperCall = prevInSuperCall;\r\n            return callEx;\r\n        };\r\n        TypeFlow.prototype.assignScopes = function (ast) {\r\n            var script = ast;\r\n            this.checker.locationInfo = script.locationInfo;\r\n            var globalChain = new ScopeChain(null, null, this.globalScope);\r\n            var context = new TypeScript.AssignScopeContext(globalChain, this, [\r\n                this.checker.currentModDecl\r\n            ]);\r\n            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.preAssignScopes, TypeScript.postAssignScopes, null, context);\r\n        };\r\n        TypeFlow.prototype.findMemberScope = function (enclosingScopeContext, matchFlag) {\r\n            var enclosingScope = enclosingScopeContext.getScope();\r\n            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScriptFragmentPosition();\r\n            var scriptFragment = enclosingScopeContext.getScriptFragment();\r\n            var memContext = new TypeScript.MemberScopeContext(this, pos, matchFlag);\r\n            memContext.scope = enclosingScope;\r\n            if(scriptFragment.nodeType == TypeScript.NodeType.Name) {\r\n                return scriptFragment.type.getMemberScope(this);\r\n            } else {\r\n                TypeScript.getAstWalkerFactory().walk(scriptFragment, TypeScript.preFindMemberScope, null, null, memContext);\r\n                if(memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\r\n                    enclosingScopeContext.publicsOnly = false;\r\n                }\r\n                if(memContext.type) {\r\n                    return memContext.type.getMemberScope(this);\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n        };\r\n        TypeFlow.prototype.findMemberScopeAt = function (enclosingScopeContext) {\r\n            return this.findMemberScope(enclosingScopeContext, TypeScript.ASTFlags.DotLHS);\r\n        };\r\n        TypeFlow.prototype.findMemberScopeAtFullAst = function (enclosingScopeContext) {\r\n            var matchFlag = TypeScript.ASTFlags.DotLHS;\r\n            var pos = enclosingScopeContext.pos;\r\n            var astResult = null;\r\n            var preFindMemberScopeFullAst = function (ast, parent, walker) {\r\n                if(TypeScript.isValidAstNode(ast)) {\r\n                    if(TypeScript.hasFlag(ast.flags, matchFlag) && (pos == ast.limChar || (pos - 1) == ast.limChar)) {\r\n                        astResult = ast;\r\n                        walker.options.stopWalk();\r\n                    }\r\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\r\n                }\r\n                return ast;\r\n            };\r\n            var preFindMemberScopeFullAstFuzy = function (ast, parent, walker) {\r\n                if(TypeScript.isValidAstNode(ast)) {\r\n                    if(TypeScript.hasFlag(ast.flags, matchFlag) && ((ast.minChar < pos) && (pos <= ast.limChar))) {\r\n                        astResult = ast;\r\n                    }\r\n                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);\r\n                }\r\n                return ast;\r\n            };\r\n            TypeScript.getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAst);\r\n            if(astResult == null) {\r\n                TypeScript.getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAstFuzy);\r\n            }\r\n            if(astResult && enclosingScopeContext.enclosingClassDecl && astResult.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {\r\n                enclosingScopeContext.publicsOnly = false;\r\n            }\r\n            if(astResult && astResult.type) {\r\n                return astResult.type.getMemberScope(this);\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n        return TypeFlow;\r\n    })();\r\n    TypeScript.TypeFlow = TypeFlow;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (Primitive) {\r\n        Primitive._map = [];\r\n        Primitive.None = 0;\r\n        Primitive.Void = 1;\r\n        Primitive.Double = 2;\r\n        Primitive.String = 4;\r\n        Primitive.Boolean = 8;\r\n        Primitive.Any = 16;\r\n        Primitive.Null = 32;\r\n        Primitive.Undefined = 64;\r\n    })(TypeScript.Primitive || (TypeScript.Primitive = {}));\r\n    var Primitive = TypeScript.Primitive;\r\n\r\n    var MemberName = (function () {\r\n        function MemberName() {\r\n            this.prefix = \"\";\r\n            this.suffix = \"\";\r\n        }\r\n        MemberName.prototype.isString = function () {\r\n            return false;\r\n        };\r\n        MemberName.prototype.isArray = function () {\r\n            return false;\r\n        };\r\n        MemberName.prototype.toString = function () {\r\n            return MemberName.memberNameToString(this);\r\n        };\r\n        MemberName.memberNameToString = function memberNameToString(memberName) {\r\n            var result = memberName.prefix;\r\n            if(memberName.isString()) {\r\n                result += (memberName).text;\r\n            } else {\r\n                var ar = memberName;\r\n                for(var index = 0; index < ar.entries.length; index++) {\r\n                    result += MemberName.memberNameToString(ar.entries[index]);\r\n                    result += ar.delim;\r\n                }\r\n            }\r\n            result += memberName.suffix;\r\n            return result;\r\n        }\r\n        MemberName.create = function create(arg1, arg2, arg3) {\r\n            if(typeof arg1 == \"string\") {\r\n                return new MemberNameString(arg1);\r\n            } else {\r\n                var result = new MemberNameArray();\r\n                if(arg2) {\r\n                    result.prefix = arg2;\r\n                }\r\n                if(arg3) {\r\n                    result.suffix = arg3;\r\n                }\r\n                result.entries.push(arg1);\r\n                return result;\r\n            }\r\n        }\r\n        return MemberName;\r\n    })();\r\n    TypeScript.MemberName = MemberName;    \r\n    var MemberNameString = (function (_super) {\r\n        __extends(MemberNameString, _super);\r\n        function MemberNameString(text) {\r\n                _super.call(this);\r\n            this.text = text;\r\n        }\r\n        MemberNameString.prototype.isString = function () {\r\n            return true;\r\n        };\r\n        return MemberNameString;\r\n    })(MemberName);\r\n    TypeScript.MemberNameString = MemberNameString;    \r\n    var MemberNameArray = (function (_super) {\r\n        __extends(MemberNameArray, _super);\r\n        function MemberNameArray() {\r\n            _super.apply(this, arguments);\r\n\r\n            this.delim = \"\";\r\n            this.entries = [];\r\n        }\r\n        MemberNameArray.prototype.isArray = function () {\r\n            return true;\r\n        };\r\n        MemberNameArray.prototype.add = function (entry) {\r\n            this.entries.push(entry);\r\n        };\r\n        MemberNameArray.prototype.addAll = function (entries) {\r\n            for(var i = 0; i < entries.length; i++) {\r\n                this.entries.push(entries[i]);\r\n            }\r\n        };\r\n        return MemberNameArray;\r\n    })(MemberName);\r\n    TypeScript.MemberNameArray = MemberNameArray;    \r\n    var currentTypeID = -1;\r\n    var Type = (function () {\r\n        function Type() {\r\n            this.typeID = currentTypeID++;\r\n            this.construct = null;\r\n            this.call = null;\r\n            this.index = null;\r\n            this.passTypeCreated = TypeScript.CompilerDiagnostics.analysisPass;\r\n            this.primitiveTypeClass = Primitive.None;\r\n            this.typeFlags = TypeScript.TypeFlags.None;\r\n        }\r\n        Type.prototype.baseClass = function () {\r\n            if(this.extendsList && (this.extendsList.length > 0)) {\r\n                return this.extendsList[0];\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n        Type.prototype.getArrayBase = function (arrInstType, checker) {\r\n            return this.arrayCache.specialize(arrInstType, checker);\r\n        };\r\n        Type.prototype.isClass = function () {\r\n            return this.instanceType != null;\r\n        };\r\n        Type.prototype.isArray = function () {\r\n            return this.elementType != null;\r\n        };\r\n        Type.prototype.isClassInstance = function () {\r\n            return this.symbol && !this.elementType && (this.symbol).type.isClass();\r\n        };\r\n        Type.prototype.getInstanceType = function () {\r\n            if(this.isClass()) {\r\n                return this.instanceType;\r\n            } else {\r\n                return this;\r\n            }\r\n        };\r\n        Type.prototype.hasImplementation = function () {\r\n            return TypeScript.hasFlag(this.typeFlags, TypeScript.TypeFlags.HasImplementation);\r\n        };\r\n        Type.prototype.setHasImplementation = function () {\r\n            this.typeFlags |= TypeScript.TypeFlags.HasImplementation;\r\n        };\r\n        Type.prototype.isDouble = function () {\r\n            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.Double);\r\n        };\r\n        Type.prototype.isString = function () {\r\n            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.String);\r\n        };\r\n        Type.prototype.isBoolean = function () {\r\n            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.Boolean);\r\n        };\r\n        Type.prototype.isNull = function () {\r\n            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.Null);\r\n        };\r\n        Type.prototype.getTypeName = function () {\r\n            return this.getMemberTypeName(\"\", true, false, null);\r\n        };\r\n        Type.prototype.getScopedTypeName = function (scope) {\r\n            return this.getMemberTypeName(\"\", true, false, scope);\r\n        };\r\n        Type.prototype.getScopedTypeNameEx = function (scope) {\r\n            return this.getMemberTypeNameEx(\"\", true, false, scope);\r\n        };\r\n        Type.prototype.callCount = function () {\r\n            var total = 0;\r\n            if(this.call) {\r\n                total += this.call.signatures.length;\r\n            }\r\n            if(this.construct) {\r\n                total += this.construct.signatures.length;\r\n            }\r\n            if(this.index) {\r\n                total += this.index.signatures.length;\r\n            }\r\n            return total;\r\n        };\r\n        Type.prototype.getMemberTypeName = function (prefix, topLevel, isElementType, scope) {\r\n            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope);\r\n            return memberName.toString();\r\n        };\r\n        Type.prototype.getMemberTypeNameEx = function (prefix, topLevel, isElementType, scope) {\r\n            if(this.elementType) {\r\n                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), \"\", \"[]\");\r\n            } else {\r\n                if(this.symbol && this.symbol.name && this.symbol.name != \"_anonymous\" && (((this.call == null) && (this.construct == null) && (this.index == null)) || (TypeScript.hasFlag(this.typeFlags, TypeScript.TypeFlags.BuildingName)) || (this.members && (!this.isClass())))) {\r\n                    var tn = this.symbol.scopeRelativeName(scope);\r\n                    return MemberName.create(tn == \"null\" ? \"any\" : tn);\r\n                } else {\r\n                    if(this.members || this.call || this.construct) {\r\n                        if(TypeScript.hasFlag(this.typeFlags, TypeScript.TypeFlags.BuildingName)) {\r\n                            return MemberName.create(\"this\");\r\n                        }\r\n                        this.typeFlags |= TypeScript.TypeFlags.BuildingName;\r\n                        var builder = \"\";\r\n                        var allMemberNames = new MemberNameArray();\r\n                        var curlies = isElementType;\r\n                        var signatureCount = 0;\r\n                        var memCount = 0;\r\n                        var delim = \"; \";\r\n                        if(this.members) {\r\n                            this.members.allMembers.map(function (key, s, unused) {\r\n                                var sym = s;\r\n                                if(!TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.BuiltIn)) {\r\n                                    var typeName = sym.getTypeName(scope);\r\n                                    if(typeName.length >= delim.length && typeName.substring(typeName.length - delim.length) == delim) {\r\n                                        typeName = typeName.substring(0, typeName.length - delim.length);\r\n                                    }\r\n                                    allMemberNames.add(MemberName.create(typeName));\r\n                                    memCount++;\r\n                                    if(sym.kind() == TypeScript.SymbolKind.Type) {\r\n                                        var memberType = (sym).type;\r\n                                        if(memberType.callCount() > 1) {\r\n                                            curlies = true;\r\n                                        }\r\n                                    } else {\r\n                                        curlies = true;\r\n                                    }\r\n                                }\r\n                            }, null);\r\n                        }\r\n                        var signatures;\r\n                        var j;\r\n                        var len = 0;\r\n                        var shortform = (memCount == 0) && (this.callCount() == 1) && topLevel;\r\n                        if(!shortform) {\r\n                            allMemberNames.delim = delim;\r\n                        }\r\n                        if(this.call) {\r\n                            signatures = this.call.toStrings(prefix, shortform, scope);\r\n                            for(j = 0 , len = signatures.length; j < len; j++) {\r\n                                allMemberNames.add(MemberName.create(signatures[j]));\r\n                                signatureCount++;\r\n                            }\r\n                        }\r\n                        if(this.construct) {\r\n                            signatures = this.construct.toStrings(\"new\", shortform, scope);\r\n                            for(j = 0 , len = signatures.length; j < len; j++) {\r\n                                allMemberNames.add(MemberName.create(signatures[j]));\r\n                                signatureCount++;\r\n                            }\r\n                        }\r\n                        if(this.index) {\r\n                            signatures = this.index.toStrings(\"\", shortform, scope);\r\n                            for(j = 0 , len = signatures.length; j < len; j++) {\r\n                                allMemberNames.add(MemberName.create(signatures[j]));\r\n                                signatureCount++;\r\n                            }\r\n                        }\r\n                        if((curlies) || ((signatureCount > 1) && topLevel)) {\r\n                            allMemberNames.prefix = \"{ \";\r\n                            allMemberNames.suffix = \"}\";\r\n                        }\r\n                        this.typeFlags &= (~TypeScript.TypeFlags.BuildingName);\r\n                        if((signatureCount == 0) && (memCount == 0)) {\r\n                            return MemberName.create(\"{}\");\r\n                        } else {\r\n                            return allMemberNames;\r\n                        }\r\n                    } else {\r\n                        return MemberName.create(\"{}\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Type.prototype.checkDecl = function (checker) {\r\n            if(this.isClassInstance() || this.isClass()) {\r\n                if(this.symbol.declAST) {\r\n                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);\r\n                }\r\n            }\r\n        };\r\n        Type.prototype.getMemberScope = function (flow) {\r\n            if(this == flow.anyType) {\r\n                return null;\r\n            } else {\r\n                if(this.isDouble()) {\r\n                    if(flow.numberInterfaceType) {\r\n                        return flow.numberInterfaceType.memberScope;\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                } else {\r\n                    if(this.isBoolean()) {\r\n                        if(flow.booleanInterfaceType) {\r\n                            return flow.booleanInterfaceType.memberScope;\r\n                        } else {\r\n                            return null;\r\n                        }\r\n                    } else {\r\n                        if(this == flow.stringType) {\r\n                            if(flow.stringInterfaceType) {\r\n                                return flow.stringInterfaceType.memberScope;\r\n                            } else {\r\n                                return null;\r\n                            }\r\n                        } else {\r\n                            if(this.elementType) {\r\n                                if(flow.arrayInterfaceType) {\r\n                                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);\r\n                                    return arrInstType.memberScope;\r\n                                } else {\r\n                                    return null;\r\n                                }\r\n                            } else {\r\n                                return this.memberScope;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Type.prototype.isReferenceType = function () {\r\n            return this.members || this.extendsList || this.construct || this.call || this.index || this.elementType;\r\n        };\r\n        Type.prototype.specializeType = function (pattern, replacement, checker, membersOnly) {\r\n            if(pattern == this) {\r\n                return replacement;\r\n            }\r\n            var result = this;\r\n            if(membersOnly) {\r\n                if(this.isReferenceType()) {\r\n                    result = new Type();\r\n                    if(this.members) {\r\n                        result.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                        this.members.publicMembers.map(function (key, s, unused) {\r\n                            var sym = s;\r\n                            var bSym = sym.specializeType(pattern, replacement, checker);\r\n                            result.members.addPublicMember(bSym.name, bSym);\r\n                        }, null);\r\n                        this.members.privateMembers.map(function (key, s, unused) {\r\n                            var sym = s;\r\n                            var bSym = sym.specializeType(pattern, replacement, checker);\r\n                            result.members.addPrivateMember(bSym.name, bSym);\r\n                        }, null);\r\n                    }\r\n                    if(this.ambientMembers) {\r\n                        result.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));\r\n                        this.ambientMembers.publicMembers.map(function (key, s, unused) {\r\n                            var sym = s;\r\n                            var bSym = sym.specializeType(pattern, replacement, checker);\r\n                            result.ambientMembers.addPublicMember(bSym.name, bSym);\r\n                        }, null);\r\n                        this.ambientMembers.privateMembers.map(function (key, s, unused) {\r\n                            var sym = s;\r\n                            var bSym = sym.specializeType(pattern, replacement, checker);\r\n                            result.ambientMembers.addPrivateMember(bSym.name, bSym);\r\n                        }, null);\r\n                    }\r\n                    result.containedScope = checker.scopeOf(result);\r\n                    result.memberScope = result.containedScope;\r\n                }\r\n            } else {\r\n                if(this.elementType) {\r\n                    if(this.elementType == pattern) {\r\n                        result = checker.makeArrayType(replacement);\r\n                    } else {\r\n                        if(this.elementType.elementType == pattern) {\r\n                            result = checker.makeArrayType(checker.makeArrayType(replacement));\r\n                        }\r\n                    }\r\n                } else {\r\n                    if(this.call) {\r\n                        result = new Type();\r\n                        result.call = this.call.specializeType(pattern, replacement, checker);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        Type.prototype.hasBase = function (baseType) {\r\n            if(baseType == this) {\r\n                return true;\r\n            } else {\r\n                if(this.extendsList) {\r\n                    for(var i = 0, len = this.extendsList.length; i < len; i++) {\r\n                        if(this.extendsList[i].hasBase(baseType)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        Type.prototype.mergeOrdered = function (b, checker, comparisonInfo) {\r\n            if((this == checker.anyType) || (b == checker.anyType)) {\r\n                return checker.anyType;\r\n            } else {\r\n                if(this == b) {\r\n                    return this;\r\n                } else {\r\n                    if((b == checker.nullType) && this != checker.nullType) {\r\n                        return this;\r\n                    } else {\r\n                        if((this == checker.nullType) && (b != checker.nullType)) {\r\n                            return b;\r\n                        } else {\r\n                            if((b == checker.voidType) && this != checker.voidType) {\r\n                                return this;\r\n                            } else {\r\n                                if((this == checker.voidType) && (b != checker.voidType)) {\r\n                                    return b;\r\n                                } else {\r\n                                    if((b == checker.undefinedType) && this != checker.undefinedType) {\r\n                                        return this;\r\n                                    } else {\r\n                                        if((this == checker.undefinedType) && (b != checker.undefinedType)) {\r\n                                            return b;\r\n                                        } else {\r\n                                            if(this.elementType && b.elementType) {\r\n                                                if(this.elementType == b.elementType) {\r\n                                                    return this;\r\n                                                } else {\r\n                                                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, comparisonInfo);\r\n                                                    if(mergedET == null) {\r\n                                                        return checker.makeArrayType(checker.anyType);\r\n                                                    } else {\r\n                                                        return checker.makeArrayType(mergedET);\r\n                                                    }\r\n                                                }\r\n                                            } else {\r\n                                                if(checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {\r\n                                                    return b;\r\n                                                } else {\r\n                                                    if(checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {\r\n                                                        return this;\r\n                                                    } else {\r\n                                                        return null;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Type.prototype.isModuleType = function () {\r\n            return false;\r\n        };\r\n        Type.prototype.hasMembers = function () {\r\n            return this.members != null;\r\n        };\r\n        Type.prototype.getAllEnclosedTypes = function () {\r\n            return null;\r\n        };\r\n        Type.prototype.getAllAmbientEnclosedTypes = function () {\r\n            return null;\r\n        };\r\n        Type.prototype.getPublicEnclosedTypes = function () {\r\n            return null;\r\n        };\r\n        Type.prototype.getpublicAmbientEnclosedTypes = function () {\r\n            return null;\r\n        };\r\n        return Type;\r\n    })();\r\n    TypeScript.Type = Type;    \r\n    var ModuleType = (function (_super) {\r\n        __extends(ModuleType, _super);\r\n        function ModuleType(enclosedTypes, ambientEnclosedTypes) {\r\n                _super.call(this);\r\n            this.enclosedTypes = enclosedTypes;\r\n            this.ambientEnclosedTypes = ambientEnclosedTypes;\r\n            this.importedModules = [];\r\n        }\r\n        ModuleType.prototype.isModuleType = function () {\r\n            return true;\r\n        };\r\n        ModuleType.prototype.hasMembers = function () {\r\n            return this.members != null || this.enclosedTypes != null;\r\n        };\r\n        ModuleType.prototype.getAllEnclosedTypes = function () {\r\n            return this.enclosedTypes;\r\n        };\r\n        ModuleType.prototype.getAllAmbientEnclosedTypes = function () {\r\n            return this.ambientEnclosedTypes;\r\n        };\r\n        ModuleType.prototype.getPublicEnclosedTypes = function () {\r\n            return null;\r\n        };\r\n        ModuleType.prototype.getpublicAmbientEnclosedTypes = function () {\r\n            return null;\r\n        };\r\n        return ModuleType;\r\n    })(Type);\r\n    TypeScript.ModuleType = ModuleType;    \r\n    var TypeLink = (function () {\r\n        function TypeLink() {\r\n            this.type = null;\r\n            this.ast = null;\r\n        }\r\n        return TypeLink;\r\n    })();\r\n    TypeScript.TypeLink = TypeLink;    \r\n    function getTypeLink(ast, checker, autoVar) {\r\n        var result = new TypeLink();\r\n        result.ast = ast;\r\n        if((ast == null) && (autoVar)) {\r\n            result.type = checker.anyType;\r\n        } else {\r\n            result.type = null;\r\n        }\r\n        return result;\r\n    }\r\n    TypeScript.getTypeLink = getTypeLink;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    function stripQuotes(str) {\r\n        return str.replace(\"\\\"\", \"\").replace(\"'\", \"\").replace(\"'\", \"\").replace(\"\\\"\", \"\");\r\n    }\r\n    TypeScript.stripQuotes = stripQuotes;\r\n    function isQuoted(str) {\r\n        return str.indexOf(\"\\\"\") != -1 || str.indexOf(\"'\") != -1 || str.indexOf(\"'\") != -1 || str.indexOf(\"\\\"\") != -1;\r\n    }\r\n    TypeScript.isQuoted = isQuoted;\r\n    function quoteStr(str) {\r\n        return \"\\\"\" + str + \"\\\"\";\r\n    }\r\n    TypeScript.quoteStr = quoteStr;\r\n    function swapQuotes(str) {\r\n        if(str.indexOf(\"\\\"\") != -1) {\r\n            str = str.replace(\"\\\"\", \"'\");\r\n            str = str.replace(\"\\\"\", \"'\");\r\n        } else {\r\n            str = str.replace(\"'\", \"\\\"\");\r\n            str = str.replace(\"'\", \"\\\"\");\r\n        }\r\n        return str;\r\n    }\r\n    TypeScript.swapQuotes = swapQuotes;\r\n    function switchToForwardSlashes(path) {\r\n        return path.replace(/\\\\/g, \"/\");\r\n    }\r\n    TypeScript.switchToForwardSlashes = switchToForwardSlashes;\r\n    function trimModName(modName) {\r\n        if(modName.length > 6 && modName.substring(modName.length - 6, modName.length) == \".d.str\") {\r\n            return modName.substring(0, modName.length - 6);\r\n        }\r\n        if(modName.length > 4 && modName.substring(modName.length - 4, modName.length) == \".str\") {\r\n            return modName.substring(0, modName.length - 4);\r\n        }\r\n        if(modName.length > 5 && modName.substring(modName.length - 5, modName.length) == \".d.ts\") {\r\n            return modName.substring(0, modName.length - 5);\r\n        }\r\n        if(modName.length > 3 && modName.substring(modName.length - 3, modName.length) == \".ts\") {\r\n            return modName.substring(0, modName.length - 3);\r\n        }\r\n        if(modName.length > 3 && modName.substring(modName.length - 3, modName.length) == \".js\") {\r\n            return modName.substring(0, modName.length - 3);\r\n        }\r\n        return modName;\r\n    }\r\n    TypeScript.trimModName = trimModName;\r\n    function isSTRFile(fname) {\r\n        return fname.length > 4 && fname.substring(fname.length - 4, fname.length) == \".str\";\r\n    }\r\n    TypeScript.isSTRFile = isSTRFile;\r\n    function isTSFile(fname) {\r\n        return fname.length > 3 && fname.substring(fname.length - 3, fname.length) == \".ts\";\r\n    }\r\n    TypeScript.isTSFile = isTSFile;\r\n    function isDSTRFile(fname) {\r\n        return fname.length > 6 && fname.substring(fname.length - 6, fname.length) == \".d.str\";\r\n    }\r\n    TypeScript.isDSTRFile = isDSTRFile;\r\n    function isDTSFile(fname) {\r\n        return fname.length > 5 && fname.substring(fname.length - 5, fname.length) == \".d.ts\";\r\n    }\r\n    TypeScript.isDTSFile = isDTSFile;\r\n    function getPrettyName(modPath, quote, treatAsFileName) {\r\n        if (typeof quote === \"undefined\") { quote = true; }\r\n        if (typeof treatAsFileName === \"undefined\") { treatAsFileName = false; }\r\n        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));\r\n        var components = modName.split(\"/\");\r\n        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;\r\n    }\r\n    TypeScript.getPrettyName = getPrettyName;\r\n    function quoteBaseName(modPath) {\r\n        var modName = trimModName(stripQuotes(modPath));\r\n        var path = getRootFilePath(modName);\r\n        if(path == \"\") {\r\n            return modPath;\r\n        } else {\r\n            var components = modName.split(path);\r\n            var fileIndex = components.length > 1 ? 1 : 0;\r\n            return quoteStr(components[fileIndex]);\r\n        }\r\n    }\r\n    TypeScript.quoteBaseName = quoteBaseName;\r\n    function changePathToSTR(modPath) {\r\n        return trimModName(stripQuotes(modPath)) + \".str\";\r\n    }\r\n    TypeScript.changePathToSTR = changePathToSTR;\r\n    function changePathToDSTR(modPath) {\r\n        return trimModName(stripQuotes(modPath)) + \".d.str\";\r\n    }\r\n    TypeScript.changePathToDSTR = changePathToDSTR;\r\n    function changePathToTS(modPath) {\r\n        return trimModName(stripQuotes(modPath)) + \".ts\";\r\n    }\r\n    TypeScript.changePathToTS = changePathToTS;\r\n    function changePathToDTS(modPath) {\r\n        return trimModName(stripQuotes(modPath)) + \".d.ts\";\r\n    }\r\n    TypeScript.changePathToDTS = changePathToDTS;\r\n    function isRelative(path) {\r\n        return path.charAt(0) == \".\";\r\n    }\r\n    TypeScript.isRelative = isRelative;\r\n    function isRooted(path) {\r\n        return path.charAt(0) == \"\\\\\" || path.charAt(0) == \"/\" || (path.indexOf(\":\\\\\") != -1) || (path.indexOf(\":/\") != -1);\r\n    }\r\n    TypeScript.isRooted = isRooted;\r\n    function getRootFilePath(outFname) {\r\n        if(outFname == \"\") {\r\n            return outFname;\r\n        } else {\r\n            var isPath = outFname.indexOf(\"/\") != -1;\r\n            return isPath ? filePath(outFname) : \"\";\r\n        }\r\n    }\r\n    TypeScript.getRootFilePath = getRootFilePath;\r\n    function filePath(fullPath) {\r\n        fullPath = switchToForwardSlashes(fullPath);\r\n        var components = fullPath.split(\"/\");\r\n        var path = components.slice(0, components.length - 1);\r\n        return path.join(\"/\") + \"/\";\r\n    }\r\n    TypeScript.filePath = filePath;\r\n    function normalizeURL(url) {\r\n        var hostDomainAndPortRegex = /^(https?:\\/\\/[\\-\\w\\.]+(:\\d+)?\\/)(.*)$/i;\r\n        var matches = hostDomainAndPortRegex.exec(url);\r\n        if(matches) {\r\n            var hostDomainAndPort = matches[1];\r\n            var actualPath = matches[3];\r\n            return hostDomainAndPort + normalizePath(actualPath);\r\n        }\r\n        return normalizePath(url);\r\n    }\r\n    TypeScript.normalizeURL = normalizeURL;\r\n    TypeScript.pathNormalizeRegExp = /\\//g;\r\n    function normalizePath(path) {\r\n        path = switchToForwardSlashes(path);\r\n        var startedWithSep = path.charAt(0) === \"/\";\r\n        var parts = path.split(\"/\");\r\n        for(var i = 0; i < parts.length; i++) {\r\n            if(parts[i] === \".\" || parts[i] === \"\") {\r\n                parts.splice(i, 1);\r\n                i--;\r\n            }\r\n            if(i > 0 && parts[i] === \"..\" && parts[i - 1] !== \"..\") {\r\n                parts.splice(i - 1, 2);\r\n                i -= 2;\r\n            }\r\n        }\r\n        return (startedWithSep ? \"/\" : \"\") + parts.join(\"/\");\r\n    }\r\n    TypeScript.normalizePath = normalizePath;\r\n    function normalizeImportPath(path) {\r\n        return normalizePath(path);\r\n    }\r\n    TypeScript.normalizeImportPath = normalizeImportPath;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var SourceUnit = (function () {\r\n        function SourceUnit(path, content) {\r\n            this.path = path;\r\n            this.content = content;\r\n        }\r\n        SourceUnit.prototype.getText = function (start, end) {\r\n            return this.content.substring(start, end);\r\n        };\r\n        SourceUnit.prototype.getLength = function () {\r\n            return this.content.length;\r\n        };\r\n        return SourceUnit;\r\n    })();\r\n    TypeScript.SourceUnit = SourceUnit;    \r\n    var CompilationEnvironment = (function () {\r\n        function CompilationEnvironment(compilationSettings, ioHost) {\r\n            this.compilationSettings = compilationSettings;\r\n            this.ioHost = ioHost;\r\n            this.residentCode = [];\r\n            this.code = [];\r\n        }\r\n        return CompilationEnvironment;\r\n    })();\r\n    TypeScript.CompilationEnvironment = CompilationEnvironment;    \r\n    var CodeResolver = (function () {\r\n        function CodeResolver(environment) {\r\n            this.environment = environment;\r\n            this.visited = {\r\n            };\r\n        }\r\n        CodeResolver.prototype.resolveCode = function (referencePath, parentPath, performSearch, resolutionDispatcher) {\r\n            var resolvedFile = {\r\n                content: \"\",\r\n                path: referencePath\r\n            };\r\n            var ioHost = this.environment.ioHost;\r\n            var isRelativePath = TypeScript.isRelative(referencePath);\r\n            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(referencePath);\r\n            var normalizedPath = isRelativePath ? ioHost.resolvePath(parentPath + \"/\" + referencePath) : (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + \"/\" + referencePath);\r\n            if(!TypeScript.isSTRFile(normalizedPath) && !TypeScript.isTSFile(normalizedPath)) {\r\n                normalizedPath += \".ts\";\r\n            }\r\n            normalizedPath = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(normalizedPath));\r\n            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();\r\n            if(!this.visited[absoluteModuleID]) {\r\n                if(isRelativePath || isRootedPath || !performSearch) {\r\n                    try  {\r\n                        TypeScript.CompilerDiagnostics.debugPrint(\"   Reading code from \" + normalizedPath);\r\n                        try  {\r\n                            resolvedFile.content = ioHost.readFile(normalizedPath);\r\n                        } catch (err) {\r\n                            try  {\r\n                                if(TypeScript.isSTRFile(normalizedPath)) {\r\n                                    normalizedPath = TypeScript.changePathToTS(normalizedPath);\r\n                                } else {\r\n                                    if(TypeScript.isTSFile(normalizedPath)) {\r\n                                        normalizedPath = TypeScript.changePathToSTR(normalizedPath);\r\n                                    }\r\n                                }\r\n                                TypeScript.CompilerDiagnostics.debugPrint(\"   Reading code from \" + normalizedPath);\r\n                                resolvedFile.content = ioHost.readFile(normalizedPath);\r\n                            } catch (err) {\r\n                                normalizedPath = TypeScript.changePathToDSTR(normalizedPath);\r\n                                TypeScript.CompilerDiagnostics.debugPrint(\"   Reading code from \" + normalizedPath);\r\n                                try  {\r\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\r\n                                } catch (err) {\r\n                                    normalizedPath = TypeScript.changePathToDTS(normalizedPath);\r\n                                    TypeScript.CompilerDiagnostics.debugPrint(\"   Reading code from \" + normalizedPath);\r\n                                    resolvedFile.content = ioHost.readFile(normalizedPath);\r\n                                }\r\n                            }\r\n                        }\r\n                        TypeScript.CompilerDiagnostics.debugPrint(\"   Found code at \" + normalizedPath);\r\n                        resolvedFile.path = normalizedPath;\r\n                        this.visited[absoluteModuleID] = true;\r\n                    } catch (err) {\r\n                        TypeScript.CompilerDiagnostics.debugPrint(\"   Did not find code for \" + referencePath);\r\n                    }\r\n                } else {\r\n                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);\r\n                    if(!resolvedFile) {\r\n                        if(TypeScript.isSTRFile(normalizedPath)) {\r\n                            normalizedPath = TypeScript.changePathToTS(normalizedPath);\r\n                        } else {\r\n                            if(TypeScript.isTSFile(normalizedPath)) {\r\n                                normalizedPath = TypeScript.changePathToSTR(normalizedPath);\r\n                            }\r\n                        }\r\n                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);\r\n                    }\r\n                    if(!resolvedFile) {\r\n                        normalizedPath = TypeScript.changePathToDTS(normalizedPath);\r\n                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);\r\n                        if(!resolvedFile) {\r\n                            normalizedPath = TypeScript.changePathToDSTR(normalizedPath);\r\n                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);\r\n                        }\r\n                    }\r\n                    if(resolvedFile) {\r\n                        resolvedFile.path = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));\r\n                        TypeScript.CompilerDiagnostics.debugPrint(referencePath + \" resolved to: \" + resolvedFile.path);\r\n                        resolvedFile.content = resolvedFile.content;\r\n                        this.visited[absoluteModuleID] = true;\r\n                    } else {\r\n                        TypeScript.CompilerDiagnostics.debugPrint(\"Could not find \" + referencePath);\r\n                    }\r\n                }\r\n                if(resolvedFile && resolvedFile.content) {\r\n                    var rootDir = ioHost.dirName(resolvedFile.path);\r\n                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);\r\n                    var preProcessedFileInfo = TypeScript.preProcessFile(sourceUnit, this.environment.compilationSettings);\r\n                    for(var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {\r\n                        var referencedFile = preProcessedFileInfo.referencedFiles[i];\r\n                        var normalizedPath = TypeScript.isRooted(referencedFile.path) ? referencedFile.path : rootDir + \"/\" + referencedFile.path;\r\n                        normalizedPath = ioHost.resolvePath(normalizedPath);\r\n                        if(referencePath == normalizedPath) {\r\n                            resolutionDispatcher.postResolutionError(normalizedPath, \"File contains reference to itself\", null);\r\n                            continue;\r\n                        }\r\n                        this.resolveCode(referencedFile.path, rootDir, false, resolutionDispatcher);\r\n                    }\r\n                    for(var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {\r\n                        this.resolveCode(preProcessedFileInfo.importedFiles[i].path, rootDir, true, resolutionDispatcher);\r\n                    }\r\n                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);\r\n                }\r\n            }\r\n        };\r\n        return CodeResolver;\r\n    })();\r\n    TypeScript.CodeResolver = CodeResolver;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var StyleSettings = (function () {\r\n        function StyleSettings() {\r\n            this.bitwise = false;\r\n            this.blockInCompoundStmt = false;\r\n            this.eqeqeq = false;\r\n            this.forin = false;\r\n            this.emptyBlocks = true;\r\n            this.newMustBeUsed = false;\r\n            this.requireSemi = false;\r\n            this.assignmentInCond = false;\r\n            this.eqnull = false;\r\n            this.evalOK = true;\r\n            this.innerScopeDeclEscape = true;\r\n            this.funcInLoop = true;\r\n            this.reDeclareLocal = true;\r\n            this.literalSubscript = true;\r\n            this.implicitAny = false;\r\n        }\r\n        StyleSettings.prototype.setOption = function (opt, val) {\r\n            var optExists = this[opt];\r\n            if(optExists !== undefined) {\r\n                this[opt] = val;\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        };\r\n        StyleSettings.prototype.parseOptions = function (str) {\r\n            var opts = str.split(\";\");\r\n            for(var i = 0, len = opts.length; i < len; i++) {\r\n                var opt = opts[i];\r\n                var val = true;\r\n                var colonIndex = opt.lastIndexOf(\":\");\r\n                if(colonIndex >= 0) {\r\n                    var valStr = opt.substring(colonIndex + 1);\r\n                    opt = opt.substring(0, colonIndex);\r\n                    if(valStr == \"off\") {\r\n                        val = false;\r\n                    }\r\n                }\r\n                if(!this.setOption(opt, val)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        return StyleSettings;\r\n    })();\r\n    TypeScript.StyleSettings = StyleSettings;    \r\n    var CompilationSettings = (function () {\r\n        function CompilationSettings() {\r\n            this.styleSettings = new StyleSettings();\r\n            this.propagateConstants = false;\r\n            this.minWhitespace = false;\r\n            this.parseOnly = false;\r\n            this.outputMany = true;\r\n            this.errorRecovery = false;\r\n            this.emitComments = false;\r\n            this.watch = false;\r\n            this.exec = false;\r\n            this.resolve = true;\r\n            this.controlFlow = false;\r\n            this.printControlFlow = false;\r\n            this.controlFlowUseDef = false;\r\n            this.errorOnWith = true;\r\n            this.preprocess = true;\r\n            this.canCallDefinitionSignature = false;\r\n            this.inferPropertiesFromThisAssignment = false;\r\n            this.useDefaultLib = true;\r\n            this.codeGenTarget = TypeScript.CodeGenTarget.ES3;\r\n            this.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;\r\n            this.outputFileName = \"\";\r\n            this.errorFileName = \"\";\r\n            this.mapSourceFiles = false;\r\n            this.generateDeclarationFiles = false;\r\n            this.useCaseSensitiveFileResolution = false;\r\n        }\r\n        CompilationSettings.prototype.setStyleOptions = function (str) {\r\n            this.styleSettings.parseOptions(str);\r\n        };\r\n        CompilationSettings.prototype.outputOne = function (outFile) {\r\n            this.outputFileName = outFile;\r\n            this.outputMany = false;\r\n        };\r\n        return CompilationSettings;\r\n    })();\r\n    TypeScript.CompilationSettings = CompilationSettings;    \r\n    function getFileReferenceFromReferencePath(comment) {\r\n        var referencesRegEx = /^(\\/\\/\\/\\s*<reference\\s+path=)('|\")(.+?)\\2\\s*(static=('|\")(.+?)\\2\\s*)*\\/>/igm;\r\n        var match = referencesRegEx.exec(comment);\r\n        if(match) {\r\n            var path = TypeScript.normalizePath(match[3]);\r\n            var adjustedPath = TypeScript.normalizePath(path);\r\n            var isResident = match.length >= 7 && match[6] == \"true\";\r\n            if(isResident) {\r\n                TypeScript.CompilerDiagnostics.debugPrint(path + \" is resident\");\r\n            }\r\n            return {\r\n                minChar: 0,\r\n                limChar: 0,\r\n                path: TypeScript.switchToForwardSlashes(adjustedPath),\r\n                isResident: isResident\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    function getAdditionalDependencyPath(comment) {\r\n        var referencesRegEx = /^(\\/\\/\\/\\s*<amd-dependency\\s+path=)('|\")(.+?)\\2\\s*(static=('|\")(.+?)\\2\\s*)*\\/>/igm;\r\n        var match = referencesRegEx.exec(comment);\r\n        if(match) {\r\n            var path = match[3];\r\n            return path;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    TypeScript.getAdditionalDependencyPath = getAdditionalDependencyPath;\r\n    function getStyleSettings(comment, styleSettings) {\r\n        var styleRegEx = /^(\\/\\/\\/\\s*<style\\s+)(([a-zA-Z])+=('|\").+('|\"))\\s*\\/>/igm;\r\n        var settings = styleRegEx.exec(comment);\r\n        if(settings) {\r\n            var settingsRegEx = /^([a-zA-Z]+=['\"]on['|\"])/igm;\r\n            settings = settingsRegEx.exec(settings[2]);\r\n            if(settings) {\r\n                for(var i = 0; i < settings.length; i++) {\r\n                    var setting = (settings[i]).split(\"=\");\r\n                    var on = \"\\\"on\\\"\";\r\n                    switch(setting[0]) {\r\n                        case \"blockInCompoundStmt\": {\r\n                            styleSettings.blockInCompoundStmt = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"eqeqeq\": {\r\n                            styleSettings.eqeqeq = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"forin\": {\r\n                            styleSettings.forin = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"emptyBlocks\": {\r\n                            styleSettings.emptyBlocks = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"newMustBeUsed\": {\r\n                            styleSettings.newMustBeUsed = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"requireSemi\": {\r\n                            styleSettings.requireSemi = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"assignmentInCond\": {\r\n                            styleSettings.assignmentInCond = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"eqnull\": {\r\n                            styleSettings.eqnull = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"evalOK\": {\r\n                            styleSettings.evalOK = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"innerScopeDeclEscape\": {\r\n                            styleSettings.innerScopeDeclEscape = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"funcInLoop\": {\r\n                            styleSettings.funcInLoop = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"reDeclareLocal\": {\r\n                            styleSettings.reDeclareLocal = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"literalSubscript\": {\r\n                            styleSettings.literalSubscript = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                        case \"implicitAny\": {\r\n                            styleSettings.implicitAny = setting[1] == on;\r\n                            break;\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    TypeScript.getStyleSettings = getStyleSettings;\r\n    function preProcessFile(sourceText, options) {\r\n        if (typeof options === \"undefined\") { options = new CompilationSettings(); }\r\n        var scanner = new TypeScript.Scanner();\r\n        scanner.resetComments();\r\n        scanner.setSourceText(sourceText, TypeScript.LexMode.File);\r\n        var tok = scanner.scan();\r\n        var comments = [];\r\n        var comment = null;\r\n        var leftCurlies = [];\r\n        var settings = options;\r\n        var referencedFiles = [];\r\n        var importedFiles = [];\r\n        var isLibFile = false;\r\n        while(tok.tokenId != TypeScript.TokenID.EOF) {\r\n            if(tok.tokenId == TypeScript.TokenID.IMPORT) {\r\n                tok = scanner.scan();\r\n                if(tok.tokenId == TypeScript.TokenID.ID || TypeScript.convertTokToID(tok, false)) {\r\n                    tok = scanner.scan();\r\n                    if(tok.tokenId == TypeScript.TokenID.Asg) {\r\n                        tok = scanner.scan();\r\n                        if(tok.tokenId == TypeScript.TokenID.MODULE) {\r\n                            tok = scanner.scan();\r\n                            if(tok.tokenId == TypeScript.TokenID.LParen) {\r\n                                tok = scanner.scan();\r\n                                if(tok.tokenId == TypeScript.TokenID.QString) {\r\n                                    var ref = {\r\n                                        minChar: scanner.startPos,\r\n                                        limChar: scanner.pos,\r\n                                        path: TypeScript.stripQuotes(TypeScript.switchToForwardSlashes(tok.getText())),\r\n                                        isResident: false\r\n                                    };\r\n                                    importedFiles.push(ref);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if(tok.tokenId == TypeScript.TokenID.LCurly) {\r\n                leftCurlies.push(tok);\r\n            }\r\n            if(tok.tokenId == TypeScript.TokenID.RCurly) {\r\n                leftCurlies.pop();\r\n            }\r\n            tok = scanner.scan();\r\n        }\r\n        comments = scanner.getComments();\r\n        for(var iComment = 0; iComment < comments.length; iComment++) {\r\n            comment = comments[iComment];\r\n            if(!comment.isBlock) {\r\n                var referencedCode = getFileReferenceFromReferencePath(comment.getText());\r\n                if(referencedCode) {\r\n                    referencedCode.minChar = comment.startPos;\r\n                    referencedCode.limChar = referencedCode.minChar + comment.value.length;\r\n                    referencedFiles.push(referencedCode);\r\n                }\r\n                getStyleSettings(comment.getText(), settings.styleSettings);\r\n                var isNoLibRegex = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib=)('|\")(.+?)\\2\\s*\\/>/igm;\r\n                var isNoLibMatch = isNoLibRegex.exec(comment.getText());\r\n                if(isNoLibMatch) {\r\n                    isLibFile = (isNoLibMatch[3] == \"true\");\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            settings: settings,\r\n            referencedFiles: referencedFiles,\r\n            importedFiles: importedFiles,\r\n            isLibFile: isLibFile\r\n        };\r\n    }\r\n    TypeScript.preProcessFile = preProcessFile;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    var IncrementalParser = (function () {\r\n        function IncrementalParser(logger) {\r\n            this.logger = logger;\r\n            this.astLogger = new TypeScript.AstLogger(this.logger);\r\n        }\r\n        IncrementalParser.prototype.getEnclosingScopeContextIfSingleScopeEdit = function (previousScript, scriptId, newSourceText, editRange) {\r\n            this.logger.log(\"checkEditsInsideSingleScope(\\\"\" + scriptId + \"\\\")\");\r\n            if(editRange === null) {\r\n                throw new Error(\"editRange should be valid\");\r\n            }\r\n            if(editRange.isUnknown()) {\r\n                this.logger.log(\"  Bailing out because edit range is unknown\");\r\n                return null;\r\n            }\r\n            var scope1 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false);\r\n            var scope2 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false);\r\n            if(scope1 == null || scope2 == null) {\r\n                this.logger.log(\"  Bailing out because containing scopes cannot be determined\");\r\n                return null;\r\n            }\r\n            if(scope1.scopeStartAST !== scope2.scopeStartAST) {\r\n                this.logger.log(\"  Bailing out because edit overlaps 2 disctint scopes\");\r\n                return null;\r\n            }\r\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\r\n            if(newScopeLength <= 0) {\r\n                this.logger.log(\"  Bailing out because scope has been entirely removed from new source text\");\r\n                return null;\r\n            }\r\n            return scope1;\r\n        };\r\n        IncrementalParser.prototype.attemptIncrementalUpdateUnit = function (previousScript, scriptId, newSourceText, editRange) {\r\n            this.logger.log(\"attemptIncrementalUpdateUnit(\\\"\" + scriptId + \"\\\")\");\r\n            if(editRange === null) {\r\n                throw new Error(\"editRange should be valid\");\r\n            }\r\n            var scope1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript, scriptId, newSourceText, editRange);\r\n            if(scope1 === null) {\r\n                return null;\r\n            }\r\n            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;\r\n            if(newScopeLength >= newSourceText.getLength() / 2) {\r\n                this.logger.log(\"  Bailing out because range of scope to reparse (\" + newScopeLength + \" characters) is greater than half the size of the source text\");\r\n                return null;\r\n            }\r\n            var parseErrors = [];\r\n            var errorCapture = function (minChar, charLen, message, unitIndex) {\r\n                parseErrors.push(new TypeScript.ErrorEntry(unitIndex, minChar, minChar + charLen, message));\r\n            };\r\n            var quickParseResult = TypeScript.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);\r\n            if(quickParseResult.endLexState != TypeScript.LexState.Start) {\r\n                this.logger.log(\"  Bailing out because scope contains unterminated comment\");\r\n                return null;\r\n            }\r\n            var scriptFragment = quickParseResult.Script;\r\n            if(scriptFragment.vars.members.length !== 0) {\r\n                this.logger.log(\"  Bailing out because new source text defines variables\");\r\n                return null;\r\n            }\r\n            if(scriptFragment.bod.members.length !== 1) {\r\n                this.logger.log(\"  Bailing out because new source text defines more than one scope (or none)\");\r\n                return null;\r\n            }\r\n            var oldScope = scope1.scopeStartAST;\r\n            var newScope = scriptFragment.bod.members[0];\r\n            if(oldScope.nodeType != newScope.nodeType) {\r\n                this.logger.log(\"  Bailing out because new source text does not define the same scope type as the existing scope\");\r\n                return null;\r\n            }\r\n            if(!(oldScope).leftCurlyCount || !(oldScope).rightCurlyCount) {\r\n                this.logger.log(\"  Bailing out because sopce doesn't have left/right curly count\");\r\n                return null;\r\n            }\r\n            if((oldScope).leftCurlyCount !== (newScope).leftCurlyCount) {\r\n                this.logger.log(\"  Bailing out because new source text contains more (or fewer) left curly braces\");\r\n                return null;\r\n            }\r\n            if((oldScope).rightCurlyCount !== (newScope).rightCurlyCount) {\r\n                this.logger.log(\"  Bailing out because new source text contains more (or fewer) right curly braces\");\r\n                return null;\r\n            }\r\n            if(newScope.minChar !== 0) {\r\n                this.logger.log(\"  Bailing out because new function declaration does not start at position 0\");\r\n                return null;\r\n            }\r\n            if(newScope.limChar !== newScopeLength) {\r\n                this.logger.log(\"  Bailing out because new function declaration does not end at the new end position\");\r\n                return null;\r\n            }\r\n            return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);\r\n        };\r\n        IncrementalParser.prototype.mergeTrees = function (updateResult) {\r\n            var _this = this;\r\n            TypeScript.timeFunction(this.logger, \"mergeTrees()\", function () {\r\n                var editRange = new TypeScript.ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);\r\n                _this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);\r\n                _this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);\r\n                _this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);\r\n                _this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);\r\n            });\r\n        };\r\n        IncrementalParser.prototype.replaceAST = function (script, oldAst, newAst) {\r\n            var _this = this;\r\n            var pre = function (cur, parent, walker) {\r\n                if(cur === oldAst) {\r\n                    newAst.preComments = cur.preComments;\r\n                    newAst.postComments = cur.postComments;\r\n                    _this.logger.log(\"replaced old AST node with new one in script AST\");\r\n                    walker.options.stopWalk();\r\n                    return newAst;\r\n                }\r\n                if(TypeScript.isValidAstNode(cur)) {\r\n                    if(cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {\r\n                        walker.options.goChildren = false;\r\n                    }\r\n                }\r\n                return cur;\r\n            };\r\n            TypeScript.getAstWalkerFactory().walk(script, pre);\r\n        };\r\n        IncrementalParser.prototype.mergeLocationInfo = function (script, partial, editRange) {\r\n            var lineMap1 = script.locationInfo.lineMap;\r\n            var lineMap2 = partial.locationInfo.lineMap;\r\n            if(this.logger.information()) {\r\n                this.logger.log(\"lineMap1 (before):\");\r\n                this.astLogger.logLinemap(lineMap1);\r\n                this.logger.log(\"lineMap2 (quick parse):\");\r\n                this.astLogger.logLinemap(lineMap2);\r\n                this.logger.log(\"EditRange=\" + editRange);\r\n            }\r\n            var i1 = 2;\r\n            var i2 = 2;\r\n            var len1 = lineMap1.length;\r\n            var len2 = lineMap2.length;\r\n            while(i1 < len1 || i2 < len2) {\r\n                if(i1 < len1) {\r\n                    if(lineMap1[i1] <= editRange.minChar) {\r\n                        i1++;\r\n                    } else {\r\n                        if(lineMap1[i1] >= editRange.limChar) {\r\n                            lineMap1[i1] += editRange.delta;\r\n                            i1++;\r\n                        } else {\r\n                            if(i2 < len2) {\r\n                                lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);\r\n                                i1++;\r\n                                len1++;\r\n                                i2++;\r\n                            } else {\r\n                                lineMap1.splice(i1, 1);\r\n                                len1--;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    lineMap1.push(lineMap2[i2] + editRange.minChar);\r\n                    i2++;\r\n                }\r\n            }\r\n            if(this.logger.information()) {\r\n                this.logger.log(\"lineMap1 (after merge):\");\r\n                this.astLogger.logLinemap(lineMap1);\r\n            }\r\n        };\r\n        IncrementalParser.prototype.applyDeltaPosition = function (ast, start, delta) {\r\n            var applyDelta = function (ast) {\r\n                if(ast.minChar !== -1 && ast.minChar >= start) {\r\n                    ast.minChar += delta;\r\n                }\r\n                if(ast.limChar !== -1 && ast.limChar >= start) {\r\n                    ast.limChar += delta;\r\n                }\r\n            };\r\n            var applyDeltaToComments = function (comments) {\r\n                if(comments && comments.length > 0) {\r\n                    for(var i = 0; i < comments.length; i++) {\r\n                        applyDelta(comments[i]);\r\n                    }\r\n                }\r\n            };\r\n            var pre = function (cur, parent, walker) {\r\n                if(cur.limChar !== -1 && cur.limChar < start) {\r\n                    walker.options.goChildren = false;\r\n                }\r\n                applyDelta(cur);\r\n                applyDeltaToComments(cur.preComments);\r\n                applyDeltaToComments(cur.postComments);\r\n                return cur;\r\n            };\r\n            TypeScript.getAstWalkerFactory().walk(ast, pre);\r\n        };\r\n        return IncrementalParser;\r\n    })();\r\n    TypeScript.IncrementalParser = IncrementalParser;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (UpdateUnitKind) {\r\n        UpdateUnitKind._map = [];\r\n        UpdateUnitKind._map[0] = \"Unknown\";\r\n        UpdateUnitKind.Unknown = 0;\r\n        UpdateUnitKind._map[1] = \"NoEdits\";\r\n        UpdateUnitKind.NoEdits = 1;\r\n        UpdateUnitKind._map[2] = \"EditsInsideSingleScope\";\r\n        UpdateUnitKind.EditsInsideSingleScope = 2;\r\n    })(TypeScript.UpdateUnitKind || (TypeScript.UpdateUnitKind = {}));\r\n    var UpdateUnitKind = TypeScript.UpdateUnitKind;\r\n\r\n    var ScriptEditRange = (function () {\r\n        function ScriptEditRange(minChar, limChar, delta) {\r\n            this.minChar = minChar;\r\n            this.limChar = limChar;\r\n            this.delta = delta;\r\n        }\r\n        ScriptEditRange.unknown = function unknown() {\r\n            return new ScriptEditRange(-1, -1, -1);\r\n        }\r\n        ScriptEditRange.prototype.isUnknown = function () {\r\n            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;\r\n        };\r\n        ScriptEditRange.prototype.containsPosition = function (pos) {\r\n            return (this.minChar <= pos && pos < this.limChar) || (this.minChar <= pos && pos < this.limChar + this.delta);\r\n        };\r\n        ScriptEditRange.prototype.toString = function () {\r\n            return \"editRange(minChar=\" + this.minChar + \", limChar=\" + this.limChar + \", delta=\" + this.delta + \")\";\r\n        };\r\n        return ScriptEditRange;\r\n    })();\r\n    TypeScript.ScriptEditRange = ScriptEditRange;    \r\n    var UpdateUnitResult = (function () {\r\n        function UpdateUnitResult(kind, unitIndex, script1, script2) {\r\n            this.kind = kind;\r\n            this.unitIndex = unitIndex;\r\n            this.script1 = script1;\r\n            this.script2 = script2;\r\n            this.scope1 = null;\r\n            this.scope2 = null;\r\n            this.editRange = null;\r\n            this.parseErrors = [];\r\n        }\r\n        UpdateUnitResult.noEdits = function noEdits(unitIndex) {\r\n            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null);\r\n        }\r\n        UpdateUnitResult.unknownEdits = function unknownEdits(script1, script2, parseErrors) {\r\n            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2);\r\n            result.parseErrors = parseErrors;\r\n            return result;\r\n        }\r\n        UpdateUnitResult.singleScopeEdits = function singleScopeEdits(script1, script2, scope1, scope2, editRange, parseErrors) {\r\n            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2);\r\n            result.scope1 = scope1;\r\n            result.scope2 = scope2;\r\n            result.editRange = editRange;\r\n            result.parseErrors = parseErrors;\r\n            return result;\r\n        }\r\n        return UpdateUnitResult;\r\n    })();\r\n    TypeScript.UpdateUnitResult = UpdateUnitResult;    \r\n    var ErrorEntry = (function () {\r\n        function ErrorEntry(unitIndex, minChar, limChar, message) {\r\n            this.unitIndex = unitIndex;\r\n            this.minChar = minChar;\r\n            this.limChar = limChar;\r\n            this.message = message;\r\n        }\r\n        return ErrorEntry;\r\n    })();\r\n    TypeScript.ErrorEntry = ErrorEntry;    \r\n    TypeScript.defaultSettings = new TypeScript.CompilationSettings();\r\n    var TypeScriptCompiler = (function () {\r\n        function TypeScriptCompiler(outfile, errorOutput, logger, settings) {\r\n            if (typeof logger === \"undefined\") { logger = new TypeScript.NullLogger(); }\r\n            if (typeof settings === \"undefined\") { settings = TypeScript.defaultSettings; }\r\n            this.outfile = outfile;\r\n            this.errorOutput = errorOutput;\r\n            this.logger = logger;\r\n            this.settings = settings;\r\n            this.parser = new TypeScript.Parser();\r\n            this.typeFlow = null;\r\n            this.scripts = new TypeScript.ASTList();\r\n            this.units = new Array();\r\n            this.errorReporter = new TypeScript.ErrorReporter(this.outfile);\r\n            this.persistentTypeState = new TypeScript.PersistentGlobalTypeState(this.errorReporter);\r\n            this.errorReporter.parser = this.parser;\r\n            this.initTypeChecker(this.errorOutput);\r\n            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;\r\n            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;\r\n            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;\r\n            this.emitSettings = {\r\n                minWhitespace: this.settings.minWhitespace,\r\n                propagateConstants: this.settings.propagateConstants,\r\n                emitComments: this.settings.emitComments,\r\n                path: this.settings.outputFileName,\r\n                createFile: null,\r\n                outputMany: this.settings.outputMany\r\n            };\r\n            TypeScript.codeGenTarget = settings.codeGenTarget;\r\n        }\r\n        TypeScriptCompiler.prototype.timeFunction = function (funcDescription, func) {\r\n            return TypeScript.timeFunction(this.logger, funcDescription, func);\r\n        };\r\n        TypeScriptCompiler.prototype.initTypeChecker = function (errorOutput) {\r\n            this.persistentTypeState.refreshPersistentState();\r\n            this.typeChecker = new TypeScript.TypeChecker(this.persistentTypeState);\r\n            this.typeChecker.errorReporter = this.errorReporter;\r\n            this.typeChecker.checkControlFlow = this.settings.controlFlow;\r\n            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;\r\n            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;\r\n            this.typeChecker.errorsOnWith = this.settings.errorOnWith;\r\n            this.typeChecker.styleSettings = this.settings.styleSettings;\r\n            this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;\r\n            this.errorReporter.checker = this.typeChecker;\r\n            this.setErrorOutput(this.errorOutput);\r\n        };\r\n        TypeScriptCompiler.prototype.setErrorOutput = function (outerr) {\r\n            this.errorOutput = outerr;\r\n            this.errorReporter.setErrOut(outerr);\r\n            this.parser.outfile = outerr;\r\n        };\r\n        TypeScriptCompiler.prototype.emitCommentsToOutput = function () {\r\n            this.emitSettings = {\r\n                minWhitespace: this.settings.minWhitespace,\r\n                propagateConstants: this.settings.propagateConstants,\r\n                emitComments: this.settings.emitComments,\r\n                path: this.settings.outputFileName,\r\n                createFile: null,\r\n                outputMany: this.settings.outputMany\r\n            };\r\n        };\r\n        TypeScriptCompiler.prototype.setErrorCallback = function (fn) {\r\n            this.parser.errorCallback = fn;\r\n        };\r\n        TypeScriptCompiler.prototype.updateUnit = function (prog, filename, setRecovery) {\r\n            return this.updateSourceUnit(new TypeScript.StringSourceText(prog), filename, setRecovery);\r\n        };\r\n        TypeScriptCompiler.prototype.updateSourceUnit = function (sourceText, filename, setRecovery) {\r\n            var _this = this;\r\n            return this.timeFunction(\"updateSourceUnit(\" + filename + \")\", function () {\r\n                var updateResult = _this.partialUpdateUnit(sourceText, filename, setRecovery);\r\n                return _this.applyUpdateResult(updateResult);\r\n            });\r\n        };\r\n        TypeScriptCompiler.prototype.applyUpdateResult = function (updateResult) {\r\n            switch(updateResult.kind) {\r\n                case UpdateUnitKind.NoEdits: {\r\n                    return false;\r\n\r\n                }\r\n                case UpdateUnitKind.Unknown: {\r\n                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;\r\n                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;\r\n                    for(var i = 0, len = updateResult.parseErrors.length; i < len; i++) {\r\n                        var e = updateResult.parseErrors[i];\r\n                        if(this.parser.errorCallback) {\r\n                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);\r\n                        }\r\n                    }\r\n                    return true;\r\n\r\n                }\r\n                case UpdateUnitKind.EditsInsideSingleScope: {\r\n                    new TypeScript.IncrementalParser(this.logger).mergeTrees(updateResult);\r\n                    return true;\r\n\r\n                }\r\n            }\r\n        };\r\n        TypeScriptCompiler.prototype.partialUpdateUnit = function (sourceText, filename, setRecovery) {\r\n            var _this = this;\r\n            return this.timeFunction(\"partialUpdateUnit(\" + filename + \")\", function () {\r\n                for(var i = 0, len = _this.units.length; i < len; i++) {\r\n                    if(_this.units[i].filename == filename) {\r\n                        if((_this.scripts.members[i]).isResident) {\r\n                            return UpdateUnitResult.noEdits(i);\r\n                        }\r\n                        if(setRecovery) {\r\n                            _this.parser.setErrorRecovery(null, 0, 0);\r\n                        }\r\n                        var updateResult;\r\n                        var parseErrors = [];\r\n                        var errorCapture = function (minChar, charLen, message, unitIndex) {\r\n                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));\r\n                        };\r\n                        var svErrorCallback = _this.parser.errorCallback;\r\n                        if(svErrorCallback) {\r\n                            _this.parser.errorCallback = errorCapture;\r\n                        }\r\n                        var oldScript = _this.scripts.members[i];\r\n                        var newScript = _this.parser.parse(sourceText, filename, i);\r\n                        if(svErrorCallback) {\r\n                            _this.parser.errorCallback = svErrorCallback;\r\n                        }\r\n                        updateResult = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors);\r\n                        return updateResult;\r\n                    }\r\n                }\r\n                throw new Error(\"Unknown file \\\"\" + filename + \"\\\"\");\r\n            });\r\n        };\r\n        TypeScriptCompiler.prototype.addUnit = function (prog, filename, keepResident) {\r\n            if (typeof keepResident === \"undefined\") { keepResident = false; }\r\n            return this.addSourceUnit(new TypeScript.StringSourceText(prog), filename, keepResident);\r\n        };\r\n        TypeScriptCompiler.prototype.addSourceUnit = function (sourceText, filename, keepResident) {\r\n            if (typeof keepResident === \"undefined\") { keepResident = false; }\r\n            var _this = this;\r\n            return this.timeFunction(\"addSourceUnit(\" + filename + \", \" + keepResident + \")\", function () {\r\n                var script = _this.parser.parse(sourceText, filename, _this.units.length, TypeScript.AllowedElements.Global);\r\n                script.isResident = keepResident;\r\n                _this.persistentTypeState.setCollectionMode(keepResident ? TypeScript.TypeCheckCollectionMode.Resident : TypeScript.TypeCheckCollectionMode.Transient);\r\n                var index = _this.units.length;\r\n                _this.units[index] = script.locationInfo;\r\n                _this.typeChecker.collectTypes(script);\r\n                _this.scripts.append(script);\r\n                return script;\r\n            });\r\n        };\r\n        TypeScriptCompiler.prototype.parseUnit = function (prog, filename) {\r\n            return this.parseSourceUnit(new TypeScript.StringSourceText(prog), filename);\r\n        };\r\n        TypeScriptCompiler.prototype.parseSourceUnit = function (sourceText, filename) {\r\n            this.parser.setErrorRecovery(this.outfile, -1, -1);\r\n            var script = this.parser.parse(sourceText, filename, 0);\r\n            var context = new TypeScript.PrintContext(this.outfile, this.parser);\r\n            TypeScript.getAstWalkerFactory().walk(script, TypeScript.prePrintAST, TypeScript.postPrintAST, null, context);\r\n        };\r\n        TypeScriptCompiler.prototype.typeCheck = function () {\r\n            var _this = this;\r\n            return this.timeFunction(\"typeCheck()\", function () {\r\n                var binder = new TypeScript.Binder(_this.typeChecker);\r\n                _this.typeChecker.units = _this.units;\r\n                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.globals);\r\n                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.ambientGlobals);\r\n                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.globalTypes);\r\n                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.ambientGlobalTypes);\r\n                _this.typeFlow = new TypeScript.TypeFlow(_this.logger, _this.typeChecker.globalScope, _this.parser, _this.typeChecker);\r\n                var i = 0;\r\n                var script = null;\r\n                var len = _this.scripts.members.length;\r\n                _this.persistentTypeState.setCollectionMode(TypeScript.TypeCheckCollectionMode.Resident);\r\n                for(i = 0; i < len; i++) {\r\n                    script = _this.scripts.members[i];\r\n                    if(!script.isResident || script.hasBeenTypeChecked) {\r\n                        continue;\r\n                    }\r\n                    _this.typeFlow.assignScopes(script);\r\n                    _this.typeFlow.initLibs();\r\n                }\r\n                for(i = 0; i < len; i++) {\r\n                    script = _this.scripts.members[i];\r\n                    if(!script.isResident || script.hasBeenTypeChecked) {\r\n                        continue;\r\n                    }\r\n                    _this.typeFlow.typeCheck(script);\r\n                    script.hasBeenTypeChecked = true;\r\n                }\r\n                _this.persistentTypeState.setCollectionMode(TypeScript.TypeCheckCollectionMode.Transient);\r\n                len = _this.scripts.members.length;\r\n                for(i = 0; i < len; i++) {\r\n                    script = _this.scripts.members[i];\r\n                    if(script.isResident) {\r\n                        continue;\r\n                    }\r\n                    _this.typeFlow.assignScopes(script);\r\n                    _this.typeFlow.initLibs();\r\n                }\r\n                for(i = 0; i < len; i++) {\r\n                    script = _this.scripts.members[i];\r\n                    if(script.isResident) {\r\n                        continue;\r\n                    }\r\n                    _this.typeFlow.typeCheck(script);\r\n                }\r\n                return null;\r\n            });\r\n        };\r\n        TypeScriptCompiler.prototype.cleanASTTypesForReTypeCheck = function (ast) {\r\n            function cleanASTType(ast, parent) {\r\n                ast.type = null;\r\n                if(ast.nodeType == TypeScript.NodeType.VarDecl) {\r\n                    var vardecl = ast;\r\n                    vardecl.sym = null;\r\n                } else {\r\n                    if(ast.nodeType == TypeScript.NodeType.ArgDecl) {\r\n                        var argdecl = ast;\r\n                        argdecl.sym = null;\r\n                    } else {\r\n                        if(ast.nodeType == TypeScript.NodeType.Name) {\r\n                            var name = ast;\r\n                            name.sym = null;\r\n                        } else {\r\n                            if(ast.nodeType == TypeScript.NodeType.FuncDecl) {\r\n                                var funcdecl = ast;\r\n                                funcdecl.signature = null;\r\n                                funcdecl.freeVariables = new Array();\r\n                                funcdecl.symbols = null;\r\n                                funcdecl.accessorSymbol = null;\r\n                                funcdecl.scopeType = null;\r\n                            } else {\r\n                                if(ast.nodeType == TypeScript.NodeType.Module) {\r\n                                    var modDecl = ast;\r\n                                    modDecl.mod = null;\r\n                                } else {\r\n                                    if(ast.nodeType == TypeScript.NodeType.With) {\r\n                                        (ast).withSym = null;\r\n                                    } else {\r\n                                        if(ast.nodeType == TypeScript.NodeType.Catch) {\r\n                                            (ast).containedScope = null;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return ast;\r\n            }\r\n            TypeScript.getAstWalkerFactory().walk(ast, cleanASTType);\r\n        };\r\n        TypeScriptCompiler.prototype.cleanTypesForReTypeCheck = function () {\r\n            var _this = this;\r\n            return this.timeFunction(\"cleanTypesForReTypeCheck()\", function () {\r\n                for(var i = 0, len = _this.scripts.members.length; i < len; i++) {\r\n                    var script = _this.scripts.members[i];\r\n                    if((script).isResident) {\r\n                        continue;\r\n                    }\r\n                    _this.cleanASTTypesForReTypeCheck(script);\r\n                    _this.typeChecker.collectTypes(script);\r\n                }\r\n                return null;\r\n            });\r\n        };\r\n        TypeScriptCompiler.prototype.attemptIncrementalTypeCheck = function (updateResult) {\r\n            return this.timeFunction(\"attemptIncrementalTypeCheck()\", function () {\r\n                return false;\r\n            });\r\n        };\r\n        TypeScriptCompiler.prototype.reTypeCheck = function () {\r\n            var _this = this;\r\n            return this.timeFunction(\"reTypeCheck()\", function () {\r\n                TypeScript.CompilerDiagnostics.analysisPass++;\r\n                _this.initTypeChecker(_this.errorOutput);\r\n                _this.persistentTypeState.setCollectionMode(TypeScript.TypeCheckCollectionMode.Transient);\r\n                _this.cleanTypesForReTypeCheck();\r\n                return _this.typeCheck();\r\n            });\r\n        };\r\n        TypeScriptCompiler.prototype.emit = function (outputMany, createFile) {\r\n            var emitter = null;\r\n            this.emitSettings.createFile = createFile;\r\n            for(var i = 0, len = this.scripts.members.length; i < len; i++) {\r\n                var script = this.scripts.members[i];\r\n                if(!script.emitRequired()) {\r\n                    continue;\r\n                }\r\n                var outf = this.outfile;\r\n                if(outputMany) {\r\n                    var fname = this.units[i].filename;\r\n                    var splitFname = fname.split(\".\");\r\n                    splitFname.pop();\r\n                    var baseName = splitFname.join(\".\");\r\n                    var outFname = baseName + \".js\";\r\n                    this.emitSettings.path = outFname;\r\n                    outf = createFile(outFname);\r\n                    emitter = new TypeScript.Emitter(this.typeChecker, outf, this.emitSettings);\r\n                    if(this.settings.mapSourceFiles) {\r\n                        emitter.setSourceMappings(new TypeScript.SourceMapper(fname, outFname, outf, createFile(outFname + TypeScript.SourceMapper.MapFileExtension)));\r\n                    }\r\n                    if(this.settings.generateDeclarationFiles) {\r\n                        var declareFileName = TypeScript.isSTRFile(fname) ? TypeScript.changePathToDSTR(fname) : TypeScript.isTSFile(fname) ? TypeScript.changePathToDTS(fname) : TypeScript.changePathToDTS(fname);\r\n                        emitter.setDeclarationFile(createFile(declareFileName));\r\n                    }\r\n                } else {\r\n                    if(emitter == null) {\r\n                        emitter = new TypeScript.Emitter(this.typeChecker, this.outfile, this.emitSettings);\r\n                        if(this.settings.mapSourceFiles) {\r\n                            emitter.setSourceMappings(new TypeScript.SourceMapper(script.locationInfo.filename, this.settings.outputFileName, this.outfile, createFile(this.settings.outputFileName + TypeScript.SourceMapper.MapFileExtension)));\r\n                        }\r\n                        if(this.settings.generateDeclarationFiles) {\r\n                            var outfname = this.settings.outputFileName;\r\n                            outfname = TypeScript.isSTRFile(outfname) ? TypeScript.changePathToDSTR(outfname) : TypeScript.isTSFile(outfname) ? TypeScript.changePathToDTS(outfname) : TypeScript.changePathToDTS(outfname);\r\n                            emitter.setDeclarationFile(createFile(outfname));\r\n                        }\r\n                    } else {\r\n                        if(this.settings.mapSourceFiles) {\r\n                            emitter.setSourceMappings(new TypeScript.SourceMapper(script.locationInfo.filename, emitter.sourceMapper.jsFileName, this.outfile, emitter.sourceMapper.sourceMapOut));\r\n                        }\r\n                    }\r\n                }\r\n                this.typeChecker.locationInfo = script.locationInfo;\r\n                emitter.emitJavascript(script, TypeScript.TokenID.Comma, false, emitter.canWriteDeclFile());\r\n                if(outputMany) {\r\n                    if(this.settings.mapSourceFiles) {\r\n                        emitter.emitSourceMappings();\r\n                    }\r\n                    if(this.settings.generateDeclarationFiles) {\r\n                        emitter.declFile.Close();\r\n                    }\r\n                    outf.Close();\r\n                }\r\n            }\r\n            if(!outputMany) {\r\n                if(this.settings.mapSourceFiles) {\r\n                    emitter.emitSourceMappings();\r\n                }\r\n                if(this.settings.generateDeclarationFiles) {\r\n                    emitter.declFile.Close();\r\n                }\r\n            }\r\n        };\r\n        TypeScriptCompiler.prototype.emitToOutfile = function () {\r\n            var emitter = null;\r\n            if(this.settings.mapSourceFiles) {\r\n                throw Error(\"Cannot generate source map\");\r\n            }\r\n            if(this.settings.generateDeclarationFiles) {\r\n                throw Error(\"Cannot generate declaration files\");\r\n            }\r\n            for(var i = 0, len = this.scripts.members.length; i < len; i++) {\r\n                if(emitter == null) {\r\n                    emitter = new TypeScript.Emitter(this.typeChecker, this.outfile, this.emitSettings);\r\n                }\r\n                var script = this.scripts.members[i];\r\n                this.typeChecker.locationInfo = script.locationInfo;\r\n                emitter.emitJavascript(script, TypeScript.TokenID.Comma, false);\r\n            }\r\n        };\r\n        return TypeScriptCompiler;\r\n    })();\r\n    TypeScript.TypeScriptCompiler = TypeScriptCompiler;    \r\n    var ScopeEntry = (function () {\r\n        function ScopeEntry(name, type, sym) {\r\n            this.name = name;\r\n            this.type = type;\r\n            this.sym = sym;\r\n        }\r\n        return ScopeEntry;\r\n    })();\r\n    TypeScript.ScopeEntry = ScopeEntry;    \r\n    var ScopeTraversal = (function () {\r\n        function ScopeTraversal(compiler) {\r\n            this.compiler = compiler;\r\n        }\r\n        ScopeTraversal.prototype.getScope = function (enclosingScopeContext) {\r\n            if(enclosingScopeContext.enclosingObjectLit && enclosingScopeContext.isMemberCompletion) {\r\n                return enclosingScopeContext.getObjectLiteralScope();\r\n            } else {\r\n                if(enclosingScopeContext.isMemberCompletion) {\r\n                    if(enclosingScopeContext.useFullAst) {\r\n                        return this.compiler.typeFlow.findMemberScopeAtFullAst(enclosingScopeContext);\r\n                    } else {\r\n                        return this.compiler.typeFlow.findMemberScopeAt(enclosingScopeContext);\r\n                    }\r\n                } else {\r\n                    return enclosingScopeContext.getScope();\r\n                }\r\n            }\r\n        };\r\n        ScopeTraversal.prototype.getScopeEntries = function (enclosingScopeContext) {\r\n            var scope = this.getScope(enclosingScopeContext);\r\n            if(scope == null) {\r\n                return [];\r\n            }\r\n            var inScopeNames = new TypeScript.StringHashTable();\r\n            var allSymbolNames = scope.getAllSymbolNames(enclosingScopeContext.isMemberCompletion);\r\n            for(var i = 0; i < allSymbolNames.length; i++) {\r\n                var name = allSymbolNames[i];\r\n                if(name == TypeScript.globalId || name == \"_Core\" || name == \"_element\") {\r\n                    continue;\r\n                }\r\n                inScopeNames.add(name, \"\");\r\n            }\r\n            var svModuleDecl = this.compiler.typeChecker.currentModDecl;\r\n            this.compiler.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;\r\n            var result = this.getTypeNamesForNames(enclosingScopeContext, inScopeNames.getAllKeys(), scope);\r\n            this.compiler.typeChecker.currentModDecl = svModuleDecl;\r\n            return result;\r\n        };\r\n        ScopeTraversal.prototype.getTypeNamesForNames = function (enclosingScopeContext, allNames, scope) {\r\n            var result = [];\r\n            var enclosingScope = enclosingScopeContext.getScope();\r\n            for(var i = 0; i < allNames.length; i++) {\r\n                var name = allNames[i];\r\n                var publicsOnly = enclosingScopeContext.publicsOnly && enclosingScopeContext.isMemberCompletion;\r\n                var symbol = scope.find(name, publicsOnly, false);\r\n                if(symbol == null) {\r\n                    symbol = scope.find(name, publicsOnly, true);\r\n                }\r\n                var displayThisMember = symbol && symbol.flags & TypeScript.SymbolFlags.Private ? symbol.container == scope.container : true;\r\n                if(symbol) {\r\n                    if(displayThisMember && !TypeScript.isQuoted(symbol.name) && !TypeScript.isRelative(symbol.name)) {\r\n                        var typeName = symbol.getType().getScopedTypeName(enclosingScope);\r\n                        result.push(new ScopeEntry(name, typeName, symbol));\r\n                    }\r\n                } else {\r\n                    if(name == \"true\" || name == \"false\") {\r\n                        result.push(new ScopeEntry(name, \"bool\", this.compiler.typeChecker.booleanType.symbol));\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        return ScopeTraversal;\r\n    })();\r\n    TypeScript.ScopeTraversal = ScopeTraversal;    \r\n})(TypeScript || (TypeScript = {}));\r\n\r\nvar TypeScript;\r\n(function (TypeScript) {\r\n    (function (CompilerDiagnostics) {\r\n        CompilerDiagnostics.debug = false;\r\n        CompilerDiagnostics.diagnosticWriter = null;\r\n        CompilerDiagnostics.analysisPass = 0;\r\n        function Alert(output) {\r\n            if(CompilerDiagnostics.diagnosticWriter) {\r\n                CompilerDiagnostics.diagnosticWriter.Alert(output);\r\n            }\r\n        }\r\n        CompilerDiagnostics.Alert = Alert;\r\n        function debugPrint(s) {\r\n            if(CompilerDiagnostics.debug) {\r\n                Alert(s);\r\n            }\r\n        }\r\n        CompilerDiagnostics.debugPrint = debugPrint;\r\n        function assert(condition, s) {\r\n            if(CompilerDiagnostics.debug) {\r\n                if(!condition) {\r\n                    Alert(s);\r\n                }\r\n            }\r\n        }\r\n        CompilerDiagnostics.assert = assert;\r\n    })(TypeScript.CompilerDiagnostics || (TypeScript.CompilerDiagnostics = {}));\r\n    var CompilerDiagnostics = TypeScript.CompilerDiagnostics;\r\n\r\n    var NullLogger = (function () {\r\n        function NullLogger() { }\r\n        NullLogger.prototype.information = function () {\r\n            return false;\r\n        };\r\n        NullLogger.prototype.debug = function () {\r\n            return false;\r\n        };\r\n        NullLogger.prototype.warning = function () {\r\n            return false;\r\n        };\r\n        NullLogger.prototype.error = function () {\r\n            return false;\r\n        };\r\n        NullLogger.prototype.fatal = function () {\r\n            return false;\r\n        };\r\n        NullLogger.prototype.log = function (s) {\r\n        };\r\n        return NullLogger;\r\n    })();\r\n    TypeScript.NullLogger = NullLogger;    \r\n    var LoggerAdapter = (function () {\r\n        function LoggerAdapter(logger) {\r\n            this.logger = logger;\r\n            this._information = this.logger.information();\r\n            this._debug = this.logger.debug();\r\n            this._warning = this.logger.warning();\r\n            this._error = this.logger.error();\r\n            this._fatal = this.logger.fatal();\r\n        }\r\n        LoggerAdapter.prototype.information = function () {\r\n            return this._information;\r\n        };\r\n        LoggerAdapter.prototype.debug = function () {\r\n            return this._debug;\r\n        };\r\n        LoggerAdapter.prototype.warning = function () {\r\n            return this._warning;\r\n        };\r\n        LoggerAdapter.prototype.error = function () {\r\n            return this._error;\r\n        };\r\n        LoggerAdapter.prototype.fatal = function () {\r\n            return this._fatal;\r\n        };\r\n        LoggerAdapter.prototype.log = function (s) {\r\n            this.logger.log(s);\r\n        };\r\n        return LoggerAdapter;\r\n    })();\r\n    TypeScript.LoggerAdapter = LoggerAdapter;    \r\n    var BufferedLogger = (function () {\r\n        function BufferedLogger() {\r\n            this.logContents = [];\r\n        }\r\n        BufferedLogger.prototype.information = function () {\r\n            return false;\r\n        };\r\n        BufferedLogger.prototype.debug = function () {\r\n            return false;\r\n        };\r\n        BufferedLogger.prototype.warning = function () {\r\n            return false;\r\n        };\r\n        BufferedLogger.prototype.error = function () {\r\n            return false;\r\n        };\r\n        BufferedLogger.prototype.fatal = function () {\r\n            return false;\r\n        };\r\n        BufferedLogger.prototype.log = function (s) {\r\n            this.logContents.push(s);\r\n        };\r\n        return BufferedLogger;\r\n    })();\r\n    TypeScript.BufferedLogger = BufferedLogger;    \r\n    function timeFunction(logger, funcDescription, func) {\r\n        var start = +new Date();\r\n        var result = func();\r\n        var end = +new Date();\r\n        logger.log(funcDescription + \" completed in \" + (end - start) + \" msec\");\r\n        return result;\r\n    }\r\n    TypeScript.timeFunction = timeFunction;\r\n    function stringToLiteral(value, length) {\r\n        var result = \"\";\r\n        var addChar = function (index) {\r\n            var ch = value.charCodeAt(index);\r\n            switch(ch) {\r\n                case 9: {\r\n                    result += \"\\\\t\";\r\n                    break;\r\n\r\n                }\r\n                case 10: {\r\n                    result += \"\\\\n\";\r\n                    break;\r\n\r\n                }\r\n                case 11: {\r\n                    result += \"\\\\v\";\r\n                    break;\r\n\r\n                }\r\n                case 12: {\r\n                    result += \"\\\\f\";\r\n                    break;\r\n\r\n                }\r\n                case 13: {\r\n                    result += \"\\\\r\";\r\n                    break;\r\n\r\n                }\r\n                case 34: {\r\n                    result += \"\\\\\\\"\";\r\n                    break;\r\n\r\n                }\r\n                case 39: {\r\n                    result += \"\\\\\\'\";\r\n                    break;\r\n\r\n                }\r\n                case 92: {\r\n                    result += \"\\\\\";\r\n                    break;\r\n\r\n                }\r\n                default: {\r\n                    result += value.charAt(index);\r\n\r\n                }\r\n            }\r\n        };\r\n        var tooLong = (value.length > length);\r\n        if(tooLong) {\r\n            var mid = length >> 1;\r\n            for(var i = 0; i < mid; i++) {\r\n                addChar(i);\r\n            }\r\n            result += \"(...)\";\r\n            for(var i = value.length - mid; i < value.length; i++) {\r\n                addChar(i);\r\n            }\r\n        } else {\r\n            length = value.length;\r\n            for(var i = 0; i < length; i++) {\r\n                addChar(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    TypeScript.stringToLiteral = stringToLiteral;\r\n})(TypeScript || (TypeScript = {}));\r\n\r\n\r\n\r\nvar IO = (function () {\r\n    function getWindowsScriptHostIO() {\r\n        var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\r\n        var args = [];\r\n        for(var i = 0; i < WScript.Arguments.length; i++) {\r\n            args[i] = WScript.Arguments.Item(i);\r\n        }\r\n        return {\r\n            readFile: function (path) {\r\n                try  {\r\n                    var file = fso.OpenTextFile(path);\r\n                    var bomChar = !file.AtEndOfStream ? file.Read(2) : '';\r\n                    var str = bomChar;\r\n                    if((bomChar.charCodeAt(0) == 254 && bomChar.charCodeAt(1) == 255) || (bomChar.charCodeAt(0) == 255 && bomChar.charCodeAt(1) == 254)) {\r\n                        file.close();\r\n                        file = fso.OpenTextFile(path, 1, false, -1);\r\n                        str = '';\r\n                    }\r\n                    if(!file.AtEndOfStream) {\r\n                        str += file.ReadAll();\r\n                    }\r\n                    file.close();\r\n                    return str;\r\n                } catch (err) {\r\n                    throw new Error(\"Error reading file \\\"\" + path + \"\\\": \" + err.message);\r\n                }\r\n            },\r\n            writeFile: function (path, contents) {\r\n                var file = fso.OpenTextFile(path, 2, true);\r\n                file.Write(contents);\r\n                file.Close();\r\n            },\r\n            fileExists: function (path) {\r\n                return fso.FileExists(path);\r\n            },\r\n            resolvePath: function (path) {\r\n                return fso.GetAbsolutePathName(path);\r\n            },\r\n            dirName: function (path) {\r\n                return fso.GetParentFolderName(path);\r\n            },\r\n            findFile: function (rootPath, partialFilePath) {\r\n                var path = fso.GetAbsolutePathName(rootPath) + \"/\" + partialFilePath;\r\n                while(true) {\r\n                    if(fso.FileExists(path)) {\r\n                        try  {\r\n                            var content = this.readFile(path);\r\n                            return {\r\n                                content: content,\r\n                                path: path\r\n                            };\r\n                        } catch (err) {\r\n                        }\r\n                    } else {\r\n                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));\r\n                        if(rootPath == \"\") {\r\n                            return null;\r\n                        } else {\r\n                            path = fso.BuildPath(rootPath, partialFilePath);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            deleteFile: function (path) {\r\n                if(fso.FileExists(path)) {\r\n                    fso.DeleteFile(path, true);\r\n                }\r\n            },\r\n            createFile: function (path) {\r\n                try  {\r\n                    return fso.CreateTextFile(path, true, false);\r\n                } catch (ex) {\r\n                    WScript.StdErr.WriteLine(\"Couldn't write to file '\" + path + \"'\");\r\n                    throw ex;\r\n                }\r\n            },\r\n            directoryExists: function (path) {\r\n                return fso.FolderExists(path);\r\n            },\r\n            createDirectory: function (path) {\r\n                if(!this.directoryExists(path)) {\r\n                    fso.CreateFolder(path);\r\n                }\r\n            },\r\n            dir: function (path, spec, options) {\r\n                options = options || {\r\n                };\r\n                function filesInFolder(folder, root) {\r\n                    var paths = [];\r\n                    var fc;\r\n                    if(options.recursive) {\r\n                        fc = new Enumerator(folder.subfolders);\r\n                        for(; !fc.atEnd(); fc.moveNext()) {\r\n                            paths = paths.concat(filesInFolder(fc.item(), root + \"\\\\\" + fc.item().Name));\r\n                        }\r\n                    }\r\n                    fc = new Enumerator(folder.files);\r\n                    for(; !fc.atEnd(); fc.moveNext()) {\r\n                        if(!spec || fc.item().Name.match(spec)) {\r\n                            paths.push(root + \"\\\\\" + fc.item().Name);\r\n                        }\r\n                    }\r\n                    return paths;\r\n                }\r\n                var folder = fso.GetFolder(path);\r\n                var paths = [];\r\n                return filesInFolder(folder, path);\r\n            },\r\n            print: function (str) {\r\n                WScript.StdOut.Write(str);\r\n            },\r\n            printLine: function (str) {\r\n                WScript.Echo(str);\r\n            },\r\n            arguments: args,\r\n            stderr: WScript.StdErr,\r\n            watchFiles: null,\r\n            run: function (source, filename) {\r\n                eval(source);\r\n            },\r\n            getExecutingFilePath: function () {\r\n                return WScript.ScriptFullName;\r\n            },\r\n            quit: function (exitCode) {\r\n                if (typeof exitCode === \"undefined\") { exitCode = 0; }\r\n                try  {\r\n                    WScript.Quit(exitCode);\r\n                } catch (e) {\r\n                }\r\n            }\r\n        };\r\n    }\r\n    ; ;\r\n    function getNodeIO() {\r\n        var _fs = require('fs');\r\n        var _path = require('path');\r\n        var _module = require('module');\r\n        return {\r\n            readFile: function (file) {\r\n                var buffer = _fs.readFileSync(file);\r\n                switch(buffer[0]) {\r\n                    case 254: {\r\n                        if(buffer[1] == 255) {\r\n                            var i = 0;\r\n                            while((i + 1) < buffer.length) {\r\n                                var temp = buffer[i];\r\n                                buffer[i] = buffer[i + 1];\r\n                                buffer[i + 1] = temp;\r\n                                i += 2;\r\n                            }\r\n                            return buffer.toString(\"ucs2\", 2);\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case 255: {\r\n                        if(buffer[1] == 254) {\r\n                            return buffer.toString(\"ucs2\", 2);\r\n                        }\r\n                        break;\r\n\r\n                    }\r\n                    case 239: {\r\n                        if(buffer[1] == 187) {\r\n                            return buffer.toString(\"utf8\", 3);\r\n                        }\r\n\r\n                    }\r\n                }\r\n                return buffer.toString();\r\n            },\r\n            writeFile: _fs.writeFileSync,\r\n            deleteFile: function (path) {\r\n                try  {\r\n                    _fs.unlinkSync(path);\r\n                } catch (e) {\r\n                }\r\n            },\r\n            fileExists: function (path) {\r\n                return _fs.existsSync(path);\r\n            },\r\n            createFile: function (path) {\r\n                function mkdirRecursiveSync(path) {\r\n                    var stats = _fs.statSync(path);\r\n                    if(stats.isFile()) {\r\n                        throw \"\\\"\" + path + \"\\\" exists but isn't a directory.\";\r\n                    } else {\r\n                        if(stats.isDirectory()) {\r\n                            return;\r\n                        } else {\r\n                            mkdirRecursiveSync(_path.dirname(path));\r\n                            _fs.mkdirSync(path, 509);\r\n                        }\r\n                    }\r\n                }\r\n                mkdirRecursiveSync(_path.dirname(path));\r\n                var fd = _fs.openSync(path, 'w');\r\n                return {\r\n                    Write: function (str) {\r\n                        _fs.writeSync(fd, str);\r\n                    },\r\n                    WriteLine: function (str) {\r\n                        _fs.writeSync(fd, str + '\\r\\n');\r\n                    },\r\n                    Close: function () {\r\n                        _fs.closeSync(fd);\r\n                        fd = null;\r\n                    }\r\n                };\r\n            },\r\n            dir: function dir(path, spec, options) {\r\n                options = options || {\r\n                };\r\n                function filesInFolder(folder) {\r\n                    var paths = [];\r\n                    var files = _fs.readdirSync(folder);\r\n                    for(var i = 0; i < files.length; i++) {\r\n                        var stat = _fs.statSync(folder + \"\\\\\" + files[i]);\r\n                        if(options.recursive && stat.isDirectory()) {\r\n                            paths = paths.concat(filesInFolder(folder + \"\\\\\" + files[i]));\r\n                        } else {\r\n                            if(stat.isFile() && (!spec || files[i].match(spec))) {\r\n                                paths.push(folder + \"\\\\\" + files[i]);\r\n                            }\r\n                        }\r\n                    }\r\n                    return paths;\r\n                }\r\n                return filesInFolder(path);\r\n            },\r\n            createDirectory: function (path) {\r\n                if(!this.directoryExists(path)) {\r\n                    _fs.mkdirSync(path);\r\n                }\r\n            },\r\n            directoryExists: function (path) {\r\n                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();\r\n            },\r\n            resolvePath: function (path) {\r\n                return _path.resolve(path);\r\n            },\r\n            dirName: function (path) {\r\n                return _path.dirname(path);\r\n            },\r\n            findFile: function (rootPath, partialFilePath) {\r\n                var path = rootPath + \"/\" + partialFilePath;\r\n                while(true) {\r\n                    if(_fs.existsSync(path)) {\r\n                        try  {\r\n                            var content = this.readFile(path);\r\n                            return {\r\n                                content: content,\r\n                                path: path\r\n                            };\r\n                        } catch (err) {\r\n                        }\r\n                    } else {\r\n                        var parentPath = _path.resolve(rootPath, \"..\");\r\n                        if(rootPath === parentPath) {\r\n                            return null;\r\n                        } else {\r\n                            rootPath = parentPath;\r\n                            path = _path.resolve(rootPath, partialFilePath);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            print: function (str) {\r\n                process.stdout.write(str);\r\n            },\r\n            printLine: function (str) {\r\n                process.stdout.write(str + '\\n');\r\n            },\r\n            arguments: process.argv.slice(2),\r\n            stderr: {\r\n                Write: function (str) {\r\n                    process.stderr.write(str);\r\n                },\r\n                WriteLine: function (str) {\r\n                    process.stderr.write(str + '\\n');\r\n                },\r\n                Close: function () {\r\n                }\r\n            },\r\n            watchFiles: function (files, callback) {\r\n                var watchers = [];\r\n                var firstRun = true;\r\n                var isWindows = /^win/.test(process.platform);\r\n                var processingChange = false;\r\n                var fileChanged = function (e, fn) {\r\n                    if(!firstRun && !isWindows) {\r\n                        for(var i = 0; i < files.length; ++i) {\r\n                            _fs.unwatchFile(files[i]);\r\n                        }\r\n                    }\r\n                    firstRun = false;\r\n                    if(!processingChange) {\r\n                        processingChange = true;\r\n                        callback();\r\n                        setTimeout(function () {\r\n                            processingChange = false;\r\n                        }, 100);\r\n                    }\r\n                    if(isWindows && watchers.length === 0) {\r\n                        for(var i = 0; i < files.length; ++i) {\r\n                            var watcher = _fs.watch(files[i], fileChanged);\r\n                            watchers.push(watcher);\r\n                            watcher.on('error', function (e) {\r\n                                process.stderr.write(\"ERROR\" + e);\r\n                            });\r\n                        }\r\n                    } else {\r\n                        if(!isWindows) {\r\n                            for(var i = 0; i < files.length; ++i) {\r\n                                _fs.watchFile(files[i], {\r\n                                    interval: 500\r\n                                }, fileChanged);\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                fileChanged();\r\n                return true;\r\n            },\r\n            run: function (source, filename) {\r\n                require.main.filename = filename;\r\n                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));\r\n                require.main._compile(source, filename);\r\n            },\r\n            getExecutingFilePath: function () {\r\n                return process.mainModule.filename;\r\n            },\r\n            quit: process.exit\r\n        };\r\n    }\r\n    ; ;\r\n    if(typeof ActiveXObject === \"function\") {\r\n        return getWindowsScriptHostIO();\r\n    } else {\r\n        if(typeof require === \"function\") {\r\n            return getNodeIO();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n})();\r\nvar OptionsParser = (function () {\r\n    function OptionsParser(host) {\r\n        this.host = host;\r\n        this.DEFAULT_SHORT_FLAG = \"-\";\r\n        this.DEFAULT_LONG_FLAG = \"--\";\r\n        this.unnamed = [];\r\n        this.options = [];\r\n    }\r\n    OptionsParser.prototype.findOption = function (arg) {\r\n        for(var i = 0; i < this.options.length; i++) {\r\n            if(arg === this.options[i].short || arg === this.options[i].name) {\r\n                return this.options[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    OptionsParser.prototype.printUsage = function () {\r\n        this.host.printLine(\"Syntax:   tsc [options] [file ..]\");\r\n        this.host.printLine(\"\");\r\n        this.host.printLine(\"Examples: tsc hello.ts\");\r\n        this.host.printLine(\"          tsc --out foo.js foo.ts\");\r\n        this.host.printLine(\"          tsc @args.txt\");\r\n        this.host.printLine(\"\");\r\n        this.host.printLine(\"Options:\");\r\n        var output = [];\r\n        var maxLength = 0;\r\n        this.options = this.options.sort(function (a, b) {\r\n            var aName = a.name.toLowerCase();\r\n            var bName = b.name.toLowerCase();\r\n            if(aName > bName) {\r\n                return 1;\r\n            } else {\r\n                if(aName < bName) {\r\n                    return -1;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n        });\r\n        for(var i = 0; i < this.options.length; i++) {\r\n            var option = this.options[i];\r\n            if(option.experimental) {\r\n                continue;\r\n            }\r\n            if(!option.usage) {\r\n                break;\r\n            }\r\n            var usageString = \"  \";\r\n            var type = option.type ? \" \" + option.type.toUpperCase() : \"\";\r\n            if(option.short) {\r\n                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + \", \";\r\n            }\r\n            usageString += this.DEFAULT_LONG_FLAG + option.name + type;\r\n            output.push([\r\n                usageString, \r\n                option.usage\r\n            ]);\r\n            if(usageString.length > maxLength) {\r\n                maxLength = usageString.length;\r\n            }\r\n        }\r\n        output.push([\r\n            \"  @<file>\", \r\n            \"Insert command line options and files from a file.\"\r\n        ]);\r\n        for(var i = 0; i < output.length; i++) {\r\n            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(\" \") + output[i][1]);\r\n        }\r\n    };\r\n    OptionsParser.prototype.option = function (name, config, short) {\r\n        if(!config) {\r\n            config = short;\r\n            short = null;\r\n        }\r\n        config.name = name;\r\n        config.short = short;\r\n        config.flag = false;\r\n        this.options.push(config);\r\n    };\r\n    OptionsParser.prototype.flag = function (name, config, short) {\r\n        if(!config) {\r\n            config = short;\r\n            short = null;\r\n        }\r\n        config.name = name;\r\n        config.short = short;\r\n        config.flag = true;\r\n        this.options.push(config);\r\n    };\r\n    OptionsParser.prototype.parseString = function (argString) {\r\n        var position = 0;\r\n        var tokens = argString.match(/\\s+|\"|[^\\s\"]+/g);\r\n        function peek() {\r\n            return tokens[position];\r\n        }\r\n        function consume() {\r\n            return tokens[position++];\r\n        }\r\n        function consumeQuotedString() {\r\n            var value = '';\r\n            consume();\r\n            var token = peek();\r\n            while(token && token !== '\"') {\r\n                consume();\r\n                value += token;\r\n                token = peek();\r\n            }\r\n            consume();\r\n            return value;\r\n        }\r\n        var args = [];\r\n        var currentArg = '';\r\n        while(position < tokens.length) {\r\n            var token = peek();\r\n            if(token === '\"') {\r\n                currentArg += consumeQuotedString();\r\n            } else {\r\n                if(token.match(/\\s/)) {\r\n                    if(currentArg.length > 0) {\r\n                        args.push(currentArg);\r\n                        currentArg = '';\r\n                    }\r\n                    consume();\r\n                } else {\r\n                    consume();\r\n                    currentArg += token;\r\n                }\r\n            }\r\n        }\r\n        if(currentArg.length > 0) {\r\n            args.push(currentArg);\r\n        }\r\n        this.parse(args);\r\n    };\r\n    OptionsParser.prototype.parse = function (args) {\r\n        var position = 0;\r\n        function consume() {\r\n            return args[position++];\r\n        }\r\n        while(position < args.length) {\r\n            var current = consume();\r\n            var match = current.match(/^(--?|@)(.*)/);\r\n            var value = null;\r\n            if(match) {\r\n                if(match[1] === '@') {\r\n                    this.parseString(this.host.readFile(match[2]));\r\n                } else {\r\n                    var arg = match[2];\r\n                    var option = this.findOption(arg);\r\n                    if(option === null) {\r\n                        this.host.printLine(\"Unknown option '\" + arg + \"'\");\r\n                        this.host.printLine(\"Use the '--help' flag to see options\");\r\n                    } else {\r\n                        if(!option.flag) {\r\n                            value = consume();\r\n                        }\r\n                        option.set(value);\r\n                    }\r\n                }\r\n            } else {\r\n                this.unnamed.push(current);\r\n            }\r\n        }\r\n    };\r\n    return OptionsParser;\r\n})();\r\nvar CommandLineHost = (function () {\r\n    function CommandLineHost() {\r\n        this.pathMap = {\r\n        };\r\n        this.resolvedPaths = {\r\n        };\r\n    }\r\n    CommandLineHost.prototype.isResolved = function (path) {\r\n        return this.resolvedPaths[this.pathMap[path]] != undefined;\r\n    };\r\n    CommandLineHost.prototype.resolveCompilationEnvironment = function (preEnv, resolver, traceDependencies) {\r\n        var _this = this;\r\n        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);\r\n        var nCode = preEnv.code.length;\r\n        var nRCode = preEnv.residentCode.length;\r\n        var postResolutionError = function (errorFile, errorMessage) {\r\n            TypeScript.CompilerDiagnostics.debugPrint(\"Could not resolve file '\" + errorFile + \"'\" + (errorMessage == \"\" ? \"\" : \": \" + errorMessage));\r\n        };\r\n        var resolutionDispatcher = {\r\n            postResolutionError: postResolutionError,\r\n            postResolution: function (path, code) {\r\n                if(!_this.resolvedPaths[path]) {\r\n                    resolvedEnv.code.push(code);\r\n                    _this.resolvedPaths[path] = true;\r\n                }\r\n            }\r\n        };\r\n        var residentResolutionDispatcher = {\r\n            postResolutionError: postResolutionError,\r\n            postResolution: function (path, code) {\r\n                if(!_this.resolvedPaths[path]) {\r\n                    resolvedEnv.residentCode.push(code);\r\n                    _this.resolvedPaths[path] = true;\r\n                }\r\n            }\r\n        };\r\n        var path = \"\";\r\n        for(var i = 0; i < nRCode; i++) {\r\n            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.residentCode[i].path));\r\n            this.pathMap[preEnv.residentCode[i].path] = path;\r\n            resolver.resolveCode(path, \"\", false, residentResolutionDispatcher);\r\n        }\r\n        for(var i = 0; i < nCode; i++) {\r\n            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));\r\n            this.pathMap[preEnv.code[i].path] = path;\r\n            resolver.resolveCode(path, \"\", false, resolutionDispatcher);\r\n        }\r\n        return resolvedEnv;\r\n    };\r\n    return CommandLineHost;\r\n})();\r\nvar BatchCompiler = (function () {\r\n    function BatchCompiler(ioHost) {\r\n        this.ioHost = ioHost;\r\n        this.commandLineHost = new CommandLineHost();\r\n        this.resolvedEnvironment = null;\r\n        this.compilationSettings = new TypeScript.CompilationSettings();\r\n        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);\r\n    }\r\n    BatchCompiler.prototype.resolve = function () {\r\n        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);\r\n        var ret = this.commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);\r\n        for(var i = 0; i < this.compilationEnvironment.residentCode.length; i++) {\r\n            if(!this.commandLineHost.isResolved(this.compilationEnvironment.residentCode[i].path)) {\r\n                this.ioHost.stderr.WriteLine(\"Error reading file \\\"\" + this.compilationEnvironment.residentCode[i].path + \"\\\": File not found\");\r\n            }\r\n        }\r\n        for(var i = 0; i < this.compilationEnvironment.code.length; i++) {\r\n            if(!this.commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {\r\n                this.ioHost.stderr.WriteLine(\"Error reading file \\\"\" + this.compilationEnvironment.code[i].path + \"\\\": File not found\");\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    BatchCompiler.prototype.compile = function () {\r\n        var _this = this;\r\n        if(this.compilationSettings.outputFileName) {\r\n            this.compilationSettings.outputFileName = TypeScript.switchToForwardSlashes(this.ioHost.resolvePath(this.compilationSettings.outputFileName));\r\n        }\r\n        var outfile = this.compilationSettings.outputFileName ? this.ioHost.createFile(this.compilationSettings.outputFileName) : null;\r\n        var compiler;\r\n        var errout = null;\r\n        if(this.compilationSettings.errorFileName) {\r\n            errout = this.ioHost.createFile(this.compilationSettings.errorFileName);\r\n            compiler = new TypeScript.TypeScriptCompiler(outfile, errout, new TypeScript.NullLogger(), this.compilationSettings);\r\n            compiler.setErrorOutput(errout);\r\n        } else {\r\n            compiler = new TypeScript.TypeScriptCompiler(outfile, outfile, new TypeScript.NullLogger(), this.compilationSettings);\r\n            compiler.setErrorOutput(this.ioHost.stderr);\r\n            compiler.setErrorCallback(function (minChar, charLen, message, unitIndex) {\r\n                compiler.errorReporter.hasErrors = true;\r\n                var fname = _this.resolvedEnvironment.code[unitIndex].path;\r\n                var msg = fname + \" (\" + compiler.parser.scanner.line + \",\" + compiler.parser.scanner.col + \"): \" + message;\r\n                if(_this.compilationSettings.errorRecovery) {\r\n                    _this.ioHost.stderr.WriteLine(msg);\r\n                } else {\r\n                    throw new SyntaxError(msg);\r\n                }\r\n            });\r\n        }\r\n        if(this.compilationSettings.emitComments) {\r\n            compiler.emitCommentsToOutput();\r\n        }\r\n        var consumeUnit = function (code, addAsResident) {\r\n            try  {\r\n                if(!_this.compilationSettings.resolve) {\r\n                    code.content = _this.ioHost.readFile(code.path);\r\n                }\r\n                if(code.content) {\r\n                    if(_this.compilationSettings.parseOnly) {\r\n                        compiler.parseUnit(code.content, code.path);\r\n                    } else {\r\n                        if(_this.compilationSettings.errorRecovery) {\r\n                            compiler.parser.setErrorRecovery(outfile, -1, -1);\r\n                        }\r\n                        compiler.addUnit(code.content, code.path, addAsResident);\r\n                    }\r\n                }\r\n            } catch (err) {\r\n                compiler.errorReporter.hasErrors = true;\r\n                if(errout) {\r\n                    errout.WriteLine(err.message);\r\n                } else {\r\n                    _this.ioHost.stderr.WriteLine(err.message);\r\n                }\r\n            }\r\n        };\r\n        for(var iResCode = 0; iResCode < this.resolvedEnvironment.residentCode.length; iResCode++) {\r\n            if(!this.compilationSettings.parseOnly) {\r\n                consumeUnit(this.resolvedEnvironment.residentCode[iResCode], true);\r\n            }\r\n        }\r\n        for(var iCode = 0; iCode < this.resolvedEnvironment.code.length; iCode++) {\r\n            if(!this.compilationSettings.parseOnly || (iCode > 0)) {\r\n                consumeUnit(this.resolvedEnvironment.code[iCode], false);\r\n            }\r\n        }\r\n        if(!this.compilationSettings.parseOnly) {\r\n            compiler.typeCheck();\r\n            if(this.compilationSettings.generateDeclarationFiles && compiler.errorReporter.hasErrors) {\r\n                this.compilationSettings.generateDeclarationFiles = false;\r\n            }\r\n            try  {\r\n                compiler.emit(this.compilationSettings.outputMany, this.ioHost.createFile);\r\n            } catch (err) {\r\n                if(err.message != \"EmitError\") {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n        if(outfile) {\r\n            outfile.Close();\r\n        }\r\n        if(errout) {\r\n            errout.Close();\r\n        }\r\n        if(compiler.errorReporter.hasErrors) {\r\n            this.ioHost.quit(1);\r\n        }\r\n    };\r\n    BatchCompiler.prototype.run = function () {\r\n        for(var i = 0; i < this.compilationEnvironment.code.length; i++) {\r\n            var unit = this.compilationEnvironment.code[i];\r\n            var outputFileName = unit.path;\r\n            if(TypeScript.isTSFile(outputFileName)) {\r\n                outputFileName = outputFileName.replace(/\\.ts$/, \".js\");\r\n            } else {\r\n                if(TypeScript.isSTRFile(outputFileName)) {\r\n                    outputFileName = outputFileName.replace(/\\.str$/, \".js\");\r\n                }\r\n            }\r\n            if(this.ioHost.fileExists(outputFileName)) {\r\n                var unitRes = this.ioHost.readFile(outputFileName);\r\n                this.ioHost.run(unitRes, outputFileName);\r\n            }\r\n        }\r\n    };\r\n    BatchCompiler.prototype.batchCompile = function () {\r\n        var _this = this;\r\n        TypeScript.CompilerDiagnostics.diagnosticWriter = {\r\n            Alert: function (s) {\r\n                _this.ioHost.printLine(s);\r\n            }\r\n        };\r\n        var code;\r\n        var opts = new OptionsParser(this.ioHost);\r\n        opts.option('out', {\r\n            usage: 'Concatenate and emit output to single file',\r\n            type: 'file',\r\n            set: function (str) {\r\n                _this.compilationSettings.outputOne(str);\r\n            }\r\n        });\r\n        opts.option('style', {\r\n            usage: 'Select style checking options (examples --style requireSemi:off or --style \"eqeqeq;bitwise:off\")',\r\n            experimental: true,\r\n            set: function (str) {\r\n                _this.compilationSettings.setStyleOptions(str);\r\n            }\r\n        });\r\n        opts.flag('sourcemap', {\r\n            usage: 'Generates corresponding .map file',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.mapSourceFiles = true;\r\n            }\r\n        });\r\n        opts.flag('declarations', {\r\n            usage: 'Generates corresponding .d.ts file',\r\n            set: function () {\r\n                _this.compilationSettings.generateDeclarationFiles = true;\r\n            }\r\n        });\r\n        opts.option('reference', {\r\n            usage: 'Add a reference to the compilation',\r\n            type: 'file',\r\n            experimental: true,\r\n            set: function (str) {\r\n                code = new TypeScript.SourceUnit(str, null);\r\n                _this.compilationEnvironment.residentCode.push(code);\r\n            }\r\n        }, 'r');\r\n        if(this.ioHost.watchFiles) {\r\n            opts.flag('watch', {\r\n                usage: 'Watch output files',\r\n                set: function () {\r\n                    _this.compilationSettings.watch = true;\r\n                }\r\n            }, 'w');\r\n        }\r\n        opts.flag('exec', {\r\n            usage: 'Execute the script after compilation',\r\n            set: function () {\r\n                _this.compilationSettings.exec = true;\r\n            }\r\n        }, 'e');\r\n        opts.flag('parse', {\r\n            usage: 'Parse only',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.parseOnly = true;\r\n            }\r\n        });\r\n        opts.flag('minw', {\r\n            usage: 'Minimize whitespace',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.minWhitespace = true;\r\n            }\r\n        }, 'mw');\r\n        opts.flag('const', {\r\n            usage: 'Propagate constants to emitted code',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.propagateConstants = true;\r\n            }\r\n        });\r\n        opts.flag('errorrecovery', {\r\n            usage: 'Enable error recovery',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.errorRecovery = true;\r\n            }\r\n        }, 'er');\r\n        opts.flag('comments', {\r\n            usage: 'Emit comments to output',\r\n            set: function () {\r\n                _this.compilationSettings.emitComments = true;\r\n            }\r\n        }, 'c');\r\n        opts.flag('cflow', {\r\n            usage: 'Control flow',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.controlFlow = true;\r\n            }\r\n        });\r\n        opts.flag('cflowp', {\r\n            usage: 'Print control flow',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.controlFlow = true;\r\n                _this.compilationSettings.printControlFlow = true;\r\n            }\r\n        });\r\n        opts.flag('cflowu', {\r\n            usage: 'Print Use Def control flow',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.controlFlow = true;\r\n                _this.compilationSettings.controlFlowUseDef = true;\r\n            }\r\n        });\r\n        opts.flag('noerroronwith', {\r\n            usage: 'Allow with statements',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.errorOnWith = false;\r\n            }\r\n        });\r\n        opts.flag('noresolve', {\r\n            usage: 'Skip resolution and preprocessing',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.resolve = false;\r\n                _this.compilationSettings.preprocess = false;\r\n            }\r\n        });\r\n        opts.flag('debug', {\r\n            usage: 'Print debug output',\r\n            experimental: true,\r\n            set: function () {\r\n                TypeScript.CompilerDiagnostics.debug = true;\r\n            }\r\n        });\r\n        opts.flag('canCallDefinitionSignature', {\r\n            usage: 'Allows you to call the definition signature of an overload group',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.canCallDefinitionSignature = true;\r\n            }\r\n        });\r\n        opts.flag('nooptimizemodules', {\r\n            usage: 'Do not optimize module codegen',\r\n            experimental: true,\r\n            set: function () {\r\n                TypeScript.optimizeModuleCodeGen = false;\r\n            }\r\n        });\r\n        opts.flag('nolib', {\r\n            usage: 'Do not include a default lib.d.ts with global declarations',\r\n            set: function () {\r\n                _this.compilationSettings.useDefaultLib = false;\r\n            }\r\n        });\r\n        opts.flag('inferProperties', {\r\n            usage: 'Infer class properties from top-level assignments to \\'this\\'',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.inferPropertiesFromThisAssignment = true;\r\n            }\r\n        });\r\n        opts.option('target', {\r\n            usage: 'Specify ECMAScript target version: \"ES3\" (default), or \"ES5\"',\r\n            type: 'VER',\r\n            set: function (type) {\r\n                type = type.toLowerCase();\r\n                if(type === 'es3') {\r\n                    _this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES3;\r\n                } else {\r\n                    if(type === 'es5') {\r\n                        _this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES5;\r\n                    } else {\r\n                        _this.ioHost.printLine(\"ECMAScript target version '\" + type + \"' not supported.  Using default 'ES3' code generation\");\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        opts.option('module', {\r\n            usage: 'Specify module code generation: \"commonjs\" (default) or \"amd\"',\r\n            type: 'kind',\r\n            set: function (type) {\r\n                type = type.toLowerCase();\r\n                if(type === 'commonjs' || type === 'node') {\r\n                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;\r\n                } else {\r\n                    if(type === 'amd') {\r\n                        TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous;\r\n                    } else {\r\n                        _this.ioHost.printLine(\"Module code generation '\" + type + \"' not supported.  Using default 'commonjs' code generation\");\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        var printedUsage = false;\r\n        opts.flag('help', {\r\n            usage: 'Print this message',\r\n            set: function (type) {\r\n                opts.printUsage();\r\n                printedUsage = true;\r\n            }\r\n        }, 'h');\r\n        opts.flag('useCaseSensitiveFileResolution', {\r\n            usage: 'Force file resolution to be case sensitive',\r\n            experimental: true,\r\n            set: function () {\r\n                _this.compilationSettings.useCaseSensitiveFileResolution = true;\r\n            }\r\n        });\r\n        opts.parse(this.ioHost.arguments);\r\n        if(this.compilationSettings.useDefaultLib) {\r\n            var compilerFilePath = this.ioHost.getExecutingFilePath();\r\n            var binDirPath = this.ioHost.dirName(compilerFilePath);\r\n            var libStrPath = this.ioHost.resolvePath(binDirPath + \"\\\\lib.d.ts\");\r\n            code = new TypeScript.SourceUnit(libStrPath, null);\r\n            this.compilationEnvironment.code.push(code);\r\n        }\r\n        for(var i = 0; i < opts.unnamed.length; i++) {\r\n            code = new TypeScript.SourceUnit(opts.unnamed[i], null);\r\n            this.compilationEnvironment.code.push(code);\r\n        }\r\n        if(this.compilationEnvironment.code.length == (this.compilationSettings.useDefaultLib ? 1 : 0) && this.compilationEnvironment.residentCode.length == 0) {\r\n            if(!printedUsage) {\r\n                opts.printUsage();\r\n            }\r\n            return;\r\n        }\r\n        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;\r\n        if(this.compilationSettings.watch) {\r\n            var files = [];\r\n            for(var iResCode = 0; iResCode < this.resolvedEnvironment.residentCode.length; iResCode++) {\r\n                files.push(this.resolvedEnvironment.residentCode[iResCode].path);\r\n            }\r\n            for(var iCode = 0; iCode < this.resolvedEnvironment.code.length; iCode++) {\r\n                files.push(this.resolvedEnvironment.code[iCode].path);\r\n            }\r\n            if(this.ioHost.watchFiles) {\r\n                this.ioHost.watchFiles(files, function () {\r\n                    _this.ioHost.printLine(\"Recompiling(\" + new Date() + \"): \" + files);\r\n                    _this.compilationEnvironment.code = [];\r\n                    for(var i = 0; i < opts.unnamed.length; i++) {\r\n                        code = new TypeScript.SourceUnit(opts.unnamed[i], null);\r\n                        _this.compilationEnvironment.code.push(code);\r\n                    }\r\n                    _this.resolvedEnvironment = _this.compilationSettings.resolve ? _this.resolve() : _this.compilationEnvironment;\r\n                    _this.compile();\r\n                    if(_this.compilationSettings.exec) {\r\n                        _this.run();\r\n                    }\r\n                    _this.ioHost.printLine(\"\");\r\n                });\r\n            } else {\r\n                this.ioHost.printLine(\"Error: Current host does not support -w[atch] option\");\r\n            }\r\n        } else {\r\n            this.compile();\r\n            if(this.compilationSettings.exec) {\r\n                this.run();\r\n            }\r\n        }\r\n    };\r\n    return BatchCompiler;\r\n})();\r\nvar batch = new BatchCompiler(IO);\r\nbatch.batchCompile();\r\n"]],"start1":0,"start2":0,"length1":0,"length2":1115136}]],"length":1115136}
